# German translations for eu.jumplink.Learn6502 package
# Copyright (C) 2025 Pascal Garber
# This file is distributed under the CC-BY-4.0 license.
# Pascal Garber <pascal@mailfreun.de>, 2025.
# Pascal Garber <pascal@artandcode.studio>, 2025.
msgid ""
msgstr ""
"Project-Id-Version: eu.jumplink.Learn6502\n"
"Report-Msgid-Bugs-To: https://github.com/JumpLink/Learn6502/issues\n"
"POT-Creation-Date: 2025-04-14 11:47+0200\n"
"PO-Revision-Date: 2024-03-19 12:00+0100\n"
"Last-Translator: Pascal Garber <pascal@mailfreun.de>\n"
"Language-Team: German <de@li.org>\n"
"Language: de\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=n != 1;\n"
"X-Generator: Weblate 5.11-dev\n"
"License: CC-BY-4.0\n"

#: ../6502/src/assembler.ts:174
msgid "Unable to relocate code outside 64k memory"
msgstr "Code kann nicht außerhalb des 64k Speicherbereichs verschoben werden"

#: ../6502/src/assembler.ts:238
msgid "Assembling code ..."
msgstr "Code wird assembliert..."

#: ../6502/src/assembler.ts:256
msgid "No code to run."
msgstr "Kein Code zum Ausführen vorhanden."

#: ../6502/src/assembler.ts:263
#, javascript-format
msgid "Syntax error line %d: %s"
msgstr "Syntaxfehler in Zeile %d: %s"

#: ../6502/src/assembler.ts:266
#, javascript-format
msgid ""
"Out of range branch on line %d (branches are limited to -128 to +127): %s"
msgstr ""
"Sprungbefehl außerhalb des gültigen Bereichs in Zeile %d (Sprünge sind auf "
"-128 bis +127 begrenzt): %s"

#: ../6502/src/assembler.ts:275
#, javascript-format
msgid "Code assembled successfully, %d bytes."
msgstr "Code erfolgreich assembliert, %d Bytes."

#: ../6502/src/assembler.ts:410
msgid "Preprocessing ..."
msgstr "Vorverarbeitung läuft..."

#: ../6502/src/labels.ts:71
msgid "Found $d labels."
msgstr "%d Labels gefunden."

#: ../6502/src/labels.ts:73
msgid "Found $d label."
msgstr "%d Label gefunden."

#: ../6502/src/labels.ts:92
msgid "Indexing labels..."
msgstr "Labels werden indiziert..."

#: ../6502/src/labels.ts:95
#, javascript-format
msgid "Label already defined at line %s: %d"
msgstr "Label wurde bereits in Zeile %d definiert: %s"

#: ../6502/src/labels.ts:125
msgid "Label {label} is already used as a symbol; please rename one of them"
msgstr ""
"Label {label} wird bereits als Symbol verwendet; bitte eines davon umbenennen"

#: ../6502/src/simulator.ts:217
msgid "No address or label provided"
msgstr "Keine Adresse oder Label angegeben"

#: ../6502/src/simulator.ts:232
msgid "Unable to find/parse given address/label"
msgstr ""
"Die angegebene Adresse/Label konnte nicht gefunden oder verarbeitet werden"

#: ../6502/src/simulator.ts:261
msgid "Stopped"
msgstr "Angehalten"

#: ../6502/src/simulator.ts:1522
msgid "wdm-output"
msgstr "WDM-Ausgabe"

#: ../6502/src/simulator.ts:1595
#, javascript-format
msgid "Address %s - unknown opcode"
msgstr "Adresse %s - unbekannter Opcode"

#: ../6502/src/simulator.ts:1605
msgid "6502 Stack filled! Wrapping..."
msgstr "6502 Stack voll! Überlauf..."

#: ../6502/src/simulator.ts:1614
msgid "6502 Stack emptied! Wrapping..."
msgstr "6502 Stack leer! Unterlauf..."

#: ../6502/src/simulator.ts:1703
#, javascript-format
msgid "Program completed at PC=$%s"
msgstr "Programm beendet bei PC=$%s"

#: ../app-gnome/src/widgets/application-window.ts:55
msgid "Unsaved changes"
msgstr "Uneingespeicherte Änderungen"

#: ../app-gnome/src/widgets/application-window.ts:57
#, javascript-format
msgid "File \"%s\" has unsaved changes"
msgstr "Datei \"%s\" enthält ungespeicherte Änderungen"

#: ../app-gnome/src/widgets/application-window.ts:84
msgid "Assemble"
msgstr "Assemblieren"

#: ../app-gnome/src/widgets/application-window.ts:89
msgid "Run"
msgstr "Ausführen"

#: ../app-gnome/src/widgets/application-window.ts:94
msgid "Pause"
msgstr "Pause"

#: ../app-gnome/src/widgets/application-window.ts:99
msgid "Resume"
msgstr "Fortsetzen"

#: ../app-gnome/src/widgets/application-window.ts:104
msgid "Reset"
msgstr "Zurücksetzen"

#: ../app-gnome/src/widgets/application-window.ts:109
msgid "Step"
msgstr "Schritt"

#: ../app-gnome/src/widgets/application-window.ts:138
msgid "Code copied to editor"
msgstr "Code in Editor kopiert"

#: ../app-gnome/src/widgets/application-window.ts:163
msgid "Copied to clipboard"
msgstr "In die Zwischenablage kopiert"

#: ../app-gnome/src/widgets/application-window.ts:168
msgid "Failed to copy to clipboard"
msgstr "Konnte nicht in die Zwischenablage kopiert werden"

#: ../app-gnome/src/widgets/application-window.ts:219
#: ../app-gnome/src/widgets/application-window.ts:254
msgid "Program paused automatically"
msgstr "Programm automatisch pausiert"

#: ../app-gnome/src/widgets/application-window.ts:386
msgid "Assembled successfully"
msgstr "Erfolgreich assembliert"

#: ../app-gnome/src/widgets/application-window.ts:398
msgid "Assemble failed"
msgstr "Assemblierung fehlgeschlagen"

#: ../app-gnome/src/widgets/application-window.ts:406
msgid "Hexdump:"
msgstr "Hexdump:"

#: ../app-gnome/src/widgets/application-window.ts:413
msgid "Disassembly:"
msgstr "Disassemblierung:"

#: ../app-gnome/src/widgets/application-window.ts:492
msgid "Simulator failure"
msgstr "Simulator-Fehler"

#: ../app-gnome/src/widgets/application-window.ts:511
msgid "Labels failure"
msgstr "Label-Fehler"

#: ../app-gnome/src/widgets/application-window.ts:517
msgid "Gamepad key pressed:"
msgstr "Gamepad-Taste gedrückt:"

#: ../app-gnome/src/widgets/application-window.ts:702
msgid "Open Assembly File"
msgstr "Assembler-Datei öffnen"

#: ../app-gnome/src/widgets/application-window.ts:713
msgid "Failed to load file"
msgstr "Datei konnte nicht geladen werden"

#: ../app-gnome/src/widgets/application-window.ts:731
msgid "File loaded successfully"
msgstr "Datei erfolgreich geladen"

#: ../app-gnome/src/widgets/application-window.ts:737
msgid "Error opening file"
msgstr "Fehler beim Öffnen der Datei"

#: ../app-gnome/src/widgets/application-window.ts:753
#: ../app-gnome/src/widgets/application-window.ts:754
msgid "untitled"
msgstr "unbenannt"

#: ../app-gnome/src/widgets/application-window.ts:760
msgid "Save Assembly File"
msgstr "Assembler Datei speichern"

#: ../app-gnome/src/widgets/application-window.ts:773
#: ../app-gnome/src/widgets/application-window.ts:811
msgid "Error saving file"
msgstr "Fehler beim Speichern der Datei"

#: ../app-gnome/src/widgets/application-window.ts:804
msgid "File saved successfully"
msgstr "Datei erfolgreich gespeichert"

#: ../app-gnome/src/widgets/application-window.ts:822
msgid "Assembly Files"
msgstr "Assembler-Dateien"

#: ../app-gnome/src/widgets/application-window.ts:827
msgid "All Files"
msgstr "Alle Dateien"

#: ../app-gnome/src/widgets/application-window.blp:26
msgid "Learn 6502 Assembly"
msgstr "Lerne 6502 Assembler"

#: ../app-gnome/src/widgets/application-window.blp:33
msgid "Menu"
msgstr "Menü"

#: ../app-gnome/src/widgets/application-window.blp:63
#: ../app-gnome/src/widgets/learn.blp:8
msgid "Learn"
msgstr "Lernen"

#: ../app-gnome/src/widgets/application-window.blp:72
msgid "Editor"
msgstr "Editor"

#: ../app-gnome/src/widgets/application-window.blp:81
#: ../app-gnome/src/widgets/debugger/debugger.blp:15
msgid "Debugger"
msgstr "Debugger"

#: ../app-gnome/src/widgets/application-window.blp:90
msgid "Game Console"
msgstr "Spielkonsole"

#: ../app-gnome/src/widgets/application-window.blp:112
msgid "Open..."
msgstr "Öffnen..."

#: ../app-gnome/src/widgets/application-window.blp:117
#: ../app-gnome/src/widgets/application-window.blp:197
msgid "Save"
msgstr "Speichern"

#: ../app-gnome/src/widgets/application-window.blp:122
msgid "Save as..."
msgstr "Speichern unter..."

#: ../app-gnome/src/widgets/application-window.blp:143
#: ../app-gnome/src/widgets/editor.blp:8
#: ../app-gnome/src/widgets/help-window.blp:7
msgid "Help"
msgstr "Hilfe"

#: ../app-gnome/src/widgets/application-window.blp:148
msgid "About Learn 6502 Assembly"
msgstr "Über Lerne 6502 Assembler"

#: ../app-gnome/src/widgets/application-window.blp:153
msgid "Quit"
msgstr "Beenden"

#: ../app-gnome/src/widgets/application-window.blp:170
msgid "Continue"
msgstr "Fortfahren"

#: ../app-gnome/src/widgets/application-window.blp:190
msgid "Save changes?"
msgstr "Änderungen speichern?"

#: ../app-gnome/src/widgets/application-window.blp:191
msgid ""
"Your file has unsaved changes. Changes will be lost if you don't save them."
msgstr ""
"Deine Datei enthält ungespeicherte Änderungen. Die Änderungen gehen "
"verloren, wenn du sie nicht speicherst."

#: ../app-gnome/src/widgets/application-window.blp:195
msgid "Cancel"
msgstr "Abbrechen"

#: ../app-gnome/src/widgets/application-window.blp:196
msgid "Discard"
msgstr "Verwerfen"

#: ../app-gnome/src/widgets/learn.blp:9
msgid "Learn how to program the 6502 microprocessor."
msgstr "Lerne, wie man den 6502-Mikroprozessor programmiert."

#: ../app-gnome/src/widgets/preferences-dialog.blp:7
msgid "Preferences"
msgstr "Einstellungen"

#: ../app-gnome/src/widgets/preferences-dialog.blp:10
msgid "Appearance"
msgstr "Erscheinungsbild"

#: ../app-gnome/src/widgets/preferences-dialog.blp:14
msgid "Main Settings"
msgstr "Haupteinstellungen"

#: ../app-gnome/src/widgets/preferences-dialog.blp:15
msgid "There are currently no settings."
msgstr "Derzeit gibt es keine Einstellungen."

#: ../app-gnome/src/widgets/source-view.blp:34
msgid "Copy to editor"
msgstr "In Editor kopieren"

#: ../app-gnome/src/widgets/theme-selector.blp:24
#: ../app-gnome/src/widgets/theme-selector.blp:27
msgid "Follow system style"
msgstr ""

#: ../app-gnome/src/widgets/theme-selector.blp:43
#: ../app-gnome/src/widgets/theme-selector.blp:46
msgid "Light style"
msgstr ""

#: ../app-gnome/src/widgets/theme-selector.blp:62
#: ../app-gnome/src/widgets/theme-selector.blp:65
msgid "Dark style"
msgstr ""

#: ../app-gnome/src/widgets/debugger/debugger.blp:16
msgid ""
"Debug your 6502 assembly code, step through your program, and view memory "
"and registers. To get started, assemble and run your program."
msgstr ""
"Debugge deinen 6502-Assemblercode, gehe dein Programm schrittweise durch und "
"betrachte Speicher und Register. Kompiliere und starte dein Programm, um zu "
"beginnen."

#: ../app-gnome/src/widgets/debugger/debugger.blp:37
msgid "Information"
msgstr "Information"

#: ../app-gnome/src/widgets/debugger/debugger.blp:52
msgid "Messages"
msgstr "Meldungen"

#: ../app-gnome/src/widgets/debugger/debugger.blp:67
msgid "Hex Monitor"
msgstr "Hex-Monitor"

#: ../app-gnome/src/widgets/debugger/debugger.blp:82
msgid "Hexdump"
msgstr "Hexdump"

#: ../app-gnome/src/widgets/debugger/debugger.blp:97
msgid "Disassembled"
msgstr "Disassemblierter Code"

#: ../app-gnome/src/widgets/debugger/hex-monitor.blp:19
msgid "Zero Page ($0000-$00FF)"
msgstr "Nullseite ($0000-$00FF)"

#: ../app-gnome/src/widgets/debugger/hex-monitor.blp:20
msgid "Stack ($0100-$01FF)"
msgstr "Stack ($0100-$01FF)"

#: ../app-gnome/src/widgets/debugger/hex-monitor.blp:21
msgid "Display Memory ($0200-$05FF)"
msgstr "Anzeigespeicher ($0200-$05FF)"

#: ../app-gnome/src/widgets/debugger/hex-monitor.blp:22
msgid "Program Storage ($0600-$FFFF)"
msgstr "Programmspeicher ($0600-$FFFF)"

#: ../app-gnome/src/widgets/debugger/hex-monitor.blp:23
msgid "Snake Game Data ($00-$15)"
msgstr "Snake-Spieldaten ($00-$15)"

#: ../app-gnome/src/widgets/debugger/hex-monitor.blp:24
msgid "Random/Input ($FE-$FF)"
msgstr "Zufalls-/Eingabedaten ($FE-$FF)"

#: ../app-gnome/src/widgets/debugger/hex-monitor.blp:25
msgid "Full Memory ($0000-$FFFF)"
msgstr "Gesamter Speicher ($0000-$FFFF)"

#: ../app-gnome/src/widgets/debugger/hex-monitor.blp:35
#: ../app-gnome/src/widgets/debugger/hexdump.blp:9
msgid "Copy to clipboard"
msgstr "In die Zwischenablage kopieren"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:7
msgid "6502 Assembly Learning Environment"
msgstr "Lernumgebung für 6502-Assembler"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:9
msgid ""
"A comprehensive learning environment for programming vintage computers and "
"game consoles using 6502 assembly language."
msgstr ""
"Eine umfassende Lernumgebung für die Programmierung von Retro-Computern und "
"Spielkonsolen mit 6502-Assembler."

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:12
msgid "Features:"
msgstr "Funktionen:"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:14
msgid "Learn step-by-step with an interactive tutorial"
msgstr "Lerne Schritt für Schritt mit einem interaktiven Tutorial"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:15
msgid "Write code with a built-in editor"
msgstr "Schreibe Code mit einem integrierten Editor"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:16
msgid "Debug your programs with real-time tools"
msgstr "Debugge deine Programme mit Echtzeit-Tools"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:17
msgid "See your code run on a virtual game console"
msgstr "Führe deinen Code auf einer virtuellen Spielkonsole aus"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:24
msgid "Interactive tutorial interface in light theme"
msgstr "Interaktive Tutorial-Oberfläche im hellen Design"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:28
msgid "Interactive tutorial interface in dark theme"
msgstr "Interaktive Tutorial-Oberfläche im dunklen Design"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:32
msgid "Code editor with 6502 assembly syntax highlighting and visible help"
msgstr ""
"Code-Editor mit Syntaxhervorhebung für 6502-Assembler und sichtbarer Hilfe"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:36
msgid "Built-in debugger showing real-time registers, flags, and memory"
msgstr ""
"Integrierter Debugger mit Echtzeit-Anzeige von Registern, Flags und Speicher"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:40
msgid "Virtual game console displaying three colored pixels"
msgstr "Virtuelle Spielkonsole mit drei farbigen Pixeln"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:55
msgid "Major update focusing on improved learning experience and usability"
msgstr ""
"Umfangreiches Update mit Fokus auf verbessertes Lernerlebnis und "
"Benutzerfreundlichkeit"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:57
msgid "Added help feature to make code editing easier for beginners"
msgstr ""
"Hilfefunktion hinzugefügt, um die Codebearbeitung für Anfänger zu erleichtern"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:58
msgid "Improved game screen and controls for mobile devices"
msgstr "Verbesserte Spieloberfläche und Steuerung für mobile Geräte"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:59
msgid ""
"New tools to examine your code, including disassembler and fast switchable "
"memory viewer"
msgstr ""
"Neue Werkzeuge zur Code-Analyse, einschließlich Disassembler und schnell "
"umschaltbarer Speicheransicht"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:60
msgid "Many minor bugs have been fixed to improve overall usability"
msgstr ""
"Zahlreiche kleine Fehler wurden behoben, um die allgemeine "
"Benutzerfreundlichkeit zu verbessern"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:61
msgid "Games now automatically pause when switching between screens"
msgstr ""
"Spiele werden jetzt automatisch pausiert, wenn zwischen Bildschirmen "
"gewechselt wird"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:62
msgid "Added file management to save and load your programs"
msgstr "Dateiverwaltung zum Speichern und Laden von Programmen hinzugefügt"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:68
msgid "Enhanced app presentation and accessibility"
msgstr "Verbesserte App-Darstellung und Zugänglichkeit"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:69
msgid "Improved descriptions to be more welcoming for non-technical users"
msgstr "Verbesserte Beschreibungen für nicht-technische Benutzer"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:70
msgid "Optimized Flatpak configuration by removing unnecessary permissions"
msgstr ""
"Optimierte Flatpak-Konfiguration durch Entfernen unnötiger Berechtigungen"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:75
msgid "Improved the game console performance for smoother gameplay"
msgstr "Verbesserte Leistung der Spielekonsole für flüssigeres Gameplay"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:76
msgid "Enhanced the hex monitor address range input for easier value editing"
msgstr "Verbesserte Eingabe des Adressbereichs im Hex-Monitor"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:77
msgid "Reduced default hex monitor address range for better efficiency"
msgstr ""
"Reduzierter Standard-Adressbereich des Hex-Monitors für bessere Effizienz"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:78
msgid "Debugger now only updates when visible, reducing unnecessary processing"
msgstr ""
"Debugger wird nur noch aktualisiert, wenn er sichtbar ist, reduziert "
"unnötige Verarbeitung"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:79
msgid "Fixed build error on PostmarketOS, improving mobile compatibility"
msgstr ""
"Build-Fehler unter PostmarketOS behoben, verbessert Kompatibilität mit "
"Mobilgeräten"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:84
msgid "First release of Learn 6502 Assembly for GNOME"
msgstr "Erste Veröffentlichung von Lerne 6502 Assembler für GNOME"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:97
msgid "6502"
msgstr "6502"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:98
msgid "Assembly"
msgstr "Assembler"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:99
msgid "Programming"
msgstr "Programmierung"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:100
msgid "Learning"
msgstr "Lernen"

#: ../app-gnome/data/metainfo/eu.jumplink.Learn6502.metainfo.xml.in:101
msgid "Emulator"
msgstr "Emulator"

#: ../learn/dist/quick-help.ui:1
msgid "Memory Map"
msgstr "Speicherbelegung"

#: ../learn/dist/quick-help.ui:2 ../learn/dist/quick-help.ui:4
#: ../learn/dist/quick-help.ui:6 ../learn/dist/quick-help.ui:8
#: ../learn/dist/quick-help.ui:10 ../learn/dist/quick-help.ui:12
#: ../learn/dist/quick-help.ui:14 ../learn/dist/quick-help.ui:16
#: ../learn/dist/quick-help.ui:18 ../learn/dist/quick-help.ui:20
#: ../learn/dist/quick-help.ui:22
msgid "•"
msgstr ""

#: ../learn/dist/quick-help.ui:2
msgid ""
"<b>Zero Page</b>: <tt>$0000</tt>-<tt>$00FF</tt> (first 256 bytes, faster "
"access)"
msgstr ""
"<b>Zero Page</b>: <tt>$0000</tt>-<tt>$00FF</tt> (erste 256 Bytes, "
"schnellerer Zugriff)"

#: ../learn/dist/quick-help.ui:2
msgid "<b>Stack</b>: <tt>$0100</tt>-<tt>$01FF</tt>"
msgstr "<b>Stack</b>: <tt>$0100</tt>-<tt>$01FF</tt>"

#: ../learn/dist/quick-help.ui:2
msgid ""
"<b>Display Memory</b>: <tt>$0200</tt>-<tt>$05FF</tt> (used for screen output)"
msgstr ""
"<b>Anzeigespeicher</b>: <tt>$0200</tt>-<tt>$05FF</tt> (für Bildschirmausgabe)"

#: ../learn/dist/quick-help.ui:2
msgid "<b>Program Storage</b>: Starting at <tt>$0600</tt>"
msgstr "<b>Programmspeicher</b>: Beginnt bei <tt>$0600</tt>"

#: ../learn/dist/quick-help.ui:3
msgid "Display Organization"
msgstr "Bildschirmorganisation"

#: ../learn/dist/quick-help.ui:4
msgid "Screen maps to memory range <tt>$0200</tt>-<tt>$05FF</tt>"
msgstr ""
"Bildschirm wird auf Speicherbereich <tt>$0200</tt>-<tt>$05FF</tt> abgebildet"

#: ../learn/dist/quick-help.ui:4
msgid ""
"Values <tt>$00</tt>-<tt>$0F</tt> represent 16 different colors (<tt>$00</"
"tt>=black, <tt>$01</tt>=white)"
msgstr ""
"Werte <tt>$00</tt>-<tt>$0F</tt> stellen 16 verschiedene Farben dar (<tt>$00</"
"tt>=schwarz, <tt>$01</tt>=weiß)"

#: ../learn/dist/quick-help.ui:4
msgid "Organized as four horizontal strips of 32×8 pixels"
msgstr "Organisiert als vier horizontale Streifen von 32×8 Pixeln"

#: ../learn/dist/quick-help.ui:4
msgid ""
"First row: <tt>$0200</tt>-<tt>$021F</tt>, second row: <tt>$0220</tt>-"
"<tt>$023F</tt>, etc."
msgstr ""
"Erste Zeile: <tt>$0200</tt>-<tt>$021F</tt>, zweite Zeile: <tt>$0220</tt>-"
"<tt>$023F</tt>, usw."

#: ../learn/dist/quick-help.ui:5
msgid "Color Palette"
msgstr "Farbpalette"

#: ../learn/dist/quick-help.ui:6
msgid "<b><tt>$0</tt></b>: Black (<tt>#000000</tt>)"
msgstr "<b><tt>$0</tt></b>: Schwarz (<tt>#000000</tt>)"

#: ../learn/dist/quick-help.ui:6
msgid "<b><tt>$1</tt></b>: White (<tt>#ffffff</tt>)"
msgstr "<b><tt>$1</tt></b>: Weiß (<tt>#ffffff</tt>)"

#: ../learn/dist/quick-help.ui:6
msgid "<b><tt>$2</tt></b>: Red (<tt>#880000</tt>)"
msgstr "<b><tt>$2</tt></b>: Rot (<tt>#880000</tt>)"

#: ../learn/dist/quick-help.ui:6
msgid "<b><tt>$3</tt></b>: Cyan (<tt>#aaffee</tt>)"
msgstr "<b><tt>$3</tt></b>: Cyan (<tt>#aaffee</tt>)"

#: ../learn/dist/quick-help.ui:6
msgid "<b><tt>$4</tt></b>: Purple (<tt>#cc44cc</tt>)"
msgstr "<b><tt>$4</tt></b>: Lila (<tt>#cc44cc</tt>)"

#: ../learn/dist/quick-help.ui:6
msgid "<b><tt>$5</tt></b>: Green (<tt>#00cc55</tt>)"
msgstr "<b><tt>$5</tt></b>: Grün (<tt>#00cc55</tt>)"

#: ../learn/dist/quick-help.ui:6
msgid "<b><tt>$6</tt></b>: Blue (<tt>#0000aa</tt>)"
msgstr "<b><tt>$6</tt></b>: Blau (<tt>#0000aa</tt>)"

#: ../learn/dist/quick-help.ui:6
msgid "<b><tt>$7</tt></b>: Yellow (<tt>#eeee77</tt>)"
msgstr "<b><tt>$7</tt></b>: Gelb (<tt>#eeee77</tt>)"

#: ../learn/dist/quick-help.ui:6
msgid "<b><tt>$8</tt></b>: Orange (<tt>#dd8855</tt>)"
msgstr "<b><tt>$8</tt></b>: Orange (<tt>#dd8855</tt>)"

#: ../learn/dist/quick-help.ui:6
msgid "<b><tt>$9</tt></b>: Brown (<tt>#664400</tt>)"
msgstr "<b><tt>$9</tt></b>: Braun (<tt>#664400</tt>)"

#: ../learn/dist/quick-help.ui:6
msgid "<b><tt>$a</tt></b>: Light red (<tt>#ff7777</tt>)"
msgstr "<b><tt>$a</tt></b>: Hellrot (<tt>#ff7777</tt>)"

#: ../learn/dist/quick-help.ui:6
msgid "<b><tt>$b</tt></b>: Dark grey (<tt>#333333</tt>)"
msgstr "<b><tt>$b</tt></b>: Dunkelgrau (<tt>#333333</tt>)"

#: ../learn/dist/quick-help.ui:6
msgid "<b><tt>$c</tt></b>: Grey (<tt>#777777</tt>)"
msgstr "<b><tt>$c</tt></b>: Grau (<tt>#777777</tt>)"

#: ../learn/dist/quick-help.ui:6
msgid "<b><tt>$d</tt></b>: Light green (<tt>#aaff66</tt>)"
msgstr "<b><tt>$d</tt></b>: Hellgrün (<tt>#aaff66</tt>)"

#: ../learn/dist/quick-help.ui:6
msgid "<b><tt>$e</tt></b>: Light blue (<tt>#0088ff</tt>)"
msgstr "<b><tt>$e</tt></b>: Hellblau (<tt>#0088ff</tt>)"

#: ../learn/dist/quick-help.ui:6
msgid "<b><tt>$f</tt></b>: Light grey (<tt>#bbbbbb</tt>)"
msgstr "<b><tt>$f</tt></b>: Hellgrau (<tt>#bbbbbb</tt>)"

#: ../learn/dist/quick-help.ui:7
msgid "Registers"
msgstr "Register"

#: ../learn/dist/quick-help.ui:8
msgid ""
"<b>A</b> (Accumulator): Main register for calculations and data manipulation"
msgstr ""
"<b>A</b> (Akkumulator): Hauptregister für Berechnungen und Datenmanipulation"

#: ../learn/dist/quick-help.ui:8
msgid "<b>X, Y</b>: Index registers for addressing and counting"
msgstr "<b>X, Y</b>: Indexregister für Adressierung und Zählung"

#: ../learn/dist/quick-help.ui:8
msgid ""
"<b>SP</b> (Stack Pointer): Points to current stack position (starts at "
"<tt>$FF</tt>)"
msgstr ""
"<b>SP</b> (Stack Pointer): Zeigt auf aktuelle Stack-Position (beginnt bei "
"<tt>$FF</tt>)"

#: ../learn/dist/quick-help.ui:8
msgid "<b>PC</b> (Program Counter): Points to the next instruction to execute"
msgstr ""
"<b>PC</b> (Program Counter): Zeigt auf die nächste auszuführende Anweisung"

#: ../learn/dist/quick-help.ui:9
msgid "Processor Flags"
msgstr "Prozessor-Flags"

#: ../learn/dist/quick-help.ui:10
msgid "<b>N</b> (Negative): Set when bit 7 of result is set"
msgstr "<b>N</b> (Negativ): Gesetzt, wenn Bit 7 des Ergebnisses gesetzt ist"

#: ../learn/dist/quick-help.ui:10
msgid ""
"<b>V</b> (Overflow): Set when arithmetic operation causes signed overflow"
msgstr ""
"<b>V</b> (Überlauf): Gesetzt, wenn arithmetische Operation einen "
"Vorzeichenüberlauf verursacht"

#: ../learn/dist/quick-help.ui:10
msgid "<b>B</b> (Break): Set when BRK instruction is executed"
msgstr "<b>B</b> (Break): Gesetzt, wenn BRK-Anweisung ausgeführt wird"

#: ../learn/dist/quick-help.ui:10
msgid ""
"<b>D</b> (Decimal): Set when processor is in BCD (Binary Coded Decimal) mode"
msgstr ""
"<b>D</b> (Dezimal): Gesetzt, wenn Prozessor im BCD-Modus (Binary Coded "
"Decimal) ist"

#: ../learn/dist/quick-help.ui:10
msgid "<b>I</b> (Interrupt): Set when interrupts are disabled"
msgstr "<b>I</b> (Interrupt): Gesetzt, wenn Interrupts deaktiviert sind"

#: ../learn/dist/quick-help.ui:10
msgid "<b>Z</b> (Zero): Set when result is zero"
msgstr "<b>Z</b> (Null): Gesetzt, wenn Ergebnis null ist"

#: ../learn/dist/quick-help.ui:10
msgid "<b>C</b> (Carry): Set when arithmetic operations overflow a byte"
msgstr ""
"<b>C</b> (Übertrag): Gesetzt, wenn arithmetische Operationen ein Byte "
"überlaufen"

#: ../learn/dist/quick-help.ui:10
msgid "Used for conditional branching"
msgstr "Wird für bedingte Verzweigungen verwendet"

#: ../learn/dist/quick-help.ui:11
msgid "Addressing Modes"
msgstr "Adressierungsmodi"

#: ../learn/dist/quick-help.ui:12
msgid "<b>Immediate</b> (<tt>#$c0</tt>): Use the actual value"
msgstr "<b>Unmittelbar</b> (<tt>#$c0</tt>): Verwendet den tatsächlichen Wert"

#: ../learn/dist/quick-help.ui:12
msgid ""
"<b>Zero Page</b> (<tt>$c0</tt>): Access memory locations <tt>$00</tt>-"
"<tt>$FF</tt>"
msgstr ""
"<b>Nullseite</b> (<tt>$c0</tt>): Greift auf Speicheradressen <tt>$00</tt>-"
"<tt>$FF</tt> zu"

#: ../learn/dist/quick-help.ui:12
msgid "<b>Absolute</b> (<tt>$c000</tt>): Access any memory location"
msgstr ""
"<b>Absolut</b> (<tt>$c000</tt>): Greift auf beliebige Speicheradressen zu"

#: ../learn/dist/quick-help.ui:12
msgid ""
"<b>Zero Page,X/Y</b> (<tt>$c0,X</tt>): Add X/Y register to zero page address"
msgstr ""
"<b>Nullseite,X/Y</b> (<tt>$c0,X</tt>): Addiert X/Y-Register zur "
"Nullseitenadresse"

#: ../learn/dist/quick-help.ui:12
msgid ""
"<b>Absolute,X/Y</b> (<tt>$c000,X</tt>): Add X/Y register to absolute address"
msgstr ""
"<b>Absolut,X/Y</b> (<tt>$c000,X</tt>): Addiert X/Y-Register zur absoluten "
"Adresse"

#: ../learn/dist/quick-help.ui:12
msgid ""
"<b>Indirect</b> (<tt>($c000)</tt>): Look up address stored at given location"
msgstr ""
"<b>Indirekt</b> (<tt>($c000)</tt>): Liest die an der angegebenen Adresse "
"gespeicherte Adresse"

#: ../learn/dist/quick-help.ui:12
msgid ""
"<b>Indexed Indirect</b> (<tt>($c0,X)</tt>): Add X to zero page address, then "
"dereference"
msgstr ""
"<b>Indiziert Indirekt</b> (<tt>($c0,X)</tt>): Addiert X zur "
"Nullseitenadresse, dann dereferenzieren"

#: ../learn/dist/quick-help.ui:12
msgid ""
"<b>Indirect Indexed</b> (<tt>($c0),Y</tt>): Dereference zero page address, "
"then add Y"
msgstr ""
"<b>Indirekt Indiziert</b> (<tt>($c0),Y</tt>): Dereferenziert "
"Nullseitenadresse, dann Y addieren"

#: ../learn/dist/quick-help.ui:13
msgid "Common Instructions"
msgstr "Häufige Anweisungen"

#: ../learn/dist/quick-help.ui:14
msgid "<b>LDA/LDX/LDY</b>: Load registers"
msgstr "<b>LDA/LDX/LDY</b>: Register laden"

#: ../learn/dist/quick-help.ui:14
msgid "<b>STA/STX/STY</b>: Store registers to memory"
msgstr "<b>STA/STX/STY</b>: Register im Speicher ablegen"

#: ../learn/dist/quick-help.ui:14
msgid "<b>INX/INY/DEX/DEY</b>: Increment/decrement registers"
msgstr "<b>INX/INY/DEX/DEY</b>: Register erhöhen/verringern"

#: ../learn/dist/quick-help.ui:14
msgid "<b>ADC/SBC</b>: Add/subtract with carry"
msgstr "<b>ADC/SBC</b>: Addieren/Subtrahieren mit Übertrag"

#: ../learn/dist/quick-help.ui:14
msgid "<b>JMP</b>: Unconditional jump"
msgstr "<b>JMP</b>: Unbedingter Sprung"

#: ../learn/dist/quick-help.ui:14
msgid "<b>JSR/RTS</b>: Jump to subroutine / Return from subroutine"
msgstr "<b>JSR/RTS</b>: Sprung zu Unterprogramm / Rückkehr aus Unterprogramm"

#: ../learn/dist/quick-help.ui:14
msgid "<b>BEQ/BNE/BCC/BCS</b>: Branch if equal/not equal/carry clear/carry set"
msgstr ""
"<b>BEQ/BNE/BCC/BCS</b>: Verzweige wenn gleich/ungleich/Übertrag gelöscht/"
"Übertrag gesetzt"

#: ../learn/dist/quick-help.ui:14
msgid "<b>PHA/PLA</b>: Push/pull accumulator to/from stack"
msgstr "<b>PHA/PLA</b>: Akkumulator auf Stack legen/vom Stack holen"

#: ../learn/dist/quick-help.ui:15
msgid "Special Memory Locations (in Simulator)"
msgstr "Spezielle Speicheradressen (im Simulator)"

#: ../learn/dist/quick-help.ui:16
msgid ""
"<b><tt>$FE</tt></b>: Random number generator (reads as a random value 0-255)"
msgstr ""
"<b><tt>$FE</tt></b>: Zufallszahlengenerator (liefert einen Zufallswert 0-255)"

#: ../learn/dist/quick-help.ui:16
msgid "<b><tt>$FF</tt></b>: Last pressed key (ASCII code)"
msgstr "<b><tt>$FF</tt></b>: Zuletzt gedrückte Taste (ASCII-Code)"

#: ../learn/dist/quick-help.ui:17
msgid "<b>Directional controls</b>:"
msgstr "<b>Richtungssteuerung</b>:"

#: ../learn/dist/quick-help.ui:18
msgid "<b>W</b> or Up Arrow key (<tt>$77</tt>)"
msgstr "<b>W</b> oder Pfeil nach oben (<tt>$77</tt>)"

#: ../learn/dist/quick-help.ui:18
msgid "<b>A</b> or Left Arrow key (<tt>$61</tt>)"
msgstr "<b>A</b> oder Pfeil nach links (<tt>$61</tt>)"

#: ../learn/dist/quick-help.ui:18
msgid "<b>S</b> or Down Arrow key (<tt>$73</tt>)"
msgstr "<b>S</b> oder Pfeil nach unten (<tt>$73</tt>)"

#: ../learn/dist/quick-help.ui:18
msgid "<b>D</b> or Right Arrow key (<tt>$64</tt>)"
msgstr "<b>D</b> oder Pfeil nach rechts (<tt>$64</tt>)"

#: ../learn/dist/quick-help.ui:19
msgid "<b>Action buttons</b>:"
msgstr "<b>Aktionstasten</b>:"

#: ../learn/dist/quick-help.ui:20
msgid "<b>Q</b> or Enter/Return key (<tt>$0D</tt>)"
msgstr "<b>Q</b> oder Eingabe/Return-Taste (<tt>$0D</tt>)"

#: ../learn/dist/quick-help.ui:20
msgid "<b>E</b> or Space key (<tt>$20</tt>)"
msgstr "<b>E</b> oder Leertaste (<tt>$20</tt>)"

#: ../learn/dist/quick-help.ui:21
msgid "Snake Game Memory Usage"
msgstr "Speichernutzung im Snake-Spiel"

#: ../learn/dist/quick-help.ui:22
msgid "<b><tt>$00</tt>-<tt>$01</tt></b>: Apple position"
msgstr "<b><tt>$00</tt>-<tt>$01</tt></b>: Apfel-Position"

#: ../learn/dist/quick-help.ui:22
msgid "<b><tt>$02</tt></b>: Snake direction (1=up, 2=right, 4=down, 8=left)"
msgstr ""
"<b><tt>$02</tt></b>: Schlangen-Richtung (1=oben, 2=rechts, 4=unten, 8=links)"

#: ../learn/dist/quick-help.ui:22
msgid "<b><tt>$03</tt></b>: Snake length"
msgstr "<b><tt>$03</tt></b>: Schlangen-Länge"

#: ../learn/dist/quick-help.ui:22
msgid ""
"<b><tt>$10</tt>-<tt>$15</tt></b>: Snake position data (head, body segments, "
"tail)"
msgstr ""
"<b><tt>$10</tt>-<tt>$15</tt></b>: Schlangen-Positionsdaten (Kopf, "
"Körpersegmente, Schwanz)"

#: ../learn/dist/tutorial.ui:1
msgid ""
"Tutorial <sub>by <a href=\"https://www.skilldrick.co.uk/\">Nick Morgan</a>, "
"licensed under CC BY 4.0</sub>"
msgstr ""
"Tutorial <sub>von <a href=\"https://www.skilldrick.co.uk/\">Nick Morgan</a>, "
"lizenziert unter CC BY 4.0</sub>"

#: ../learn/dist/tutorial.ui:2
msgid "Introduction"
msgstr "Einführung"

#: ../learn/dist/tutorial.ui:3
msgid ""
"In this tiny tutorial I'm going to show you how to get started writing 6502 "
"assembly language. The 6502 processor was massive in the seventies and "
"eighties, powering famous computers like the <a href=\"http://en.wikipedia."
"org/wiki/BBC_Micro\">BBC Micro</a>, <a href=\"http://en.wikipedia.org/wiki/"
"Atari_2600\">Atari 2600</a>, <a href=\"http://en.wikipedia.org/wiki/"
"Commodore_64\">Commodore 64</a>, <a href=\"http://en.wikipedia.org/wiki/"
"Apple_II\">Apple II</a>, and the <a href=\"http://en.wikipedia.org/wiki/"
"Nintendo_Entertainment_System\">Nintendo Entertainment System</a>. Bender in "
"Futurama <a href=\"http://www.transbyte.org/SID/SID-files/Bender_6502."
"jpg\">has a 6502 processor for a brain</a>. <a href=\"http://www.pagetable."
"com/docs/terminator/00-37-23.jpg\">Even the Terminator was programmed in "
"6502</a>."
msgstr ""
"In diesem kleinen Tutorial zeige ich dir, wie du mit der 6502-"
"Assemblersprache loslegen kannst. Der 6502-Prozessor war in den Siebzigern "
"und Achtzigern riesig und trieb berühmte Computer wie den <a href=\"http://"
"en.wikipedia.org/wiki/BBC_Micro\">BBC Micro</a>, <a href=\"http://en."
"wikipedia.org/wiki/Atari_2600\">Atari 2600</a>, <a href=\"http://en."
"wikipedia.org/wiki/Commodore_64\">Commodore 64</a>, <a href=\"http://en."
"wikipedia.org/wiki/Apple_II\">Apple II</a> und das <a href=\"http://en."
"wikipedia.org/wiki/Nintendo_Entertainment_System\">Nintendo Entertainment "
"System</a> an. Bender aus Futurama <a href=\"http://www.transbyte.org/SID/"
"SID-files/Bender_6502.jpg\">hat einen 6502-Prozessor als Gehirn</a>. <a "
"href=\"http://www.pagetable.com/docs/terminator/00-37-23.jpg\">Sogar der "
"Terminator wurde in 6502 programmiert</a>."

#: ../learn/dist/tutorial.ui:4
msgid ""
"So, why would you want to learn 6502? It's a dead language isn't it? Well, "
"so's Latin. And they still teach that. <a href=\"http://en.wikipedia.org/"
"wiki/Q.E.D.\">Q.E.D.</a>"
msgstr ""
"Warum solltest du also 6502 lernen wollen? Es ist doch eine tote Sprache, "
"oder? Nun, Latein ist das auch. Und das wird immer noch unterrichtet. <a "
"href=\"http://en.wikipedia.org/wiki/Q.E.D.\">Q.E.D.</a>"

#: ../learn/dist/tutorial.ui:5
msgid ""
"(Actually, I've been reliably informed that 6502 processors are still being "
"produced by <a href=\"http://www.westerndesigncenter.com/wdc/w65c02s-chip."
"cfm\">Western Design Center</a> and <a href=\"http://www.mouser.co.uk/Search/"
"Refine.aspx?Keyword=65C02\">sold to hobbyists</a>, so clearly 6502 isn't a "
"dead language! Who knew?)"
msgstr ""
"(Tatsächlich wurde mir zuverlässig mitgeteilt, dass 6502-Prozessoren immer "
"noch von <a href=\"http://www.westerndesigncenter.com/wdc/w65c02s-chip."
"cfm\">Western Design Center</a> hergestellt und <a href=\"http://www.mouser."
"co.uk/Search/Refine.aspx?Keyword=65C02\">an Bastler verkauft</a> werden, "
"also ist 6502 offensichtlich keine tote Sprache! Wer hätte das gedacht?)"

#: ../learn/dist/tutorial.ui:6
msgid ""
"Seriously though, I think it's valuable to have an understanding of assembly "
"language. Assembly language is the lowest level of abstraction in computers "
"- the point at which the code is still readable. Assembly language "
"translates directly to the bytes that are executed by your computer's "
"processor. If you understand how it works, you've basically become a "
"computer <a href=\"http://skilldrick.co.uk/2011/04/magic-in-software-"
"development/\">magician</a>."
msgstr ""
"Aber ernsthaft, ich denke es ist wertvoll, ein Verständnis für "
"Assemblersprache zu haben. Assemblersprache ist die niedrigste "
"Abstraktionsebene in Computern - der Punkt, an dem der Code noch lesbar ist. "
"Assemblersprache wird direkt in die Bytes übersetzt, die von deinem "
"Computerprozessor ausgeführt werden. Wenn du verstehst, wie es funktioniert, "
"bist du im Grunde ein Computer-<a href=\"http://skilldrick.co.uk/2011/04/"
"magic-in-software-development/\">Magier</a> geworden."

#: ../learn/dist/tutorial.ui:7
msgid ""
"Then why 6502? Why not a useful assembly language, like <a href=\"http://en."
"wikipedia.org/wiki/X86\">x86</a>? Well, I don't think learning x86 is "
"useful. I don't think you'll ever have to write assembly language in your "
"day job - this is purely an academic exercise, something to expand your mind "
"and your thinking. 6502 was originally written in a different age, a time "
"when the majority of developers were writing assembly directly, rather than "
"in these new-fangled high-level programming languages. So, it was designed "
"to be written by humans. More modern assembly languages are meant to written "
"by compilers, so let's leave it to them. Plus, 6502 is fun. Nobody ever "
"called x86 fun."
msgstr ""
"Warum dann 6502? Warum nicht eine nützliche Assemblersprache wie <a "
"href=\"http://en.wikipedia.org/wiki/X86\">x86</a>? Nun, ich denke nicht, "
"dass das Lernen von x86 nützlich ist. Ich glaube nicht, dass du jemals in "
"deinem Arbeitsalltag Assemblersprache schreiben musst - dies ist eine rein "
"akademische Übung, etwas um deinen Geist und dein Denken zu erweitern. 6502 "
"wurde ursprünglich in einer anderen Zeit geschrieben, als die Mehrheit der "
"Entwickler direkt in Assembler programmierte, statt in diesen neumodischen "
"höheren Programmiersprachen. Daher wurde es für Menschen geschrieben. "
"Modernere Assemblersprachen sind dafür gedacht, von Compilern geschrieben zu "
"werden, also überlassen wir es ihnen. Außerdem macht 6502 Spaß. Niemand hat "
"je x86 als spaßig bezeichnet."

#: ../learn/dist/tutorial.ui:8
msgid "Our first program"
msgstr "Unser erstes Programm"

#: ../learn/dist/tutorial.ui:9
msgid ""
"So, let's dive in! This application contains a <a href=\"https://github.com/"
"skilldrick/6502js\">JavaScript 6502 Assembler and Simulator</a> that I have "
"adapted for this interactive tutorial. Click the <b>Copy</b> button in the "
"code block below to copy the example code to the editor. Then click the "
"button in the top right to assemble the code, then click it again to run the "
"program. You can also access these actions through the dropdown menu."
msgstr ""
"Also, lass uns loslegen! Diese Anwendung enthält einen <a href=\"https://"
"github.com/skilldrick/6502js\">JavaScript 6502 Assembler und Simulator</a>, "
"den ich für dieses interaktive Tutorial angepasst habe. Klicke auf den "
"<b>Kopieren</b>-Button im Code-Block unten, um den Beispielcode in den "
"Editor zu kopieren. Klicke dann auf den Button oben rechts, um den Code zu "
"assemblieren, und klicke erneut, um das Programm auszuführen. Diese Aktionen "
"kannst du auch über das Dropdown-Menü aufrufen."

#: ../learn/dist/tutorial.ui:16
msgid ""
"The black game console screen now should show three coloured \"pixels\" at "
"the top left."
msgstr ""
"Der schwarze Spielkonsolenbildschirm sollte jetzt drei farbige \"Pixel\" "
"oben links zeigen."

#: ../learn/dist/tutorial.ui:17
msgid ""
"So, what's this program actually doing? Let's step through it. Hit <b>Reset</"
"b>, then select <b>Step</b> from the dropdown menu. The button will switch "
"to step mode, allowing you to execute the program one instruction at a time. "
"Click once and you'll notice in the debugger that <tt>A=</tt> changed from "
"<tt>$00</tt> to <tt>$01</tt>, and <tt>PC=</tt> changed from <tt>$0600</tt> "
"to <tt>$0602</tt>."
msgstr ""
"Was macht dieses Programm eigentlich? Lass uns es Schritt für Schritt "
"durchgehen. Klicke auf <b>Zurücksetzen</b> und wähle dann <b>Schritt</b> aus "
"dem Dropdown-Menü. Der Button wechselt in den Schritt-Modus, wodurch du das "
"Programm Anweisung für Anweisung ausführen kannst. Nach einem Klick wirst du "
"im Debugger sehen, dass sich <tt>A=</tt> von <tt>$00</tt> zu <tt>$01</tt> "
"und <tt>PC=</tt> von <tt>$0600</tt> zu <tt>$0602</tt> geändert hat."

#: ../learn/dist/tutorial.ui:18
msgid ""
"Any numbers prefixed with <tt>$</tt> in 6502 assembly language (and by "
"extension, in this book) are in hexadecimal (hex) format. If you're not "
"familiar with hex numbers, I recommend you read <a href=\"http://en."
"wikipedia.org/wiki/Hexadecimal\">the Wikipedia article</a>. Anything "
"prefixed with <tt>#</tt> is a literal number value. Any other number refers "
"to a memory location."
msgstr ""
"Alle Zahlen mit dem Präfix <tt>$</tt> in der 6502-Assemblersprache (und "
"folglich auch in diesem Buch) sind im Hexadezimal-(Hex)-Format. Wenn du mit "
"Hexadezimalzahlen nicht vertraut bist, empfehle ich dir, <a href=\"http://en."
"wikipedia.org/wiki/Hexadecimal\">den Wikipedia-Artikel</a> zu lesen. Alles "
"mit dem Präfix <tt>#</tt> ist ein Literalwert. Alle anderen Zahlen beziehen "
"sich auf Speicheradressen."

#: ../learn/dist/tutorial.ui:19
msgid ""
"Equipped with that knowledge, you should be able to see that the instruction "
"<tt>LDA #$01</tt> loads the hex value <tt>$01</tt> into register <tt>A</tt>. "
"I'll go into more detail on registers in the next section."
msgstr ""
"Mit diesem Wissen solltest du erkennen können, dass die Anweisung <tt>LDA "
"#$01</tt> den Hexadezimalwert <tt>$01</tt> in das Register <tt>A</tt> lädt. "
"Ich werde im nächsten Abschnitt näher auf Register eingehen."

#: ../learn/dist/tutorial.ui:20
msgid ""
"Press <b>Step</b> again to execute the second instruction. The top-left "
"pixel of the game console should now be white. This simulator uses the "
"memory locations <tt>$0200</tt> to <tt>$05ff</tt> to draw pixels on its "
"display. The values <tt>$00</tt> to <tt>$0f</tt> represent 16 different "
"colours (<tt>$00</tt> is black and <tt>$01</tt> is white), so storing the "
"value <tt>$01</tt> at memory location <tt>$0200</tt> draws a white pixel at "
"the top left corner. This is simpler than how an actual computer would "
"output video, but it'll do for now."
msgstr ""
"Drücke erneut <b>Schritt</b>, um die zweite Anweisung auszuführen. Das Pixel "
"oben links in der Spielkonsole sollte jetzt weiß sein. Dieser Simulator "
"verwendet die Speicheradressen von <tt>$0200</tt> bis <tt>$05ff</tt>, um "
"Pixel auf seinem Display zu zeichnen. Die Werte von <tt>$00</tt> bis "
"<tt>$0f</tt> repräsentieren 16 verschiedene Farben (<tt>$00</tt> ist schwarz "
"und <tt>$01</tt> ist weiß), daher zeichnet das Speichern des Wertes <tt>$01</"
"tt> an der Speicheradresse <tt>$0200</tt> ein weißes Pixel in der oberen "
"linken Ecke. Das ist einfacher als die Art und Weise, wie ein echter "
"Computer Video ausgeben würde, aber für den Moment reicht es."

#: ../learn/dist/tutorial.ui:21
msgid ""
"So, the instruction <tt>STA $0200</tt> stores the value of the <tt>A</tt> "
"register to memory location <tt>$0200</tt>. Click <b>Step</b> four more "
"times to execute the rest of the instructions, keeping an eye on the <tt>A</"
"tt> register as it changes."
msgstr ""
"Die Anweisung <tt>STA $0200</tt> speichert also den Wert des <tt>A</tt>-"
"Registers an der Speicheradresse <tt>$0200</tt>. Klicke noch vier Mal auf "
"<b>Schritt</b>, um die restlichen Anweisungen auszuführen, und beobachte "
"dabei, wie sich das <tt>A</tt>-Register verändert."

#: ../learn/dist/tutorial.ui:22 ../learn/dist/tutorial.ui:46
#: ../learn/dist/tutorial.ui:62
msgid "Exercises"
msgstr "Übungen"

#: ../learn/dist/tutorial.ui:23 ../learn/dist/tutorial.ui:47
#: ../learn/dist/tutorial.ui:63 ../learn/dist/tutorial.ui:136
msgid "1."
msgstr "1."

#: ../learn/dist/tutorial.ui:23
msgid "Try changing the colour of the three pixels."
msgstr "Versuche die Farbe der drei Pixel zu ändern."

#: ../learn/dist/tutorial.ui:23 ../learn/dist/tutorial.ui:47
#: ../learn/dist/tutorial.ui:63
msgid "2."
msgstr "2."

#: ../learn/dist/tutorial.ui:23
msgid ""
"Change one of the pixels to draw at the bottom-right corner (memory location "
"<tt>$05ff</tt>)."
msgstr ""
"Ändere eines der Pixel so, dass es in der unteren rechten Ecke gezeichnet "
"wird (Speicheradresse <tt>$05ff</tt>)."

#: ../learn/dist/tutorial.ui:23 ../learn/dist/tutorial.ui:47
msgid "3."
msgstr "3."

#: ../learn/dist/tutorial.ui:23
msgid "Add more instructions to draw extra pixels."
msgstr "Füge weitere Anweisungen hinzu, um zusätzliche Pixel zu zeichnen."

#: ../learn/dist/tutorial.ui:24
msgid "Registers and flags"
msgstr "Register und Flags"

#: ../learn/dist/tutorial.ui:25
msgid ""
"We've already had a little look at the processor status section (the bit "
"with <tt>A</tt>, <tt>PC</tt> etc.), but what does it all mean?"
msgstr ""
"Wir haben bereits einen kurzen Blick auf den Prozessorstatus-Bereich "
"geworfen (den Teil mit <tt>A</tt>, <tt>PC</tt> usw.), aber was bedeutet das "
"alles?"

#: ../learn/dist/tutorial.ui:26
msgid ""
"The first line shows the <tt>A</tt>, <tt>X</tt> and <tt>Y</tt> registers "
"(<tt>A</tt> is often called the \"accumulator\"). Each register holds a "
"single byte. Most operations work on the contents of these registers."
msgstr ""
"Die erste Zeile zeigt die Register <tt>A</tt>, <tt>X</tt> und <tt>Y</tt> "
"(<tt>A</tt> wird oft als \"Akkumulator\" bezeichnet). Jedes Register enthält "
"ein einzelnes Byte. Die meisten Operationen arbeiten mit dem Inhalt dieser "
"Register."

#: ../learn/dist/tutorial.ui:27
msgid ""
"<tt>SP</tt> is the stack pointer. I won't get into the stack yet, but "
"basically this register is decremented every time a byte is pushed onto the "
"stack, and incremented when a byte is popped off the stack."
msgstr ""
"<tt>SP</tt> ist der Stack-Pointer. Ich werde jetzt noch nicht auf den Stack "
"eingehen, aber im Grunde wird dieses Register jedes Mal dekrementiert, wenn "
"ein Byte auf den Stack geschoben wird, und inkrementiert, wenn ein Byte vom "
"Stack genommen wird."

#: ../learn/dist/tutorial.ui:28
msgid ""
"<tt>PC</tt> is the program counter - it's how the processor knows at what "
"point in the program it currently is. It's like the current line number of "
"an executing script. In the JavaScript simulator the code is assembled "
"starting at memory location <tt>$0600</tt>, so <tt>PC</tt> always starts "
"there."
msgstr ""
"<tt>PC</tt> ist der Programmzähler (program counter) - damit weiß der "
"Prozessor, an welcher Stelle im Programm er sich gerade befindet. Es ist wie "
"die aktuelle Zeilennummer eines ausgeführten Skripts. Im JavaScript-"
"Simulator wird der Code ab der Speicheradresse <tt>$0600</tt> assembliert, "
"daher beginnt <tt>PC</tt> immer dort."

#: ../learn/dist/tutorial.ui:29
msgid ""
"The last section shows the processor flags. Each flag is one bit, so all "
"seven flags live in a single byte. The flags are set by the processor to "
"give information about the previous instruction. More on that later. <a "
"href=\"https://web.archive.org/web/20210626024532/http://www.obelisk.me."
"uk/6502/registers.html\">Read more about the registers and flags here</a>."
msgstr ""
"Der letzte Abschnitt zeigt die Prozessor-Flags. Jedes Flag ist ein Bit, "
"sodass alle sieben Flags in einem einzigen Byte untergebracht sind. Die "
"Flags werden vom Prozessor gesetzt, um Informationen über die vorherige "
"Anweisung zu geben. Mehr dazu später. <a href=\"https://web.archive.org/"
"web/20210626024532/http://www.obelisk.me.uk/6502/registers.html\">Lies hier "
"mehr über Register und Flags</a>."

#: ../learn/dist/tutorial.ui:30
msgid "Instructions"
msgstr "Anweisungen"

#: ../learn/dist/tutorial.ui:31
msgid ""
"Instructions in assembly language are like a small set of predefined "
"functions. All instructions take zero or one arguments. Here's some "
"annotated source code to introduce a few different instructions:"
msgstr ""
"Anweisungen in der Assemblersprache sind wie eine kleine Sammlung "
"vordefinierter Funktionen. Alle Anweisungen nehmen null oder ein Argument. "
"Hier ist etwas kommentierter Quellcode, um einige verschiedene Anweisungen "
"vorzustellen:"

#: ../learn/dist/tutorial.ui:37
msgid ""
"Assemble the code, then turn on the debugger and step through the code, "
"watching the <tt>A</tt> and <tt>X</tt> registers. Something slightly odd "
"happens on the line <tt>ADC #$c4</tt>. You might expect that adding <tt>$c4</"
"tt> to <tt>$c0</tt> would give <tt>$184</tt>, but this processor gives the "
"result as <tt>$84</tt>. What's up with that?"
msgstr ""
"Assembliere den Code, schalte dann den Debugger ein und gehe den Code "
"schrittweise durch, während du die Register <tt>A</tt> und <tt>X</tt> "
"beobachtest. Etwas Seltsames passiert in der Zeile <tt>ADC #$c4</tt>. Du "
"könntest erwarten, dass das Addieren von <tt>$c4</tt> zu <tt>$c0</tt> "
"<tt>$184</tt> ergibt, aber dieser Prozessor gibt das Ergebnis als <tt>$84</"
"tt> aus. Was hat es damit auf sich?"

#: ../learn/dist/tutorial.ui:38
msgid ""
"The problem is, <tt>$184</tt> is too big to fit in a single byte (the max is "
"<tt>$FF</tt>), and the registers can only hold a single byte. It's OK "
"though; the processor isn't actually dumb. If you were looking carefully "
"enough, you'll have noticed that the carry flag was set to <tt>1</tt> after "
"this operation. So that's how you know."
msgstr ""
"Das Problem ist, dass <tt>$184</tt> zu groß ist, um in ein einzelnes Byte zu "
"passen (das Maximum ist <tt>$FF</tt>), und die Register können nur ein "
"einzelnes Byte speichern. Aber keine Sorge; der Prozessor ist nicht wirklich "
"dumm. Wenn du genau aufgepasst hast, wirst du bemerkt haben, dass das Carry-"
"Flag nach dieser Operation auf <tt>1</tt> gesetzt wurde. So weißt du "
"Bescheid."

#: ../learn/dist/tutorial.ui:39
msgid "In the simulator below <b>type</b> (don't paste) the following code:"
msgstr "Tippe (nicht einfügen) den folgenden Code in den Simulator ein:"

#: ../learn/dist/tutorial.ui:43
msgid ""
"An important thing to notice here is the distinction between <tt>ADC #$01</"
"tt> and <tt>ADC $01</tt>. The first one adds the value <tt>$01</tt> to the "
"<tt>A</tt> register, but the second adds the value stored at memory location "
"<tt>$01</tt> to the <tt>A</tt> register."
msgstr ""
"Ein wichtiger Punkt hier ist der Unterschied zwischen <tt>ADC #$01</tt> und "
"<tt>ADC $01</tt>. Der erste Befehl addiert den Wert <tt>$01</tt> zum <tt>A</"
"tt>-Register, aber der zweite addiert den an der Speicheradresse <tt>$01</"
"tt> gespeicherten Wert zum <tt>A</tt>-Register."

#: ../learn/dist/tutorial.ui:44
msgid ""
"Assemble the code and select <b>Step</b> from the Run button's dropdown menu "
"to step through these three instructions. The monitor in the debugger shows "
"a section of memory, and can be helpful to visualise the execution of "
"programs. <tt>STA $01</tt> stores the value of the <tt>A</tt> register at "
"memory location <tt>$01</tt>, and <tt>ADC $01</tt> adds the value stored at "
"the memory location <tt>$01</tt> to the <tt>A</tt> register. <tt>$80 + $80</"
"tt> should equal <tt>$100</tt>, but because this is bigger than a byte, the "
"<tt>A</tt> register is set to <tt>$00</tt> and the carry flag is set. As "
"well as this though, the zero flag is set. The zero flag is set by all "
"instructions where the result is zero."
msgstr ""
"Assembliere den Code und wähle <b>Schritt</b> aus dem Dropdown-Menü des Run-"
"Buttons, um diese drei Anweisungen schrittweise durchzugehen. Der Monitor im "
"Debugger zeigt einen Speicherbereich an und kann hilfreich sein, um die "
"Ausführung von Programmen zu visualisieren. <tt>STA $01</tt> speichert den "
"Wert des <tt>A</tt>-Registers an der Speicheradresse <tt>$01</tt>, und "
"<tt>ADC $01</tt> addiert den an der Speicheradresse <tt>$01</tt> "
"gespeicherten Wert zum <tt>A</tt>-Register. <tt>$80 + $80</tt> sollte "
"<tt>$100</tt> ergeben, aber da dies größer als ein Byte ist, wird das <tt>A</"
"tt>-Register auf <tt>$00</tt> gesetzt und das Carry-Flag wird gesetzt. "
"Zusätzlich wird auch das Zero-Flag gesetzt. Das Zero-Flag wird bei allen "
"Anweisungen gesetzt, bei denen das Ergebnis null ist."

#: ../learn/dist/tutorial.ui:45
msgid ""
"A full list of the 6502 instruction set is <a href=\"http://www.6502.org/"
"tutorials/6502opcodes.html\">available here</a> and <a href=\"http://www."
"obelisk.me.uk/6502/reference.html\">here</a> (I usually refer to both pages "
"as they have their strengths and weaknesses). These pages detail the "
"arguments to each instruction, which registers they use, and which flags "
"they set. They are your bible."
msgstr ""
"Eine vollständige Liste des 6502-Befehlssatzes ist <a href=\"http://www.6502."
"org/tutorials/6502opcodes.html\">hier</a> und <a href=\"http://www.obelisk."
"me.uk/6502/reference.html\">hier</a> verfügbar (ich verweise normalerweise "
"auf beide Seiten, da sie ihre Stärken und Schwächen haben). Diese Seiten "
"beschreiben die Argumente für jede Anweisung, welche Register sie verwenden "
"und welche Flags sie setzen. Sie sind deine Bibel."

#: ../learn/dist/tutorial.ui:47
msgid ""
"You've seen <tt>TAX</tt>. You can probably guess what <tt>TAY</tt>, <tt>TXA</"
"tt> and <tt>TYA</tt> do, but write some code to test your assumptions."
msgstr ""
"Du hast <tt>TAX</tt> gesehen. Du kannst wahrscheinlich erraten, was <tt>TAY</"
"tt>, <tt>TXA</tt> und <tt>TYA</tt> tun, aber schreibe etwas Code, um deine "
"Vermutungen zu testen."

#: ../learn/dist/tutorial.ui:47
msgid ""
"Rewrite the first example in this section to use the <tt>Y</tt> register "
"instead of the <tt>X</tt> register."
msgstr ""
"Schreibe das erste Beispiel in diesem Abschnitt so um, dass es das <tt>Y</"
"tt>-Register anstelle des <tt>X</tt>-Registers verwendet."

#: ../learn/dist/tutorial.ui:47
msgid ""
"The opposite of <tt>ADC</tt> is <tt>SBC</tt> (subtract with carry). Write a "
"program that uses this instruction."
msgstr ""
"Das Gegenteil von <tt>ADC</tt> ist <tt>SBC</tt> (subtract with carry). "
"Schreibe ein Programm, das diese Anweisung verwendet."

#: ../learn/dist/tutorial.ui:48
msgid "Branching"
msgstr "Verzweigungen"

#: ../learn/dist/tutorial.ui:49
msgid ""
"So far we're only able to write basic programs without any branching logic. "
"Let's change that."
msgstr ""
"Bisher können wir nur einfache Programme ohne Verzweigungslogik schreiben. "
"Lass uns das ändern."

#: ../learn/dist/tutorial.ui:50
msgid ""
"6502 assembly language has a bunch of branching instructions, all of which "
"branch based on whether certain flags are set or not. In this example we'll "
"be looking at <tt>BNE</tt>: \"Branch on not equal\"."
msgstr ""
"Die 6502-Assemblersprache hat eine Reihe von Verzweigungsanweisungen, die "
"alle basierend darauf verzweigen, ob bestimmte Flags gesetzt sind oder "
"nicht. In diesem Beispiel schauen wir uns <tt>BNE</tt> an: \"Branch on not "
"equal\" (Verzweige bei Ungleichheit)."

#: ../learn/dist/tutorial.ui:59
msgid ""
"First we load the value <tt>$08</tt> into the <tt>X</tt> register. The next "
"line is a label. Labels just mark certain points in a program so we can "
"return to them later. After the label we decrement <tt>X</tt>, store it to "
"<tt>$0200</tt> (the top-left pixel), and then compare it to the value "
"<tt>$03</tt>. <a href=\"http://www.obelisk.me.uk/6502/reference."
"html#CPX\"><tt>CPX</tt></a> compares the value in the <tt>X</tt> register "
"with another value. If the two values are equal, the <tt>Z</tt> flag is set "
"to <tt>1</tt>, otherwise it is set to <tt>0</tt>."
msgstr ""
"Zuerst laden wir den Wert <tt>$08</tt> in das <tt>X</tt>-Register. Die "
"nächste Zeile ist ein Label. Labels markieren bestimmte Stellen in einem "
"Programm, damit wir später dorthin zurückkehren können. Nach dem Label "
"dekrementieren wir <tt>X</tt>, speichern es in <tt>$0200</tt> (das Pixel "
"oben links) und vergleichen es dann mit dem Wert <tt>$03</tt>. <a "
"href=\"http://www.obelisk.me.uk/6502/reference.html#CPX\"><tt>CPX</tt></a> "
"vergleicht den Wert im <tt>X</tt>-Register mit einem anderen Wert. Wenn die "
"beiden Werte gleich sind, wird das <tt>Z</tt>-Flag auf <tt>1</tt> gesetzt, "
"andernfalls auf <tt>0</tt>."

#: ../learn/dist/tutorial.ui:60
msgid ""
"The next line, <tt>BNE decrement</tt>, will shift execution to the decrement "
"label if the <tt>Z</tt> flag is set to <tt>0</tt> (meaning that the two "
"values in the <tt>CPX</tt> comparison were not equal), otherwise it does "
"nothing and we store <tt>X</tt> to <tt>$0201</tt>, then finish the program."
msgstr ""
"Die nächste Zeile, <tt>BNE decrement</tt>, wird die Ausführung zum decrement-"
"Label verschieben, wenn das <tt>Z</tt>-Flag auf <tt>0</tt> gesetzt ist (was "
"bedeutet, dass die beiden Werte im <tt>CPX</tt>-Vergleich nicht gleich "
"waren), andernfalls passiert nichts und wir speichern <tt>X</tt> in "
"<tt>$0201</tt> und beenden dann das Programm."

#: ../learn/dist/tutorial.ui:61
msgid ""
"In assembly language, you'll usually use labels with branch instructions. "
"When assembled though, this label is converted to a single-byte relative "
"offset (a number of bytes to go backwards or forwards from the next "
"instruction) so branch instructions can only go forward and back around 256 "
"bytes. This means they can only be used to move around local code. For "
"moving further you'll need to use the jumping instructions."
msgstr ""
"In der Assemblersprache verwendet man normalerweise Labels mit "
"Verzweigungsanweisungen. Beim Assemblieren wird dieses Label jedoch in einen "
"einbytigen relativen Offset umgewandelt (eine Anzahl von Bytes, die von der "
"nächsten Anweisung aus vor- oder rückwärts gegangen werden soll), sodass "
"Verzweigungsanweisungen nur etwa 256 Bytes vor und zurück gehen können. Das "
"bedeutet, dass sie nur für Bewegungen innerhalb von lokalem Code verwendet "
"werden können. Für weitere Bewegungen musst du die Sprunganweisungen "
"verwenden."

#: ../learn/dist/tutorial.ui:63
msgid ""
"The opposite of <tt>BNE</tt> is <tt>BEQ</tt>. Try writing a program that "
"uses <tt>BEQ</tt>."
msgstr ""
"Das Gegenteil von <tt>BNE</tt> ist <tt>BEQ</tt>. Versuche ein Programm zu "
"schreiben, das <tt>BEQ</tt> verwendet."

#: ../learn/dist/tutorial.ui:63
msgid ""
"<tt>BCC</tt> and <tt>BCS</tt> (\"branch on carry clear\" and \"branch on "
"carry set\") are used to branch on the carry flag. Write a program that uses "
"one of these two."
msgstr ""
"<tt>BCC</tt> und <tt>BCS</tt> (\"branch on carry clear\" und \"branch on "
"carry set\") werden verwendet, um abhängig vom Carry-Flag zu verzweigen. "
"Schreibe ein Programm, das eine dieser beiden Anweisungen verwendet."

#: ../learn/dist/tutorial.ui:64
msgid "Addressing modes"
msgstr "Adressierungsmodi"

#: ../learn/dist/tutorial.ui:65
msgid ""
"The 6502 uses a 16-bit address bus, meaning that there are 65536 bytes of "
"memory available to the processor. Remember that a byte is represented by "
"two hex characters, so the memory locations are generally represented as "
"<tt>$0000 - $ffff</tt>. There are various ways to refer to these memory "
"locations, as detailed below."
msgstr ""
"Der 6502 verwendet einen 16-Bit-Adressbus, was bedeutet, dass dem Prozessor "
"65536 Bytes Speicher zur Verfügung stehen. Denk daran, dass ein Byte durch "
"zwei Hex-Zeichen dargestellt wird, sodass die Speicheradressen im "
"Allgemeinen als <tt>$0000 - $ffff</tt> dargestellt werden. Es gibt "
"verschiedene Möglichkeiten, sich auf diese Speicheradressen zu beziehen, wie "
"unten beschrieben."

#: ../learn/dist/tutorial.ui:66
msgid ""
"With all these examples you might find it helpful to use the memory monitor "
"in the debugger to watch the memory change. The monitor takes a starting "
"memory location and a number of bytes to display from that location. Both of "
"these are hex values. For example, to display 16 bytes of memory from "
"<tt>$c000</tt>, enter <tt>c000</tt> and <tt>10</tt> into <b>Start</b> and "
"<b>Length</b>, respectively."
msgstr ""
"Bei all diesen Beispielen kann es hilfreich sein, den Speicher-Monitor im "
"Debugger zu verwenden, um die Änderungen im Speicher zu beobachten. Der "
"Monitor benötigt eine Startadresse und die Anzahl der Bytes, die von dieser "
"Position angezeigt werden sollen. Beide Werte sind Hexadezimalzahlen. Um zum "
"Beispiel 16 Bytes Speicher ab <tt>$c000</tt> anzuzeigen, gib <tt>c000</tt> "
"und <tt>10</tt> in die Felder <b>Start</b> bzw. <b>Länge</b> ein."

#: ../learn/dist/tutorial.ui:67
msgid "Absolute: <tt>$c000</tt>"
msgstr "Absolut: <tt>$c000</tt>"

#: ../learn/dist/tutorial.ui:68
msgid ""
"With absolute addressing, the full memory location is used as the argument "
"to the instruction. For example:"
msgstr ""
"Bei der absoluten Adressierung wird die vollständige Speicheradresse als "
"Argument für die Anweisung verwendet. Zum Beispiel:"

#: ../learn/dist/tutorial.ui:70
msgid "Zero page: <tt>$c0</tt>"
msgstr "Nullseite: <tt>$c0</tt>"

#: ../learn/dist/tutorial.ui:71
msgid ""
"All instructions that support absolute addressing (with the exception of the "
"jump instructions) also have the option to take a single-byte address. This "
"type of addressing is called \"zero page\" - only the first page (the first "
"256 bytes) of memory is accessible. This is faster, as only one byte needs "
"to be looked up, and takes up less space in the assembled code as well."
msgstr ""
"Alle Anweisungen, die absolute Adressierung unterstützen (mit Ausnahme der "
"Sprunganweisungen), haben auch die Möglichkeit, eine einbyte-Adresse zu "
"verwenden. Diese Art der Adressierung wird \"Nullseite\" genannt - nur die "
"erste Seite (die ersten 256 Bytes) des Speichers ist zugänglich. Dies ist "
"schneller, da nur ein Byte nachgeschlagen werden muss, und nimmt auch "
"weniger Platz im assemblierten Code ein."

#: ../learn/dist/tutorial.ui:72
msgid "Zero page,X: <tt>$c0,X</tt>"
msgstr "Nullseite,X: <tt>$c0,X</tt>"

#: ../learn/dist/tutorial.ui:73
msgid ""
"This is where addressing gets interesting. In this mode, a zero page address "
"is given, and then the value of the <tt>X</tt> register is added. Here is an "
"example:"
msgstr ""
"Hier wird die Adressierung interessant. In diesem Modus wird eine Nullseiten-"
"Adresse angegeben und dann der Wert des <tt>X</tt>-Registers hinzuaddiert. "
"Hier ist ein Beispiel:"

#: ../learn/dist/tutorial.ui:79
msgid ""
"If the result of the addition is larger than a single byte, the address "
"wraps around. For example:"
msgstr ""
"Wenn das Ergebnis der Addition größer als ein einzelnes Byte ist, wird die "
"Adresse umgebrochen. Zum Beispiel:"

#: ../learn/dist/tutorial.ui:82
msgid "Zero page,Y: <tt>$c0,Y</tt>"
msgstr "Nullseite,Y: <tt>$c0,Y</tt>"

#: ../learn/dist/tutorial.ui:83
msgid ""
"This is the equivalent of zero page,X, but can only be used with <tt>LDX</"
"tt> and <tt>STX</tt>."
msgstr ""
"Dies ist das Äquivalent zu Nullseite,X, kann aber nur mit <tt>LDX</tt> und "
"<tt>STX</tt> verwendet werden."

#: ../learn/dist/tutorial.ui:84
msgid "Absolute,X and absolute,Y: <tt>$c000,X</tt> and <tt>$c000,Y</tt>"
msgstr "Absolut,X und absolut,Y: <tt>$c000,X</tt> und <tt>$c000,Y</tt>"

#: ../learn/dist/tutorial.ui:85
msgid ""
"These are the absolute addressing versions of zero page,X and zero page,Y. "
"For example:"
msgstr ""
"Dies sind die absoluten Adressierungsversionen von Nullseite,X und Nullseite,"
"Y. Zum Beispiel:"

#: ../learn/dist/tutorial.ui:88
msgid ""
"Unlike zero page,Y, absolute,Y can't be used with <tt>STX</tt> but can be "
"used with <tt>LDA</tt> and <tt>STA</tt>."
msgstr ""
"Im Gegensatz zu Nullseite,Y kann absolut,Y nicht mit <tt>STX</tt> verwendet "
"werden, aber mit <tt>LDA</tt> und <tt>STA</tt>."

#: ../learn/dist/tutorial.ui:89
msgid "Immediate: <tt>#$c0</tt>"
msgstr "Unmittelbar: <tt>#$c0</tt>"

#: ../learn/dist/tutorial.ui:90
msgid ""
"Immediate addressing doesn't strictly deal with memory addresses - this is "
"the mode where actual values are used. For example, <tt>LDX #$01</tt> loads "
"the value <tt>$01</tt> into the <tt>X</tt> register. This is very different "
"to the zero page instruction <tt>LDX $01</tt> which loads the value at "
"memory location <tt>$01</tt> into the <tt>X</tt> register."
msgstr ""
"Die unmittelbare Adressierung beschäftigt sich nicht direkt mit "
"Speicheradressen - dies ist der Modus, in dem tatsächliche Werte verwendet "
"werden. Zum Beispiel lädt <tt>LDX #$01</tt> den Wert <tt>$01</tt> in das "
"<tt>X</tt>-Register. Dies unterscheidet sich deutlich von der Nullseiten-"
"Anweisung <tt>LDX $01</tt>, die den Wert an der Speicheradresse <tt>$01</tt> "
"in das <tt>X</tt>-Register lädt."

#: ../learn/dist/tutorial.ui:91
msgid "Relative: <tt>$c0</tt> (or label)"
msgstr "Relativ: <tt>$c0</tt> (oder Label)"

#: ../learn/dist/tutorial.ui:92
msgid ""
"Relative addressing is used for branching instructions. These instructions "
"take a single byte, which is used as an offset from the following "
"instruction."
msgstr ""
"Relative Adressierung wird für Verzweigungsanweisungen verwendet. Diese "
"Anweisungen nehmen ein einzelnes Byte, das als Offset von der folgenden "
"Anweisung verwendet wird."

#: ../learn/dist/tutorial.ui:93
msgid ""
"Assemble the following code, then check the debugger to see the hexdump of "
"the assembled code."
msgstr ""
"Assembliere den folgenden Code und schaue dann im Debugger, um den Hexdump "
"des assemblierten Codes zu sehen."

#: ../learn/dist/tutorial.ui:100
msgid "The hex should look something like this:"
msgstr "Der Hexadezimalcode sollte etwa so aussehen:"

#: ../learn/dist/tutorial.ui:102
msgid ""
"<tt>a9</tt> and <tt>c9</tt> are the processor opcodes for immediate-"
"addressed <tt>LDA</tt> and <tt>CMP</tt> respectively. <tt>01</tt> and "
"<tt>02</tt> are the arguments to these instructions. <tt>d0</tt> is the "
"opcode for <tt>BNE</tt>, and its argument is <tt>02</tt>. This means \"skip "
"over the next two bytes\" (<tt>85 22</tt>, the assembled version of <tt>STA "
"$22</tt>). Try editing the code so <tt>STA</tt> takes a two-byte absolute "
"address rather than a single-byte zero page address (e.g. change <tt>STA "
"$22</tt> to <tt>STA $2222</tt>). Reassemble the code and look at the hexdump "
"again - the argument to <tt>BNE</tt> should now be <tt>03</tt>, because the "
"instruction the processor is skipping past is now three bytes long."
msgstr ""
"<tt>a9</tt> und <tt>c9</tt> sind die Prozessor-Opcodes für unmittelbar "
"adressierte <tt>LDA</tt> und <tt>CMP</tt>. <tt>01</tt> und <tt>02</tt> sind "
"die Argumente für diese Anweisungen. <tt>d0</tt> ist der Opcode für <tt>BNE</"
"tt>, und sein Argument ist <tt>02</tt>. Dies bedeutet \"überspringe die "
"nächsten zwei Bytes\" (<tt>85 22</tt>, die assemblierte Version von <tt>STA "
"$22</tt>). Versuche den Code so zu ändern, dass <tt>STA</tt> eine zweibyte "
"absolute Adresse anstelle einer einbyte Nullseiten-Adresse verwendet (z.B. "
"ändere <tt>STA $22</tt> zu <tt>STA $2222</tt>). Assembliere den Code neu und "
"schaue dir den Hexdump erneut an - das Argument für <tt>BNE</tt> sollte "
"jetzt <tt>03</tt> sein, weil die Anweisung, die der Prozessor überspringt, "
"jetzt drei Bytes lang ist."

#: ../learn/dist/tutorial.ui:103
msgid "Implicit"
msgstr "Implizit"

#: ../learn/dist/tutorial.ui:104
msgid ""
"Some instructions don't deal with memory locations (e.g. <tt>INX</tt> - "
"increment the <tt>X</tt> register). These are said to have implicit "
"addressing - the argument is implied by the instruction."
msgstr ""
"Einige Anweisungen arbeiten nicht mit Speicheradressen (z.B. <tt>INX</tt> - "
"inkrementiere das <tt>X</tt>-Register). Diese haben eine implizite "
"Adressierung - das Argument ergibt sich aus der Anweisung selbst."

#: ../learn/dist/tutorial.ui:105
msgid "Indirect: <tt>($c000)</tt>"
msgstr "Indirekt: <tt>($c000)</tt>"

#: ../learn/dist/tutorial.ui:106
msgid ""
"Indirect addressing uses an absolute address to look up another address. The "
"first address gives the least significant byte of the address, and the "
"following byte gives the most significant byte. That can be hard to wrap "
"your head around, so here's an example:"
msgstr ""
"Indirekte Adressierung verwendet eine absolute Adresse, um eine andere "
"Adresse nachzuschlagen. Die erste Adresse liefert das niedrigstwertige Byte "
"der Adresse, und das folgende Byte liefert das höchstwertige Byte. Das kann "
"schwer zu verstehen sein, hier ist ein Beispiel:"

#: ../learn/dist/tutorial.ui:112
msgid ""
"In this example, <tt>$f0</tt> contains the value <tt>$01</tt> and <tt>$f1</"
"tt> contains the value <tt>$cc</tt>. The instruction <tt>JMP ($f0)</tt> "
"causes the processor to look up the two bytes at <tt>$f0</tt> and <tt>$f1</"
"tt> (<tt>$01</tt> and <tt>$cc</tt>) and put them together to form the "
"address <tt>$cc01</tt>, which becomes the new program counter. Assemble and "
"step through the program above to see what happens. I'll talk more about "
"<tt>JMP</tt> in the section on <a href=\"#jumping\">Jumping</a>."
msgstr ""
"In diesem Beispiel enthält <tt>$f0</tt> den Wert <tt>$01</tt> und <tt>$f1</"
"tt> enthält den Wert <tt>$cc</tt>. Die Anweisung <tt>JMP ($f0)</tt> "
"veranlasst den Prozessor, die zwei Bytes bei <tt>$f0</tt> und <tt>$f1</tt> "
"(<tt>$01</tt> und <tt>$cc</tt>) nachzuschlagen und sie zur Adresse "
"<tt>$cc01</tt> zusammenzufügen, die dann zum neuen Programmzähler wird. "
"Assembliere und gehe das obige Programm schrittweise durch, um zu sehen, was "
"passiert. Ich werde mehr über <tt>JMP</tt> im Abschnitt über <a "
"href=\"#jumping\">Springen</a> sprechen."

#: ../learn/dist/tutorial.ui:113
msgid "Indexed indirect: <tt>($c0,X)</tt>"
msgstr "Indiziert indirekt: <tt>($c0,X)</tt>"

#: ../learn/dist/tutorial.ui:114
msgid ""
"This one's kinda weird. It's like a cross between zero page,X and indirect. "
"Basically, you take the zero page address, add the value of the <tt>X</tt> "
"register to it, then use that to look up a two-byte address. For example:"
msgstr ""
"Diese ist etwas seltsam. Es ist wie eine Kreuzung zwischen Nullseite,X und "
"indirekt. Im Grunde nimmst du die Nullseiten-Adresse, addierst den Wert des "
"<tt>X</tt>-Registers dazu und verwendest das dann, um eine zweibyte-Adresse "
"nachzuschlagen. Zum Beispiel:"

#: ../learn/dist/tutorial.ui:123
msgid ""
"Memory locations <tt>$01</tt> and <tt>$02</tt> contain the values <tt>$05</"
"tt> and <tt>$07</tt> respectively. Think of <tt>($00,X)</tt> as <tt>($00 + "
"X)</tt>. In this case <tt>X</tt> is <tt>$01</tt>, so this simplifies to "
"<tt>($01)</tt>. From here things proceed like standard indirect addressing - "
"the two bytes at <tt>$01</tt> and <tt>$02</tt> (<tt>$05</tt> and <tt>$07</"
"tt>) are looked up to form the address <tt>$0705</tt>. This is the address "
"that the <tt>Y</tt> register was stored into in the previous instruction, so "
"the <tt>A</tt> register gets the same value as <tt>Y</tt>, albeit through a "
"much more circuitous route. You won't see this much."
msgstr ""
"Die Speicheradressen <tt>$01</tt> und <tt>$02</tt> enthalten die Werte "
"<tt>$05</tt> bzw. <tt>$07</tt>. Denke an <tt>($00,X)</tt> als <tt>($00 + X)</"
"tt>. In diesem Fall ist <tt>X</tt> gleich <tt>$01</tt>, also vereinfacht "
"sich das zu <tt>($01)</tt>. Von hier aus läuft es wie bei der "
"standardmäßigen indirekten Adressierung - die zwei Bytes bei <tt>$01</tt> "
"und <tt>$02</tt> (<tt>$05</tt> und <tt>$07</tt>) werden nachgeschlagen, um "
"die Adresse <tt>$0705</tt> zu bilden. Dies ist die Adresse, in die das "
"<tt>Y</tt>-Register in der vorherigen Anweisung gespeichert wurde, sodass "
"das <tt>A</tt>-Register den gleichen Wert wie <tt>Y</tt> erhält, wenn auch "
"auf einem viel umständlicheren Weg. Das wirst du nicht oft sehen."

#: ../learn/dist/tutorial.ui:124
msgid "Indirect indexed: <tt>($c0),Y</tt>"
msgstr "Indirekt indiziert: <tt>($c0),Y</tt>"

#: ../learn/dist/tutorial.ui:125
msgid ""
"Indirect indexed is like indexed indirect but less insane. Instead of adding "
"the <tt>X</tt> register to the address before dereferencing, the zero page "
"address is dereferenced, and the <tt>Y</tt> register is added to the "
"resulting address."
msgstr ""
"Indirekt indiziert ist wie indiziert indirekt, aber weniger verrückt. "
"Anstatt das <tt>X</tt>-Register vor dem Dereferenzieren zur Adresse zu "
"addieren, wird die Nullseiten-Adresse dereferenziert und das <tt>Y</tt>-"
"Register zur resultierenden Adresse addiert."

#: ../learn/dist/tutorial.ui:134
msgid ""
"In this case, <tt>($01)</tt> looks up the two bytes at <tt>$01</tt> and "
"<tt>$02</tt>: <tt>$03</tt> and <tt>$07</tt>. These form the address "
"<tt>$0703</tt>. The value of the <tt>Y</tt> register is added to this "
"address to give the final address <tt>$0704</tt>."
msgstr ""
"In diesem Fall schlägt <tt>($01)</tt> die zwei Bytes bei <tt>$01</tt> und "
"<tt>$02</tt> nach: <tt>$03</tt> und <tt>$07</tt>. Diese bilden die Adresse "
"<tt>$0703</tt>. Der Wert des <tt>Y</tt>-Registers wird zu dieser Adresse "
"addiert, um die endgültige Adresse <tt>$0704</tt> zu erhalten."

#: ../learn/dist/tutorial.ui:135
msgid "Exercise"
msgstr "Übung"

#: ../learn/dist/tutorial.ui:136
msgid ""
"Try to write code snippets that use each of the 6502 addressing modes. "
"Remember, you can use the monitor in the debugger to watch a section of "
"memory."
msgstr ""
"Versuche Code-Beispiele zu schreiben, die jeden der 6502-Adressierungsmodi "
"verwenden. Denk daran, dass du den Monitor im Debugger verwenden kannst, um "
"einen Speicherbereich zu beobachten."

#: ../learn/dist/tutorial.ui:137
msgid "The stack"
msgstr "Der Stack"

#: ../learn/dist/tutorial.ui:138
msgid ""
"The stack in a 6502 processor is just like any other stack - values are "
"pushed onto it and popped (\"pulled\" in 6502 parlance) off it. The current "
"depth of the stack is measured by the stack pointer, a special register. The "
"stack lives in memory between <tt>$0100</tt> and <tt>$01ff</tt>. The stack "
"pointer is initially <tt>$ff</tt>, which points to memory location "
"<tt>$01ff</tt>. When a byte is pushed onto the stack, the stack pointer "
"becomes <tt>$fe</tt>, or memory location <tt>$01fe</tt>, and so on."
msgstr ""
"Der Stack in einem 6502-Prozessor ist wie jeder andere Stack - Werte werden "
"darauf geschoben (gepusht) und davon genommen (\"gepullt\" in 6502-Sprache). "
"Die aktuelle Tiefe des Stacks wird durch den Stack-Pointer gemessen, ein "
"spezielles Register. Der Stack befindet sich im Speicher zwischen <tt>$0100</"
"tt> und <tt>$01ff</tt>. Der Stack-Pointer ist anfangs <tt>$ff</tt>, was auf "
"die Speicheradresse <tt>$01ff</tt> zeigt. Wenn ein Byte auf den Stack "
"geschoben wird, wird der Stack-Pointer zu <tt>$fe</tt>, oder Speicheradresse "
"<tt>$01fe</tt>, und so weiter."

#: ../learn/dist/tutorial.ui:139
msgid ""
"Two of the stack instructions are <tt>PHA</tt> and <tt>PLA</tt>, \"push "
"accumulator\" and \"pull accumulator\". Below is an example of these two in "
"action."
msgstr ""
"Zwei der Stack-Anweisungen sind <tt>PHA</tt> und <tt>PLA</tt>, \"push "
"accumulator\" und \"pull accumulator\". Unten ist ein Beispiel dieser beiden "
"in Aktion."

#: ../learn/dist/tutorial.ui:156
msgid ""
"<tt>X</tt> holds the pixel colour, and <tt>Y</tt> holds the position of the "
"current pixel. The first loop draws the current colour as a pixel (via the "
"<tt>A</tt> register), pushes the colour to the stack, then increments the "
"colour and position. The second loop pops the stack, draws the popped colour "
"as a pixel, then increments the position. As should be expected, this "
"creates a mirrored pattern."
msgstr ""
"<tt>X</tt> enthält die Pixelfarbe und <tt>Y</tt> enthält die Position des "
"aktuellen Pixels. Die erste Schleife zeichnet die aktuelle Farbe als Pixel "
"(über das <tt>A</tt>-Register), schiebt die Farbe auf den Stack und erhöht "
"dann die Farbe und Position. Die zweite Schleife nimmt die Farbe vom Stack, "
"zeichnet die genommene Farbe als Pixel und erhöht dann die Position. Wie zu "
"erwarten, erzeugt dies ein gespiegeltes Muster."

#: ../learn/dist/tutorial.ui:157
msgid "Jumping"
msgstr "Springen"

#: ../learn/dist/tutorial.ui:158
msgid ""
"Jumping is like branching with two main differences. First, jumps are not "
"conditionally executed, and second, they take a two-byte absolute address. "
"For small programs, this second detail isn't very important, as you'll "
"mostly be using labels, and the assembler works out the correct memory "
"location from the label. For larger programs though, jumping is the only way "
"to move from one section of the code to another."
msgstr ""
"Springen ist wie Verzweigen mit zwei Hauptunterschieden. Erstens werden "
"Sprünge nicht bedingt ausgeführt, und zweitens verwenden sie eine zweibyte "
"absolute Adresse. Für kleine Programme ist dieses zweite Detail nicht sehr "
"wichtig, da du hauptsächlich Labels verwendest und der Assembler die "
"korrekte Speicheradresse aus dem Label ermittelt. Für größere Programme ist "
"Springen jedoch der einzige Weg, um von einem Codeabschnitt zu einem anderen "
"zu gelangen."

#: ../learn/dist/tutorial.ui:159
msgid "JMP"
msgstr "JMP"

#: ../learn/dist/tutorial.ui:160
msgid ""
"<tt>JMP</tt> is an unconditional jump. Here's a really simple example to "
"show it in action:"
msgstr ""
"<tt>JMP</tt> ist ein unbedingter Sprung. Hier ist ein sehr einfaches "
"Beispiel, um es in Aktion zu zeigen:"

#: ../learn/dist/tutorial.ui:168
msgid "JSR/RTS"
msgstr "JSR/RTS"

#: ../learn/dist/tutorial.ui:169
msgid ""
"<tt>JSR</tt> and <tt>RTS</tt> (\"jump to subroutine\" and \"return from "
"subroutine\") are a dynamic duo that you'll usually see used together. "
"<tt>JSR</tt> is used to jump from the current location to another part of "
"the code. <tt>RTS</tt> returns to the previous position. This is basically "
"like calling a function and returning."
msgstr ""
"<tt>JSR</tt> und <tt>RTS</tt> (\"jump to subroutine\" und \"return from "
"subroutine\") sind ein dynamisches Duo, das du normalerweise zusammen "
"verwendet siehst. <tt>JSR</tt> wird verwendet, um von der aktuellen Position "
"zu einem anderen Teil des Codes zu springen. <tt>RTS</tt> kehrt zur "
"vorherigen Position zurück. Dies ist im Grunde wie ein Funktionsaufruf und "
"die Rückkehr daraus."

#: ../learn/dist/tutorial.ui:170
msgid ""
"The processor knows where to return to because <tt>JSR</tt> pushes the "
"address minus one of the next instruction onto the stack before jumping to "
"the given location. <tt>RTS</tt> pops this location, adds one to it, and "
"jumps to that location. An example:"
msgstr ""
"Der Prozessor weiß, wohin er zurückkehren soll, weil <tt>JSR</tt> die "
"Adresse der nächsten Anweisung minus eins auf den Stack schiebt, bevor er "
"zur angegebenen Position springt. <tt>RTS</tt> nimmt diese Position vom "
"Stack, addiert eins dazu und springt zu dieser Position. Ein Beispiel:"

#: ../learn/dist/tutorial.ui:187
msgid ""
"The first instruction causes execution to jump to the <tt>init</tt> label. "
"This sets <tt>X</tt>, then returns to the next instruction, <tt>JSR loop</"
"tt>. This jumps to the <tt>loop</tt> label, which increments <tt>X</tt> "
"until it is equal to <tt>$05</tt>. After that we return to the next "
"instruction, <tt>JSR end</tt>, which jumps to the end of the file. This "
"illustrates how <tt>JSR</tt> and <tt>RTS</tt> can be used together to create "
"modular code."
msgstr ""
"Die erste Anweisung veranlasst die Ausführung zum <tt>init</tt>-Label zu "
"springen. Dies setzt <tt>X</tt> und kehrt dann zur nächsten Anweisung "
"zurück, <tt>JSR loop</tt>. Dies springt zum <tt>loop</tt>-Label, das <tt>X</"
"tt> erhöht, bis es gleich <tt>$05</tt> ist. Danach kehren wir zur nächsten "
"Anweisung zurück, <tt>JSR end</tt>, die zum Ende der Datei springt. Dies "
"zeigt, wie <tt>JSR</tt> und <tt>RTS</tt> zusammen verwendet werden können, "
"um modularen Code zu erstellen."

#: ../learn/dist/tutorial.ui:188
msgid "Creating a game"
msgstr "Ein Spiel erstellen"

#: ../learn/dist/tutorial.ui:189
msgid ""
"Now, let's put all this knowledge to good use, and make a game! We're going "
"to be making a really simple version of the classic game 'Snake'."
msgstr ""
"Jetzt lass uns all dieses Wissen gut nutzen und ein Spiel erstellen! Wir "
"werden eine sehr einfache Version des klassischen Spiels 'Snake' erstellen."

#: ../learn/dist/tutorial.ui:190
msgid ""
"Even though this will be a simple version, the code will be substantially "
"larger than all the previous examples. We will need to keep track of several "
"memory locations together for the various aspects of the game. We can still "
"do the necessary bookkeeping throughout the program ourselves, as before, "
"but on a larger scale that quickly becomes tedious and can also lead to bugs "
"that are difficult to spot. Instead we'll now let the assembler do some of "
"the mundane work for us."
msgstr ""
"Auch wenn dies eine einfache Version sein wird, wird der Code wesentlich "
"umfangreicher sein als alle bisherigen Beispiele. Wir müssen mehrere "
"Speicheradressen für die verschiedenen Aspekte des Spiels im Auge behalten. "
"Wir können die notwendige Buchführung im Programm immer noch selbst "
"durchführen, wie zuvor, aber in größerem Umfang wird das schnell mühsam und "
"kann auch zu schwer zu findenden Fehlern führen. Stattdessen lassen wir "
"jetzt den Assembler einen Teil der alltäglichen Arbeit für uns erledigen."

#: ../learn/dist/tutorial.ui:191
msgid ""
"In this assembler, we can define descriptive constants (or symbols) that "
"represent numbers. The rest of the code can then simply use the constants "
"instead of the literal number, which immediately makes it obvious what we're "
"dealing with. You can use letters, digits and underscores in a name."
msgstr ""
"In diesem Assembler können wir beschreibende Konstanten (oder Symbole) "
"definieren, die Zahlen repräsentieren. Der restliche Code kann dann einfach "
"die Konstanten anstelle der wörtlichen Zahl verwenden, was sofort deutlich "
"macht, womit wir es zu tun haben. Du kannst Buchstaben, Ziffern und "
"Unterstriche in einem Namen verwenden."

#: ../learn/dist/tutorial.ui:192
msgid ""
"Here's an example. Note that immediate operands are still prefixed with a "
"<tt>#</tt>."
msgstr ""
"Hier ist ein Beispiel. Beachte, dass unmittelbare Operanden immer noch mit "
"einem <tt>#</tt> beginnen."

#: ../learn/dist/tutorial.ui:199
msgid ""
"The code block below contains the entire source code of the game. I'll "
"explain how it works in the following sections."
msgstr ""
"Der Code-Block unten enthält den gesamten Quellcode des Spiels. Ich werde in "
"den folgenden Abschnitten erklären, wie es funktioniert."

#: ../learn/dist/tutorial.ui:200
msgid ""
"<a href=\"https://twitter.com/wkjagt\">Willem van der Jagt</a> made a <a "
"href=\"https://gist.github.com/wkjagt/9043907\">fully annotated gist of this "
"source code</a>, so follow along with that for more details."
msgstr ""
"<a href=\"https://twitter.com/wkjagt\">Willem van der Jagt</a> hat einen <a "
"href=\"https://gist.github.com/wkjagt/9043907\">vollständig kommentierten "
"Gist dieses Quellcodes</a> erstellt, folge diesem für weitere Details."

#: ../learn/dist/tutorial.ui:475
msgid "Overall structure"
msgstr "Gesamtstruktur"

#: ../learn/dist/tutorial.ui:476
msgid ""
"After the initial block of comments (lines starting with semicolons), the "
"first two lines are:"
msgstr ""
"Nach dem anfänglichen Block von Kommentaren (Zeilen, die mit Semikolons "
"beginnen), sind die ersten beiden Zeilen:"

#: ../learn/dist/tutorial.ui:479
msgid ""
"<tt>init</tt> and <tt>loop</tt> are both subroutines. <tt>init</tt> "
"initializes the game state, and <tt>loop</tt> is the main game loop."
msgstr ""
"<tt>init</tt> und <tt>loop</tt> sind beide Unterprogramme. <tt>init</tt> "
"initialisiert den Spielzustand, und <tt>loop</tt> ist die Hauptspielschleife."

#: ../learn/dist/tutorial.ui:480
msgid ""
"The <tt>loop</tt> subroutine itself just calls a number of subroutines "
"sequentially, before looping back on itself:"
msgstr ""
"Das <tt>loop</tt>-Unterprogramm selbst ruft nur eine Reihe von "
"Unterprogrammen nacheinander auf, bevor es zu sich selbst zurückkehrt:"

#: ../learn/dist/tutorial.ui:489
msgid ""
"First, <tt>readkeys</tt> checks to see if one of the direction keys (W, A, "
"S, D) was pressed, and if so, sets the direction of the snake accordingly. "
"Then, <tt>checkCollision</tt> checks to see if the snake collided with "
"itself or the apple. <tt>updateSnake</tt> updates the internal "
"representation of the snake, based on its direction. Next, the apple and "
"snake are drawn. Finally, <tt>spinWheels</tt> makes the processor do some "
"busy work, to stop the game from running too quickly. Think of it like a "
"sleep command. The game keeps running until the snake collides with the wall "
"or itself."
msgstr ""
"Zuerst überprüft <tt>readkeys</tt>, ob eine der Richtungstasten (W, A, S, D) "
"gedrückt wurde, und setzt entsprechend die Richtung der Schlange. Dann "
"überprüft <tt>checkCollision</tt>, ob die Schlange mit sich selbst oder dem "
"Apfel kollidiert ist. <tt>updateSnake</tt> aktualisiert die interne "
"Darstellung der Schlange basierend auf ihrer Richtung. Als nächstes werden "
"der Apfel und die Schlange gezeichnet. Schließlich lässt <tt>spinWheels</tt> "
"den Prozessor etwas Leerlaufarbeit machen, damit das Spiel nicht zu schnell "
"läuft. Denk daran wie an einen Sleep-Befehl. Das Spiel läuft weiter, bis die "
"Schlange mit der Wand oder sich selbst kollidiert."

#: ../learn/dist/tutorial.ui:490
msgid "Zero page usage"
msgstr "Verwendung der Nullseite"

#: ../learn/dist/tutorial.ui:491
msgid ""
"The zero page of memory is used to store a number of game state variables, "
"as noted in the comment block at the top of the game. Everything in <tt>$00</"
"tt>, <tt>$01</tt> and <tt>$10</tt> upwards is a pair of bytes representing a "
"two-byte memory location that will be looked up using indirect addressing. "
"These memory locations will all be between <tt>$0200</tt> and <tt>$05ff</tt> "
"- the section of memory corresponding to the game console. For example, if "
"<tt>$00</tt> and <tt>$01</tt> contained the values <tt>$01</tt> and <tt>$02</"
"tt>, they would be referring to the second pixel of the display ( <tt>$0201</"
"tt> - remember, the least significant byte comes first in indirect "
"addressing)."
msgstr ""
"Die Zero Page wird verwendet, um verschiedene Spielzustandsvariablen zu "
"speichern, wie im Kommentarblock am Anfang des Spiels beschrieben. Die "
"Bereiche <tt>$00</tt>, <tt>$01</tt> und ab <tt>$10</tt> aufwärts enthalten "
"jeweils Bytepaare, die eine 2-Byte-Speicheradresse darstellen und über "
"Indirect Addressing nachgeschlagen werden. Diese Speicheradressen liegen "
"alle zwischen <tt>$0200</tt> und <tt>$05ff</tt> - dem Speicherbereich des "
"Spielkonsolen-Displays. Wenn zum Beispiel <tt>$00</tt> und <tt>$01</tt> die "
"Werte <tt>$01</tt> und <tt>$02</tt> enthalten, verweisen sie auf das zweite "
"Pixel des Displays (<tt>$0201</tt> - beachte, dass bei Indirect Addressing "
"das Least Significant Byte zuerst kommt)."

#: ../learn/dist/tutorial.ui:492
msgid ""
"The first two bytes hold the location of the apple. This is updated every "
"time the snake eats the apple. Byte <tt>$02</tt> contains the current "
"direction. <tt>1</tt> means up, <tt>2</tt> right, <tt>4</tt> down, and "
"<tt>8</tt> left. The reasoning behind these numbers will become clear later."
msgstr ""
"Die ersten zwei Bytes enthalten die Position des Apfels. Diese wird jedes "
"Mal aktualisiert, wenn die Schlange den Apfel frisst. Byte <tt>$02</tt> "
"enthält die aktuelle Richtung. <tt>1</tt> bedeutet nach oben, <tt>2</tt> "
"nach rechts, <tt>4</tt> nach unten und <tt>8</tt> nach links. Die Logik "
"hinter diesen Zahlen wird später klar werden."

#: ../learn/dist/tutorial.ui:493
msgid ""
"Finally, byte <tt>$03</tt> contains the current length of the snake, in "
"terms of bytes in memory (so a length of 4 means 2 pixels)."
msgstr ""
"Schließlich enthält Byte <tt>$03</tt> die aktuelle Länge der Schlange, "
"gemessen in Bytes im Speicher (eine Länge von 4 bedeutet also 2 Pixel)."

#: ../learn/dist/tutorial.ui:494
msgid "Initialization"
msgstr "Initialisierung"

#: ../learn/dist/tutorial.ui:495
msgid ""
"The <tt>init</tt> subroutine defers to two subroutines, <tt>initSnake</tt> "
"and <tt>generateApplePosition</tt>. <tt>initSnake</tt> sets the snake "
"direction, length, and then loads the initial memory locations of the snake "
"head and body. The byte pair at <tt>$10</tt> contains the screen location of "
"the head, the pair at <tt>$12</tt> contains the location of the single body "
"segment, and <tt>$14</tt> contains the location of the tail (the tail is the "
"last segment of the body and is drawn in black to keep the snake moving). "
"This happens in the following code:"
msgstr ""
"Die <tt>init</tt>-Subroutine ruft zwei weitere Subroutinen auf: "
"<tt>initSnake</tt> und <tt>generateApplePosition</tt>. <tt>initSnake</tt> "
"legt die Richtung und Länge der Schlange fest und lädt dann die initialen "
"Speicherpositionen für Kopf und Körper. Das Bytepaar bei <tt>$10</tt> "
"enthält die Bildschirmposition des Kopfes, das Paar bei <tt>$12</tt> die "
"Position des Körpersegments und <tt>$14</tt> die Position des Schwanzes (der "
"Schwanz ist das letzte Segment des Körpers und wird schwarz dargestellt, "
"damit die Bewegung der Schlange sichtbar wird). Dies geschieht im folgenden "
"Code:"

#: ../learn/dist/tutorial.ui:506
msgid ""
"This loads the value <tt>$11</tt> into the memory location <tt>$10</tt>, the "
"value <tt>$10</tt> into <tt>$12</tt>, and <tt>$0f</tt> into <tt>$14</tt>. It "
"then loads the value <tt>$04</tt> into <tt>$11</tt>, <tt>$13</tt> and "
"<tt>$15</tt>. This leads to memory like this:"
msgstr ""
"Dies lädt den Wert <tt>$11</tt> in die Speicheradresse <tt>$10</tt>, den "
"Wert <tt>$10</tt> in <tt>$12</tt> und <tt>$0f</tt> in <tt>$14</tt>. Dann "
"lädt es den Wert <tt>$04</tt> in <tt>$11</tt>, <tt>$13</tt> und <tt>$15</"
"tt>. Dies führt zu Speicher wie diesem:"

#: ../learn/dist/tutorial.ui:508
msgid ""
"which represents the indirectly-addressed memory locations <tt>$0411</tt>, "
"<tt>$0410</tt> and <tt>$040f</tt> (three pixels in the middle of the "
"display). I'm labouring this point, but it's important to fully grok how "
"indirect addressing works."
msgstr ""
"was die indirekt adressierten Speicheradressen <tt>$0411</tt>, <tt>$0410</"
"tt> und <tt>$040f</tt> repräsentiert (drei Pixel in der Mitte des Displays). "
"Ich betone diesen Punkt, aber es ist wichtig, vollständig zu verstehen, wie "
"indirekte Adressierung funktioniert."

#: ../learn/dist/tutorial.ui:509
msgid ""
"The next subroutine, <tt>generateApplePosition</tt>, sets the apple location "
"to a random position on the display. First, it loads a random byte into the "
"accumulator (<tt>$fe</tt> is a random number generator in this simulator). "
"This is stored into <tt>$00</tt>. Next, a different random byte is loaded "
"into the accumulator, which is then <tt>AND</tt>-ed with the value <tt>$03</"
"tt>. This part requires a bit of a detour."
msgstr ""
"Das nächste Unterprogramm, <tt>generateApplePosition</tt>, setzt die "
"Apfelposition auf eine zufällige Position auf dem Display. Zuerst lädt es "
"ein zufälliges Byte in den Akkumulator (<tt>$fe</tt> ist ein "
"Zufallszahlengenerator in diesem Simulator). Dies wird in <tt>$00</tt> "
"gespeichert. Als nächstes wird ein anderes zufälliges Byte in den "
"Akkumulator geladen, das dann mit dem Wert <tt>$03</tt> <tt>AND</tt>-"
"verknüpft wird. Dieser Teil erfordert einen kleinen Umweg."

#: ../learn/dist/tutorial.ui:510
msgid ""
"The hex value <tt>$03</tt> is represented in binary as <tt>00000011</tt>. "
"The <tt>AND</tt> opcode performs a bitwise AND of the argument with the "
"accumulator. For example, if the accumulator contains the binary value "
"<tt>10101010</tt>, then the result of <tt>AND</tt> with <tt>00000011</tt> "
"will be <tt>00000010</tt>."
msgstr ""
"Der Hexadezimalwert <tt>$03</tt> wird binär als <tt>00000011</tt> "
"dargestellt. Der <tt>AND</tt>-Opcode führt eine bitweise UND-Verknüpfung des "
"Arguments mit dem Akkumulator durch. Wenn zum Beispiel der Akkumulator den "
"binären Wert <tt>10101010</tt> enthält, dann wird das Ergebnis von <tt>AND</"
"tt> mit <tt>00000011</tt> <tt>00000010</tt> sein."

#: ../learn/dist/tutorial.ui:511
msgid ""
"The effect of this is to mask out the least significant two bits of the "
"accumulator, setting the others to zero. This converts a number in the range "
"of 0–255 to a number in the range of 0–3."
msgstr ""
"Die Wirkung davon ist, die zwei niedrigstwertigen Bits des Akkumulators zu "
"maskieren und die anderen auf Null zu setzen. Dies konvertiert eine Zahl im "
"Bereich von 0-255 in eine Zahl im Bereich von 0-3."

#: ../learn/dist/tutorial.ui:512
msgid ""
"After this, the value <tt>2</tt> is added to the accumulator, to create a "
"final random number in the range 2–5."
msgstr ""
"Danach wird der Wert <tt>2</tt> zum Akkumulator addiert, um eine endgültige "
"Zufallszahl im Bereich 2-5 zu erzeugen."

#: ../learn/dist/tutorial.ui:513
msgid ""
"The result of this subroutine is to load a random byte into <tt>$00</tt>, "
"and a random number between 2 and 5 into <tt>$01</tt>. Because the least "
"significant byte comes first with indirect addressing, this translates into "
"a memory address between <tt>$0200</tt> and <tt>$05ff</tt>: the exact range "
"used to draw the display."
msgstr ""
"Das Ergebnis dieses Unterprogramms ist, ein zufälliges Byte in <tt>$00</tt> "
"und eine Zufallszahl zwischen 2 und 5 in <tt>$01</tt> zu laden. Da das "
"niedrigstwertige Byte bei indirekter Adressierung zuerst kommt, übersetzt "
"sich dies in eine Speicheradresse zwischen <tt>$0200</tt> und <tt>$05ff</"
"tt>: genau der Bereich, der zum Zeichnen des Displays verwendet wird."

#: ../learn/dist/tutorial.ui:514
msgid "The game loop"
msgstr "Die Spielschleife"

#: ../learn/dist/tutorial.ui:515
msgid ""
"Nearly all games have at their heart a game loop. All game loops have the "
"same basic form: accept user input, update the game state, and render the "
"game state. This loop is no different."
msgstr ""
"Fast alle Spiele haben in ihrem Kern eine Spielschleife. Alle Spielschleifen "
"haben die gleiche Grundform: Benutzereingaben annehmen, den Spielzustand "
"aktualisieren und den Spielzustand darstellen. Diese Schleife ist da keine "
"Ausnahme."

#: ../learn/dist/tutorial.ui:516
msgid "Reading the input"
msgstr "Die Eingabe lesen"

#: ../learn/dist/tutorial.ui:517
msgid ""
"The first subroutine, <tt>readKeys</tt>, takes the job of accepting user "
"input. The memory location <tt>$ff</tt> holds the ascii code of the most "
"recent key press in this simulator. The value is loaded into the "
"accumulator, then compared to <tt>$77</tt> (the hex code for W), <tt>$64</"
"tt> (D), <tt>$73</tt> (S) and <tt>$61</tt> (A). If any of these comparisons "
"are successful, the program branches to the appropriate section."
msgstr ""
"Das erste Unterprogramm, <tt>readKeys</tt>, übernimmt die Aufgabe, "
"Benutzereingaben anzunehmen. Die Speicheradresse <tt>$ff</tt> enthält den "
"ASCII-Code des letzten Tastendrucks in diesem Simulator. Der Wert wird in "
"den Akkumulator geladen und dann mit <tt>$77</tt> (dem Hexcode für W), "
"<tt>$64</tt> (D), <tt>$73</tt> (S) und <tt>$61</tt> (A) verglichen. Wenn "
"einer dieser Vergleiche erfolgreich ist, verzweigt das Programm zum "
"entsprechenden Abschnitt."

#: ../learn/dist/tutorial.ui:518
msgid ""
"Additional button inputs are also available: button A (Enter/Return key, "
"ASCII code <tt>$0D</tt>) and button B (Space key, ASCII code <tt>$20</tt>). "
"These can be used to add more interaction to your games. For directional "
"controls, both WASD keys and arrow keys can be used interchangeably."
msgstr ""
"Zusätzliche Tasteneingaben sind ebenfalls verfügbar: Taste A (Eingabe/Return-"
"Taste, ASCII-Code <tt>$0D</tt>) und Taste B (Leertaste, ASCII-Code <tt>$20</"
"tt>). Diese können genutzt werden, um mehr Interaktion zu deinen Spielen "
"hinzuzufügen. Für die Richtungssteuerung können sowohl WASD-Tasten als auch "
"Pfeiltasten austauschbar verwendet werden."

#: ../learn/dist/tutorial.ui:519
msgid ""
"Each section (<tt>upKey</tt>, <tt>rightKey</tt>, etc.) first checks to see "
"if the current direction is the opposite of the new direction. This requires "
"another little detour."
msgstr ""
"Jeder Abschnitt (<tt>upKey</tt>, <tt>rightKey</tt>, usw.) überprüft zuerst, "
"ob die aktuelle Richtung die entgegengesetzte der neuen Richtung ist. Dies "
"erfordert einen weiteren kleinen Umweg."

#: ../learn/dist/tutorial.ui:520
msgid ""
"As stated before, the four directions are represented internally by the "
"numbers 1, 2, 4 and 8. Each of these numbers is a power of 2, thus they are "
"represented by a binary number with a single <tt>1</tt>:"
msgstr ""
"Wie bereits erwähnt, werden die vier Richtungen intern durch die Zahlen 1, "
"2, 4 und 8 dargestellt. Jede dieser Zahlen ist eine Zweierpotenz, daher "
"werden sie durch eine Binärzahl mit einer einzigen <tt>1</tt> dargestellt:"

#: ../learn/dist/tutorial.ui:525
msgid ""
"The <tt>BIT</tt> opcode is similar to <tt>AND</tt>, but the calculation is "
"only used to set the zero flag - the actual result is discarded. The zero "
"flag is set only if the result of AND-ing the accumulator with argument is "
"zero. When we're looking at powers of two, the zero flag will only be set if "
"the two numbers are not the same. For example, <tt>0001 AND 0001</tt> is not "
"zero, but <tt>0001 AND 0010</tt> is zero."
msgstr ""
"Der <tt>BIT</tt>-Opcode ist ähnlich wie <tt>AND</tt>, aber die Berechnung "
"wird nur verwendet, um das Zero-Flag zu setzen - das eigentliche Ergebnis "
"wird verworfen. Das Zero-Flag wird nur gesetzt, wenn das Ergebnis der UND-"
"Verknüpfung des Akkumulators mit dem Argument Null ist. Wenn wir "
"Zweierpotenzen betrachten, wird das Zero-Flag nur gesetzt, wenn die beiden "
"Zahlen nicht gleich sind. Zum Beispiel ist <tt>0001 AND 0001</tt> nicht "
"Null, aber <tt>0001 AND 0010</tt> ist Null."

#: ../learn/dist/tutorial.ui:526
msgid ""
"So, looking at <tt>upKey</tt>, if the current direction is down (4), the bit "
"test will be zero. <tt>BNE</tt> means \"branch if the zero flag is clear\", "
"so in this case we'll branch to <tt>illegalMove</tt>, which just returns "
"from the subroutine. Otherwise, the new direction (1 in this case) is stored "
"in the appropriate memory location."
msgstr ""
"Wenn wir also <tt>upKey</tt> betrachten und die aktuelle Richtung nach unten "
"ist (4), wird der Bit-Test Null sein. <tt>BNE</tt> bedeutet \"verzweige, "
"wenn das Zero-Flag nicht gesetzt ist\", also werden wir in diesem Fall zu "
"<tt>illegalMove</tt> verzweigen, was einfach aus dem Unterprogramm "
"zurückkehrt. Andernfalls wird die neue Richtung (in diesem Fall 1) in der "
"entsprechenden Speicheradresse gespeichert."

#: ../learn/dist/tutorial.ui:527
msgid "Updating the game state"
msgstr "Den Spielzustand aktualisieren"

#: ../learn/dist/tutorial.ui:528
msgid ""
"The next subroutine, <tt>checkCollision</tt>, defers to "
"<tt>checkAppleCollision</tt> and <tt>checkSnakeCollision</tt>. "
"<tt>checkAppleCollision</tt> just checks to see if the two bytes holding the "
"location of the apple match the two bytes holding the location of the head. "
"If they do, the length is increased and a new apple position is generated."
msgstr ""
"Das nächste Unterprogramm, <tt>checkCollision</tt>, delegiert an "
"<tt>checkAppleCollision</tt> und <tt>checkSnakeCollision</tt>. "
"<tt>checkAppleCollision</tt> überprüft nur, ob die zwei Bytes, die die "
"Position des Apfels enthalten, mit den zwei Bytes übereinstimmen, die die "
"Position des Kopfes enthalten. Wenn sie übereinstimmen, wird die Länge "
"erhöht und eine neue Apfelposition generiert."

#: ../learn/dist/tutorial.ui:529
msgid ""
"<tt>checkSnakeCollision</tt> loops through the snake's body segments, "
"checking each byte pair against the head pair. If there is a match, then "
"game over."
msgstr ""
"<tt>checkSnakeCollision</tt> durchläuft die Körpersegmente der Schlange und "
"vergleicht jedes Bytepaar mit dem Kopfpaar. Wenn es eine Übereinstimmung "
"gibt, dann ist das Spiel vorbei."

#: ../learn/dist/tutorial.ui:530
msgid ""
"After collision detection, we update the snake's location. This is done at a "
"high level like so: First, move each byte pair of the body up one position "
"in memory. Second, update the head according to the current direction. "
"Finally, if the head is out of bounds, handle it as a collision. I'll "
"illustrate this with some ascii art. Each pair of brackets contains an x,y "
"coordinate rather than a pair of bytes for simplicity."
msgstr ""
"Nach der Kollisionserkennung aktualisieren wir die Position der Schlange. "
"Dies wird auf hoher Ebene so gemacht: Zuerst wird jedes Bytepaar des Körpers "
"um eine Position im Speicher nach oben verschoben. Zweitens wird der Kopf "
"entsprechend der aktuellen Richtung aktualisiert. Schließlich wird, wenn der "
"Kopf außerhalb der Grenzen ist, dies als Kollision behandelt. Ich werde dies "
"mit ASCII-Kunst veranschaulichen. Jedes Klammerpaar enthält der Einfachheit "
"halber eine x,y-Koordinate anstelle eines Bytepaars."

#: ../learn/dist/tutorial.ui:545
msgid ""
"At a low level, this subroutine is slightly more complex. First, the length "
"is loaded into the <tt>X</tt> register, which is then decremented. The "
"snippet below shows the starting memory for the snake."
msgstr ""
"Auf niedriger Ebene ist dieses Unterprogramm etwas komplexer. Zuerst wird "
"die Länge in das <tt>X</tt>-Register geladen, das dann dekrementiert wird. "
"Der untenstehende Ausschnitt zeigt den Anfangsspeicher für die Schlange."

#: ../learn/dist/tutorial.ui:549
msgid ""
"The length is initialized to <tt>4</tt>, so <tt>X</tt> starts off as <tt>3</"
"tt>. <tt>LDA $10,x</tt> loads the value of <tt>$13</tt> into <tt>A</tt>, "
"then <tt>STA $12,x</tt> stores this value into <tt>$15</tt>. <tt>X</tt> is "
"decremented, and we loop. Now <tt>X</tt> is <tt>2</tt>, so we load <tt>$12</"
"tt> and store it into <tt>$14</tt>. This loops while <tt>X</tt> is positive "
"(<tt>BPL</tt> means \"branch if positive\")."
msgstr ""
"Die Länge wird auf <tt>4</tt> initialisiert, also beginnt <tt>X</tt> bei "
"<tt>3</tt>. <tt>LDA $10,x</tt> lädt den Wert von <tt>$13</tt> in <tt>A</tt>, "
"dann speichert <tt>STA $12,x</tt> diesen Wert in <tt>$15</tt>. <tt>X</tt> "
"wird dekrementiert und wir durchlaufen die Schleife. Jetzt ist <tt>X</tt> "
"<tt>2</tt>, also laden wir <tt>$12</tt> und speichern es in <tt>$14</tt>. "
"Dies läuft in einer Schleife, solange <tt>X</tt> positiv ist (<tt>BPL</tt> "
"bedeutet \"verzweige wenn positiv\")."

#: ../learn/dist/tutorial.ui:550
msgid ""
"Once the values have been shifted down the snake, we have to work out what "
"to do with the head. The direction is first loaded into <tt>A</tt>. <tt>LSR</"
"tt> means \"logical shift right\", or \"shift all the bits one position to "
"the right\". The least significant bit is shifted into the carry flag, so if "
"the accumulator is <tt>1</tt>, after <tt>LSR</tt> it is <tt>0</tt>, with the "
"carry flag set."
msgstr ""
"Sobald die Werte die Schlange hinunter verschoben wurden, müssen wir "
"herausfinden, was mit dem Kopf zu tun ist. Die Richtung wird zuerst in "
"<tt>A</tt> geladen. <tt>LSR</tt> bedeutet \"logische Verschiebung nach "
"rechts\" oder \"verschiebe alle Bits um eine Position nach rechts\". Das "
"niedrigstwertige Bit wird in das Carry-Flag verschoben, also wenn der "
"Akkumulator <tt>1</tt> ist, ist er nach <tt>LSR</tt> <tt>0</tt>, wobei das "
"Carry-Flag gesetzt ist."

#: ../learn/dist/tutorial.ui:551
msgid ""
"To test whether the direction is <tt>1</tt>, <tt>2</tt>, <tt>4</tt> or "
"<tt>8</tt>, the code continually shifts right until the carry is set. One "
"<tt>LSR</tt> means \"up\", two means \"right\", and so on."
msgstr ""
"Um zu testen, ob die Richtung <tt>1</tt>, <tt>2</tt>, <tt>4</tt> oder <tt>8</"
"tt> ist, verschiebt der Code kontinuierlich nach rechts, bis das Carry "
"gesetzt ist. Ein <tt>LSR</tt> bedeutet \"nach oben\", zwei bedeutet \"nach "
"rechts\" und so weiter."

#: ../learn/dist/tutorial.ui:552
msgid ""
"The next bit updates the head of the snake depending on the direction. This "
"is probably the most complicated part of the code, and it's all reliant on "
"how memory locations map to the screen, so let's look at that in more detail."
msgstr ""
"Der nächste Teil aktualisiert den Kopf der Schlange abhängig von der "
"Richtung. Dies ist wahrscheinlich der komplizierteste Teil des Codes, und es "
"hängt alles davon ab, wie Speicheradressen auf den Bildschirm abgebildet "
"werden, also lass uns das genauer betrachten."

#: ../learn/dist/tutorial.ui:553
msgid ""
"You can think of the screen as four horizontal strips of 32 × 8 pixels. "
"These strips map to <tt>$0200-$02ff</tt>, <tt>$0300-$03ff</tt>, <tt>$0400-"
"$04ff</tt> and <tt>$0500-$05ff</tt>. The first rows of pixels are <tt>$0200-"
"$021f</tt>, <tt>$0220-$023f</tt>, <tt>$0240-$025f</tt>, etc."
msgstr ""
"Du kannst dir den Bildschirm als vier horizontale Streifen von 32 × 8 Pixeln "
"vorstellen. Diese Streifen werden auf <tt>$0200-$02ff</tt>, <tt>$0300-$03ff</"
"tt>, <tt>$0400-$04ff</tt> und <tt>$0500-$05ff</tt> abgebildet. Die ersten "
"Pixelreihen sind <tt>$0200-$021f</tt>, <tt>$0220-$023f</tt>, <tt>$0240-"
"$025f</tt>, usw."

#: ../learn/dist/tutorial.ui:554
msgid ""
"As long as you're moving within one of these horizontal strips, things are "
"simple. For example, to move right, just increment the least significant "
"byte (e.g. <tt>$0200</tt> becomes <tt>$0201</tt>). To go down, add <tt>$20</"
"tt> (e.g. <tt>$0200</tt> becomes <tt>$0220</tt>). Left and up are the "
"reverse."
msgstr ""
"Solange du dich innerhalb eines dieser horizontalen Streifen bewegst, sind "
"die Dinge einfach. Um zum Beispiel nach rechts zu gehen, erhöhe einfach das "
"niedrigstwertige Byte (z.B. wird aus <tt>$0200</tt> dann <tt>$0201</tt>). Um "
"nach unten zu gehen, addiere <tt>$20</tt> (z.B. wird aus <tt>$0200</tt> dann "
"<tt>$0220</tt>). Links und oben sind die Umkehrung davon."

#: ../learn/dist/tutorial.ui:555
msgid ""
"Going between sections is more complicated, as we have to take into account "
"the most significant byte as well. For example, going down from <tt>$02e1</"
"tt> should lead to <tt>$0301</tt>. Luckily, this is fairly easy to "
"accomplish. Adding <tt>$20</tt> to <tt>$e1</tt> results in <tt>$01</tt> and "
"sets the carry bit. If the carry bit was set, we know we also need to "
"increment the most significant byte."
msgstr ""
"Der Übergang zwischen den Abschnitten ist komplizierter, da wir auch das "
"höchstwertige Byte berücksichtigen müssen. Zum Beispiel sollte das "
"Heruntergehen von <tt>$02e1</tt> zu <tt>$0301</tt> führen. Glücklicherweise "
"ist dies ziemlich einfach zu erreichen. Die Addition von <tt>$20</tt> zu "
"<tt>$e1</tt> ergibt <tt>$01</tt> und setzt das Carry-Bit. Wenn das Carry-Bit "
"gesetzt wurde, wissen wir, dass wir auch das höchstwertige Byte erhöhen "
"müssen."

#: ../learn/dist/tutorial.ui:556
msgid ""
"After a move in each direction, we also need to check to see if the head "
"would become out of bounds. This is handled differently for each direction. "
"For left and right, we can check to see if the head has effectively "
"\"wrapped around\". Going right from <tt>$021f</tt> by incrementing the "
"least significant byte would lead to <tt>$0220</tt>, but this is actually "
"jumping from the last pixel of the first row to the first pixel of the "
"second row. So, every time we move right, we need to check if the new least "
"significant byte is a multiple of <tt>$20</tt>. This is done using a bit "
"check against the mask <tt>$1f</tt>. Hopefully the illustration below will "
"show you how masking out the lowest 5 bits reveals whether a number is a "
"multiple of <tt>$20</tt> or not."
msgstr ""
"Nach einer Bewegung in jede Richtung müssen wir auch überprüfen, ob der Kopf "
"außerhalb der Grenzen geraten würde. Dies wird für jede Richtung "
"unterschiedlich gehandhabt. Für links und rechts können wir überprüfen, ob "
"der Kopf effektiv \"umgebrochen\" ist. Wenn man von <tt>$021f</tt> nach "
"rechts geht, indem man das niedrigstwertige Byte erhöht, würde dies zu "
"<tt>$0220</tt> führen, aber das bedeutet eigentlich einen Sprung vom letzten "
"Pixel der ersten Zeile zum ersten Pixel der zweiten Zeile. Also müssen wir "
"jedes Mal, wenn wir nach rechts gehen, überprüfen, ob das neue "
"niedrigstwertige Byte ein Vielfaches von <tt>$20</tt> ist. Dies geschieht "
"durch eine Bit-Prüfung gegen die Maske <tt>$1f</tt>. Die Illustration unten "
"wird hoffentlich zeigen, wie das Maskieren der niedrigsten 5 Bits offenbart, "
"ob eine Zahl ein Vielfaches von <tt>$20</tt> ist oder nicht."

#: ../learn/dist/tutorial.ui:562
msgid ""
"I won't explain in depth how each of the directions work, but the above "
"explanation should give you enough to work it out with a bit of study."
msgstr ""
"Ich werde nicht im Detail erklären, wie jede der Richtungen funktioniert, "
"aber die obige Erklärung sollte dir genug geben, um es mit etwas Studium "
"selbst herauszufinden."

#: ../learn/dist/tutorial.ui:563
msgid "Rendering the game"
msgstr "Das Spiel darstellen"

#: ../learn/dist/tutorial.ui:564
msgid ""
"Because the game state is stored in terms of pixel locations, rendering the "
"game is very straightforward. The first subroutine, <tt>drawApple</tt>, is "
"extremely simple. It sets <tt>Y</tt> to zero, loads a random colour into the "
"accumulator, then stores this value into <tt>($00),y</tt>. <tt>$00</tt> is "
"where the location of the apple is stored, so <tt>($00),y</tt> dereferences "
"to this memory location. Read the \"Indirect indexed\" section in <a "
"href=\"#addressing\">Addressing modes</a> for more details."
msgstr ""
"Da der Spielzustand in Form von Pixelpositionen gespeichert wird, ist die "
"Darstellung des Spiels sehr einfach. Das erste Unterprogramm, <tt>drawApple</"
"tt>, ist extrem einfach. Es setzt <tt>Y</tt> auf Null, lädt eine zufällige "
"Farbe in den Akkumulator und speichert diesen Wert dann in <tt>($00),y</tt>. "
"<tt>$00</tt> ist der Ort, an dem die Position des Apfels gespeichert ist, "
"also dereferenziert <tt>($00),y</tt> zu dieser Speicheradresse. Lies den "
"Abschnitt \"Indirekt indiziert\" in <a "
"href=\"#addressing\">Adressierungsmodi</a> für weitere Details."

#: ../learn/dist/tutorial.ui:565
msgid ""
"Next comes <tt>drawSnake</tt>. This is pretty simple too - we first undraw "
"the tail and then draw the head. <tt>X</tt> is set to the length of the "
"snake, so we can index to the right pixel, and we set <tt>A</tt> to zero "
"then perform the write using the indexed indirect addressing mode. Then we "
"reload <tt>X</tt> to index to the head, set <tt>A</tt> to one and store it "
"at <tt>($10,x)</tt>. <tt>$10</tt> stores the two-byte location of the head, "
"so this draws a white pixel at the current head position. As only the head "
"and the tail of the snake move, this is enough to keep the snake moving."
msgstr ""
"Als nächstes kommt <tt>drawSnake</tt>. Dies ist auch ziemlich einfach - wir "
"löschen zuerst den Schwanz und zeichnen dann den Kopf. <tt>X</tt> wird auf "
"die Länge der Schlange gesetzt, damit wir zum richtigen Pixel indexieren "
"können, und wir setzen <tt>A</tt> auf Null und führen dann das Schreiben mit "
"dem indizierten indirekten Adressierungsmodus durch. Dann laden wir <tt>X</"
"tt> neu, um zum Kopf zu indexieren, setzen <tt>A</tt> auf eins und speichern "
"es in <tt>($10,x)</tt>. <tt>$10</tt> speichert die zweibyte-Position des "
"Kopfes, also zeichnet dies einen weißen Pixel an der aktuellen Kopfposition. "
"Da sich nur der Kopf und der Schwanz der Schlange bewegen, reicht dies aus, "
"um die Schlange in Bewegung zu halten."

#: ../learn/dist/tutorial.ui:566
msgid ""
"The last subroutine, <tt>spinWheels</tt>, is just there because the game "
"would run too fast otherwise. All <tt>spinWheels</tt> does is count <tt>X</"
"tt> down from zero until it hits zero again. The first <tt>dex</tt> wraps, "
"making <tt>X</tt> <tt>#$ff</tt>."
msgstr ""
"Das letzte Unterprogramm, <tt>spinWheels</tt>, ist nur da, weil das Spiel "
"sonst zu schnell laufen würde. Alles, was <tt>spinWheels</tt> tut, ist "
"<tt>X</tt> von Null herunterzuzählen, bis es wieder Null erreicht. Das erste "
"<tt>dex</tt> überläuft, wodurch <tt>X</tt> zu <tt>#$ff</tt> wird."

#~ msgid "6502 Assembly Quick Reference"
#~ msgstr "6502-Assembler-Kurzreferenz"
