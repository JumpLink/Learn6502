{
  "6502": "6502",
  "Unable to relocate code outside 64k memory": "Unable to relocate code outside 64k memory",
  "Assembling code ...": "Assembling code ...",
  "No code to run.": "No code to run.",
  "Syntax error line %d: %s": "Syntax error line %d: %s",
  "Out of range branch on line %d (branches are limited to -128 to +127): %s": "Out of range branch on line %d (branches are limited to -128 to +127): %s",
  "Code assembled successfully, %d bytes.": "Code assembled successfully, %d bytes.",
  "Preprocessing ...": "Preprocessing ...",
  "Found $d labels.": "Found $d labels.",
  "Found $d label.": "Found $d label.",
  "Indexing labels...": "Indexing labels...",
  "Label already defined at line %s: %d": "Label already defined at line %s: %d",
  "Label {label} is already used as a symbol; please rename one of them": "Label {label} is already used as a symbol; please rename one of them",
  "No address or label provided": "No address or label provided",
  "Unable to find/parse given address/label": "Unable to find/parse given address/label",
  "Stopped": "Stopped",
  "wdm-output": "wdm-output",
  "Address %s - unknown opcode": "Address %s - unknown opcode",
  "6502 Stack filled! Wrapping...": "6502 Stack filled! Wrapping...",
  "6502 Stack emptied! Wrapping...": "6502 Stack emptied! Wrapping...",
  "Program completed at PC=$%s": "Program completed at PC=$%s",
  "Unsaved changes": "Unsaved changes",
  "File \"%s\" has unsaved changes": "File \"%s\" has unsaved changes",
  "Assemble": "Assemble",
  "Run": "Run",
  "Pause": "Pause",
  "Resume": "Resume",
  "Reset": "Reset",
  "Step": "Step",
  "Code copied to editor": "Code copied to editor",
  "Copied to clipboard": "Copied to clipboard",
  "Failed to copy to clipboard": "Failed to copy to clipboard",
  "Program paused automatically": "Program paused automatically",
  "Assembled successfully": "Assembled successfully",
  "Assemble failed": "Assemble failed",
  "Hexdump:": "Hexdump:",
  "Disassembly:": "Disassembly:",
  "Simulator failure": "Simulator failure",
  "Labels failure": "Labels failure",
  "Gamepad key pressed:": "Gamepad key pressed:",
  "Open Assembly File": "Open Assembly File",
  "Failed to load file": "Failed to load file",
  "File loaded successfully": "File loaded successfully",
  "Error opening file": "Error opening file",
  "untitled": "untitled",
  "Save Assembly File": "Save Assembly File",
  "Error saving file": "Error saving file",
  "File saved successfully": "File saved successfully",
  "Assembly Files": "Assembly Files",
  "All Files": "All Files",
  "Learn 6502 Assembly": "Learn 6502 Assembly",
  "Menu": "Menu",
  "Learn": "Learn",
  "Editor": "Editor",
  "Debugger": "Debugger",
  "Game Console": "Game Console",
  "Open...": "Open...",
  "Save": "Save",
  "Save as...": "Save as...",
  "Help": "Help",
  "About Learn 6502 Assembly": "About Learn 6502 Assembly",
  "Quit": "Quit",
  "Continue": "Continue",
  "Save changes?": "Save changes?",
  "Your file has unsaved changes. Changes will be lost if you don't save them.": "Your file has unsaved changes. Changes will be lost if you don't save them.",
  "Cancel": "Cancel",
  "Discard": "Discard",
  "Debug your 6502 assembly code, step through your program, and view memory and registers. To get started, assemble and run your program.": "Debug your 6502 assembly code, step through your program, and view memory and registers. To get started, assemble and run your program.",
  "Information": "Information",
  "Messages": "Messages",
  "Hex Monitor": "Hex Monitor",
  "Hexdump": "Hexdump",
  "Disassembled": "Disassembled",
  "Learn how to program the 6502 microprocessor.": "Learn how to program the 6502 microprocessor.",
  "Preferences": "Preferences",
  "Appearance": "Appearance",
  "Main Settings": "Main Settings",
  "There are currently no settings.": "There are currently no settings.",
  "Copy to editor": "Copy to editor",
  "Zero Page ($0000-$00FF)": "Zero Page ($0000-$00FF)",
  "Stack ($0100-$01FF)": "Stack ($0100-$01FF)",
  "Display Memory ($0200-$05FF)": "Display Memory ($0200-$05FF)",
  "Program Storage ($0600-$FFFF)": "Program Storage ($0600-$FFFF)",
  "Snake Game Data ($00-$15)": "Snake Game Data ($00-$15)",
  "Random/Input ($FE-$FF)": "Random/Input ($FE-$FF)",
  "Full Memory ($0000-$FFFF)": "Full Memory ($0000-$FFFF)",
  "Copy to clipboard": "Copy to clipboard",
  "6502 Assembly Learning Environment": "6502 Assembly Learning Environment",
  "A comprehensive learning environment for programming vintage computers and game consoles using 6502 assembly language.": "A comprehensive learning environment for programming vintage computers and game consoles using 6502 assembly language.",
  "Features:": "Features:",
  "Learn step-by-step with an interactive tutorial": "Learn step-by-step with an interactive tutorial",
  "Write code with a built-in editor": "Write code with a built-in editor",
  "Debug your programs with real-time tools": "Debug your programs with real-time tools",
  "See your code run on a virtual game console": "See your code run on a virtual game console",
  "Interactive tutorial interface in light theme": "Interactive tutorial interface in light theme",
  "Interactive tutorial interface in dark theme": "Interactive tutorial interface in dark theme",
  "Code editor with 6502 assembly syntax highlighting and visible help": "Code editor with 6502 assembly syntax highlighting and visible help",
  "Built-in debugger showing real-time registers, flags, and memory": "Built-in debugger showing real-time registers, flags, and memory",
  "Virtual game console displaying three colored pixels": "Virtual game console displaying three colored pixels",
  "Major update focusing on improved learning experience and usability": "Major update focusing on improved learning experience and usability",
  "Added help feature to make code editing easier for beginners": "Added help feature to make code editing easier for beginners",
  "Improved game screen and controls for mobile devices": "Improved game screen and controls for mobile devices",
  "New tools to examine your code, including disassembler and fast switchable memory viewer": "New tools to examine your code, including disassembler and fast switchable memory viewer",
  "Many minor bugs have been fixed to improve overall usability": "Many minor bugs have been fixed to improve overall usability",
  "Games now automatically pause when switching between screens": "Games now automatically pause when switching between screens",
  "Added file management to save and load your programs": "Added file management to save and load your programs",
  "Enhanced app presentation and accessibility": "Enhanced app presentation and accessibility",
  "Improved descriptions to be more welcoming for non-technical users": "Improved descriptions to be more welcoming for non-technical users",
  "Optimized Flatpak configuration by removing unnecessary permissions": "Optimized Flatpak configuration by removing unnecessary permissions",
  "Improved the game console performance for smoother gameplay": "Improved the game console performance for smoother gameplay",
  "Enhanced the hex monitor address range input for easier value editing": "Enhanced the hex monitor address range input for easier value editing",
  "Reduced default hex monitor address range for better efficiency": "Reduced default hex monitor address range for better efficiency",
  "Debugger now only updates when visible, reducing unnecessary processing": "Debugger now only updates when visible, reducing unnecessary processing",
  "Fixed build error on PostmarketOS, improving mobile compatibility": "Fixed build error on PostmarketOS, improving mobile compatibility",
  "First release of Learn 6502 Assembly for GNOME": "First release of Learn 6502 Assembly for GNOME",
  "Assembly": "Assembly",
  "Programming": "Programming",
  "Learning": "Learning",
  "Emulator": "Emulator",
  "Memory Map": "Memory Map",
  "<b>Zero Page</b>: <tt>$0000</tt>-<tt>$00FF</tt> (first 256 bytes, faster access)": "<b>Zero Page</b>: <tt>$0000</tt>-<tt>$00FF</tt> (first 256 bytes, faster access)",
  "<b>Stack</b>: <tt>$0100</tt>-<tt>$01FF</tt>": "<b>Stack</b>: <tt>$0100</tt>-<tt>$01FF</tt>",
  "<b>Display Memory</b>: <tt>$0200</tt>-<tt>$05FF</tt> (used for screen output)": "<b>Display Memory</b>: <tt>$0200</tt>-<tt>$05FF</tt> (used for screen output)",
  "<b>Program Storage</b>: Starting at <tt>$0600</tt>": "<b>Program Storage</b>: Starting at <tt>$0600</tt>",
  "Display Organization": "Display Organization",
  "Screen maps to memory range <tt>$0200</tt>-<tt>$05FF</tt>": "Screen maps to memory range <tt>$0200</tt>-<tt>$05FF</tt>",
  "Values <tt>$00</tt>-<tt>$0F</tt> represent 16 different colors (<tt>$00</tt>=black, <tt>$01</tt>=white)": "Values <tt>$00</tt>-<tt>$0F</tt> represent 16 different colors (<tt>$00</tt>=black, <tt>$01</tt>=white)",
  "Organized as four horizontal strips of 32×8 pixels": "Organized as four horizontal strips of 32×8 pixels",
  "First row: <tt>$0200</tt>-<tt>$021F</tt>, second row: <tt>$0220</tt>-<tt>$023F</tt>, etc.": "First row: <tt>$0200</tt>-<tt>$021F</tt>, second row: <tt>$0220</tt>-<tt>$023F</tt>, etc.",
  "Color Palette": "Color Palette",
  "<b><tt>$0</tt></b>: Black (<tt>#000000</tt>)": "<b><tt>$0</tt></b>: Black (<tt>#000000</tt>)",
  "<b><tt>$1</tt></b>: White (<tt>#ffffff</tt>)": "<b><tt>$1</tt></b>: White (<tt>#ffffff</tt>)",
  "<b><tt>$2</tt></b>: Red (<tt>#880000</tt>)": "<b><tt>$2</tt></b>: Red (<tt>#880000</tt>)",
  "<b><tt>$3</tt></b>: Cyan (<tt>#aaffee</tt>)": "<b><tt>$3</tt></b>: Cyan (<tt>#aaffee</tt>)",
  "<b><tt>$4</tt></b>: Purple (<tt>#cc44cc</tt>)": "<b><tt>$4</tt></b>: Purple (<tt>#cc44cc</tt>)",
  "<b><tt>$5</tt></b>: Green (<tt>#00cc55</tt>)": "<b><tt>$5</tt></b>: Green (<tt>#00cc55</tt>)",
  "<b><tt>$6</tt></b>: Blue (<tt>#0000aa</tt>)": "<b><tt>$6</tt></b>: Blue (<tt>#0000aa</tt>)",
  "<b><tt>$7</tt></b>: Yellow (<tt>#eeee77</tt>)": "<b><tt>$7</tt></b>: Yellow (<tt>#eeee77</tt>)",
  "<b><tt>$8</tt></b>: Orange (<tt>#dd8855</tt>)": "<b><tt>$8</tt></b>: Orange (<tt>#dd8855</tt>)",
  "<b><tt>$9</tt></b>: Brown (<tt>#664400</tt>)": "<b><tt>$9</tt></b>: Brown (<tt>#664400</tt>)",
  "<b><tt>$a</tt></b>: Light red (<tt>#ff7777</tt>)": "<b><tt>$a</tt></b>: Light red (<tt>#ff7777</tt>)",
  "<b><tt>$b</tt></b>: Dark grey (<tt>#333333</tt>)": "<b><tt>$b</tt></b>: Dark grey (<tt>#333333</tt>)",
  "<b><tt>$c</tt></b>: Grey (<tt>#777777</tt>)": "<b><tt>$c</tt></b>: Grey (<tt>#777777</tt>)",
  "<b><tt>$d</tt></b>: Light green (<tt>#aaff66</tt>)": "<b><tt>$d</tt></b>: Light green (<tt>#aaff66</tt>)",
  "<b><tt>$e</tt></b>: Light blue (<tt>#0088ff</tt>)": "<b><tt>$e</tt></b>: Light blue (<tt>#0088ff</tt>)",
  "<b><tt>$f</tt></b>: Light grey (<tt>#bbbbbb</tt>)": "<b><tt>$f</tt></b>: Light grey (<tt>#bbbbbb</tt>)",
  "Registers": "Registers",
  "<b>A</b> (Accumulator): Main register for calculations and data manipulation": "<b>A</b> (Accumulator): Main register for calculations and data manipulation",
  "<b>X, Y</b>: Index registers for addressing and counting": "<b>X, Y</b>: Index registers for addressing and counting",
  "<b>SP</b> (Stack Pointer): Points to current stack position (starts at <tt>$FF</tt>)": "<b>SP</b> (Stack Pointer): Points to current stack position (starts at <tt>$FF</tt>)",
  "<b>PC</b> (Program Counter): Points to the next instruction to execute": "<b>PC</b> (Program Counter): Points to the next instruction to execute",
  "Processor Flags": "Processor Flags",
  "<b>N</b> (Negative): Set when bit 7 of result is set": "<b>N</b> (Negative): Set when bit 7 of result is set",
  "<b>V</b> (Overflow): Set when arithmetic operation causes signed overflow": "<b>V</b> (Overflow): Set when arithmetic operation causes signed overflow",
  "<b>B</b> (Break): Set when BRK instruction is executed": "<b>B</b> (Break): Set when BRK instruction is executed",
  "<b>D</b> (Decimal): Set when processor is in BCD (Binary Coded Decimal) mode": "<b>D</b> (Decimal): Set when processor is in BCD (Binary Coded Decimal) mode",
  "<b>I</b> (Interrupt): Set when interrupts are disabled": "<b>I</b> (Interrupt): Set when interrupts are disabled",
  "<b>Z</b> (Zero): Set when result is zero": "<b>Z</b> (Zero): Set when result is zero",
  "<b>C</b> (Carry): Set when arithmetic operations overflow a byte": "<b>C</b> (Carry): Set when arithmetic operations overflow a byte",
  "Used for conditional branching": "Used for conditional branching",
  "Addressing Modes": "Addressing Modes",
  "<b>Immediate</b> (<tt>#$c0</tt>): Use the actual value": "<b>Immediate</b> (<tt>#$c0</tt>): Use the actual value",
  "<b>Zero Page</b> (<tt>$c0</tt>): Access memory locations <tt>$00</tt>-<tt>$FF</tt>": "<b>Zero Page</b> (<tt>$c0</tt>): Access memory locations <tt>$00</tt>-<tt>$FF</tt>",
  "<b>Absolute</b> (<tt>$c000</tt>): Access any memory location": "<b>Absolute</b> (<tt>$c000</tt>): Access any memory location",
  "<b>Zero Page,X/Y</b> (<tt>$c0,X</tt>): Add X/Y register to zero page address": "<b>Zero Page,X/Y</b> (<tt>$c0,X</tt>): Add X/Y register to zero page address",
  "<b>Absolute,X/Y</b> (<tt>$c000,X</tt>): Add X/Y register to absolute address": "<b>Absolute,X/Y</b> (<tt>$c000,X</tt>): Add X/Y register to absolute address",
  "<b>Indirect</b> (<tt>($c000)</tt>): Look up address stored at given location": "<b>Indirect</b> (<tt>($c000)</tt>): Look up address stored at given location",
  "<b>Indexed Indirect</b> (<tt>($c0,X)</tt>): Add X to zero page address, then dereference": "<b>Indexed Indirect</b> (<tt>($c0,X)</tt>): Add X to zero page address, then dereference",
  "<b>Indirect Indexed</b> (<tt>($c0),Y</tt>): Dereference zero page address, then add Y": "<b>Indirect Indexed</b> (<tt>($c0),Y</tt>): Dereference zero page address, then add Y",
  "Common Instructions": "Common Instructions",
  "<b>LDA/LDX/LDY</b>: Load registers": "<b>LDA/LDX/LDY</b>: Load registers",
  "<b>STA/STX/STY</b>: Store registers to memory": "<b>STA/STX/STY</b>: Store registers to memory",
  "<b>INX/INY/DEX/DEY</b>: Increment/decrement registers": "<b>INX/INY/DEX/DEY</b>: Increment/decrement registers",
  "<b>ADC/SBC</b>: Add/subtract with carry": "<b>ADC/SBC</b>: Add/subtract with carry",
  "<b>JMP</b>: Unconditional jump": "<b>JMP</b>: Unconditional jump",
  "<b>JSR/RTS</b>: Jump to subroutine / Return from subroutine": "<b>JSR/RTS</b>: Jump to subroutine / Return from subroutine",
  "<b>BEQ/BNE/BCC/BCS</b>: Branch if equal/not equal/carry clear/carry set": "<b>BEQ/BNE/BCC/BCS</b>: Branch if equal/not equal/carry clear/carry set",
  "<b>PHA/PLA</b>: Push/pull accumulator to/from stack": "<b>PHA/PLA</b>: Push/pull accumulator to/from stack",
  "Special Memory Locations (in Simulator)": "Special Memory Locations (in Simulator)",
  "<b><tt>$FE</tt></b>: Random number generator (reads as a random value 0-255)": "<b><tt>$FE</tt></b>: Random number generator (reads as a random value 0-255)",
  "<b><tt>$FF</tt></b>: Last pressed key (ASCII code)": "<b><tt>$FF</tt></b>: Last pressed key (ASCII code)",
  "<b>Directional controls</b>:": "<b>Directional controls</b>:",
  "<b>W</b> or Up Arrow key (<tt>$77</tt>)": "<b>W</b> or Up Arrow key (<tt>$77</tt>)",
  "<b>A</b> or Left Arrow key (<tt>$61</tt>)": "<b>A</b> or Left Arrow key (<tt>$61</tt>)",
  "<b>S</b> or Down Arrow key (<tt>$73</tt>)": "<b>S</b> or Down Arrow key (<tt>$73</tt>)",
  "<b>D</b> or Right Arrow key (<tt>$64</tt>)": "<b>D</b> or Right Arrow key (<tt>$64</tt>)",
  "<b>Action buttons</b>:": "<b>Action buttons</b>:",
  "<b>Q</b> or Enter/Return key (<tt>$0D</tt>)": "<b>Q</b> or Enter/Return key (<tt>$0D</tt>)",
  "<b>E</b> or Space key (<tt>$20</tt>)": "<b>E</b> or Space key (<tt>$20</tt>)",
  "Snake Game Memory Usage": "Snake Game Memory Usage",
  "<b><tt>$00</tt>-<tt>$01</tt></b>: Apple position": "<b><tt>$00</tt>-<tt>$01</tt></b>: Apple position",
  "<b><tt>$02</tt></b>: Snake direction (1=up, 2=right, 4=down, 8=left)": "<b><tt>$02</tt></b>: Snake direction (1=up, 2=right, 4=down, 8=left)",
  "<b><tt>$03</tt></b>: Snake length": "<b><tt>$03</tt></b>: Snake length",
  "<b><tt>$10</tt>-<tt>$15</tt></b>: Snake position data (head, body segments, tail)": "<b><tt>$10</tt>-<tt>$15</tt></b>: Snake position data (head, body segments, tail)",
  "Tutorial <sub>by <a href=\"https://www.skilldrick.co.uk/\">Nick Morgan</a>, licensed under CC BY 4.0</sub>": "Tutorial <sub>by <a href=\"https://www.skilldrick.co.uk/\">Nick Morgan</a>, licensed under CC BY 4.0</sub>",
  "Introduction": "Introduction",
  "In this tiny tutorial I'm going to show you how to get started writing 6502 assembly language. The 6502 processor was massive in the seventies and eighties, powering famous computers like the <a href=\"http://en.wikipedia.org/wiki/BBC_Micro\">BBC Micro</a>, <a href=\"http://en.wikipedia.org/wiki/Atari_2600\">Atari 2600</a>, <a href=\"http://en.wikipedia.org/wiki/Commodore_64\">Commodore 64</a>, <a href=\"http://en.wikipedia.org/wiki/Apple_II\">Apple II</a>, and the <a href=\"http://en.wikipedia.org/wiki/Nintendo_Entertainment_System\">Nintendo Entertainment System</a>. Bender in Futurama <a href=\"http://www.transbyte.org/SID/SID-files/Bender_6502.jpg\">has a 6502 processor for a brain</a>. <a href=\"http://www.pagetable.com/docs/terminator/00-37-23.jpg\">Even the Terminator was programmed in 6502</a>.": "In this tiny tutorial I'm going to show you how to get started writing 6502 assembly language. The 6502 processor was massive in the seventies and eighties, powering famous computers like the <a href=\"http://en.wikipedia.org/wiki/BBC_Micro\">BBC Micro</a>, <a href=\"http://en.wikipedia.org/wiki/Atari_2600\">Atari 2600</a>, <a href=\"http://en.wikipedia.org/wiki/Commodore_64\">Commodore 64</a>, <a href=\"http://en.wikipedia.org/wiki/Apple_II\">Apple II</a>, and the <a href=\"http://en.wikipedia.org/wiki/Nintendo_Entertainment_System\">Nintendo Entertainment System</a>. Bender in Futurama <a href=\"http://www.transbyte.org/SID/SID-files/Bender_6502.jpg\">has a 6502 processor for a brain</a>. <a href=\"http://www.pagetable.com/docs/terminator/00-37-23.jpg\">Even the Terminator was programmed in 6502</a>.",
  "So, why would you want to learn 6502? It's a dead language isn't it? Well, so's Latin. And they still teach that. <a href=\"http://en.wikipedia.org/wiki/Q.E.D.\">Q.E.D.</a>": "So, why would you want to learn 6502? It's a dead language isn't it? Well, so's Latin. And they still teach that. <a href=\"http://en.wikipedia.org/wiki/Q.E.D.\">Q.E.D.</a>",
  "(Actually, I've been reliably informed that 6502 processors are still being produced by <a href=\"http://www.westerndesigncenter.com/wdc/w65c02s-chip.cfm\">Western Design Center</a> and <a href=\"http://www.mouser.co.uk/Search/Refine.aspx?Keyword=65C02\">sold to hobbyists</a>, so clearly 6502 <i>isn&apos;t</i> a dead language! Who knew?)": "(Actually, I've been reliably informed that 6502 processors are still being produced by <a href=\"http://www.westerndesigncenter.com/wdc/w65c02s-chip.cfm\">Western Design Center</a> and <a href=\"http://www.mouser.co.uk/Search/Refine.aspx?Keyword=65C02\">sold to hobbyists</a>, so clearly 6502 <i>isn&apos;t</i> a dead language! Who knew?)",
  "Seriously though, I think it's valuable to have an understanding of assembly language. Assembly language is the lowest level of abstraction in computers - the point at which the code is still readable. Assembly language translates directly to the bytes that are executed by your computer's processor. If you understand how it works, you've basically become a computer <a href=\"http://skilldrick.co.uk/2011/04/magic-in-software-development/\">magician</a>.": "Seriously though, I think it's valuable to have an understanding of assembly language. Assembly language is the lowest level of abstraction in computers - the point at which the code is still readable. Assembly language translates directly to the bytes that are executed by your computer's processor. If you understand how it works, you've basically become a computer <a href=\"http://skilldrick.co.uk/2011/04/magic-in-software-development/\">magician</a>.",
  "Then why 6502? Why not a <i>useful</i> assembly language, like <a href=\"http://en.wikipedia.org/wiki/X86\">x86</a>? Well, I don't think learning x86 is useful. I don't think you'll ever have to <i>write</i> assembly language in your day job - this is purely an academic exercise, something to expand your mind and your thinking. 6502 was originally written in a different age, a time when the majority of developers were writing assembly directly, rather than in these new-fangled high-level programming languages. So, it was designed to be written by humans. More modern assembly languages are meant to written by compilers, so let's leave it to them. Plus, 6502 is <i>fun</i>. Nobody ever called x86 <i>fun</i>.": "Then why 6502? Why not a <i>useful</i> assembly language, like <a href=\"http://en.wikipedia.org/wiki/X86\">x86</a>? Well, I don't think learning x86 is useful. I don't think you'll ever have to <i>write</i> assembly language in your day job - this is purely an academic exercise, something to expand your mind and your thinking. 6502 was originally written in a different age, a time when the majority of developers were writing assembly directly, rather than in these new-fangled high-level programming languages. So, it was designed to be written by humans. More modern assembly languages are meant to written by compilers, so let's leave it to them. Plus, 6502 is <i>fun</i>. Nobody ever called x86 <i>fun</i>.",
  "Our first program": "Our first program",
  "So, let's dive in! This application contains a <a href=\"https://github.com/skilldrick/6502js\">JavaScript 6502 Assembler and Simulator</a> that I have adapted for this interactive tutorial. Click the <b>Copy</b> button in the code block below to copy the example code to the editor. Then click the button in the top right to assemble the code, then click it again to run the program. You can also access these actions through the dropdown menu.": "So, let's dive in! This application contains a <a href=\"https://github.com/skilldrick/6502js\">JavaScript 6502 Assembler and Simulator</a> that I have adapted for this interactive tutorial. Click the <b>Copy</b> button in the code block below to copy the example code to the editor. Then click the button in the top right to assemble the code, then click it again to run the program. You can also access these actions through the dropdown menu.",
  "The black game console screen now should show three coloured \"pixels\" at the top left.": "The black game console screen now should show three coloured \"pixels\" at the top left.",
  "So, what's this program actually doing? Let's step through it. Hit <b>Reset</b>, then select <b>Step</b> from the dropdown menu. The button will switch to step mode, allowing you to execute the program one instruction at a time. Click once and you'll notice in the debugger that <tt>A=</tt> changed from <tt>$00</tt> to <tt>$01</tt>, and <tt>PC=</tt> changed from <tt>$0600</tt> to <tt>$0602</tt>.": "So, what's this program actually doing? Let's step through it. Hit <b>Reset</b>, then select <b>Step</b> from the dropdown menu. The button will switch to step mode, allowing you to execute the program one instruction at a time. Click once and you'll notice in the debugger that <tt>A=</tt> changed from <tt>$00</tt> to <tt>$01</tt>, and <tt>PC=</tt> changed from <tt>$0600</tt> to <tt>$0602</tt>.",
  "Any numbers prefixed with <tt>$</tt> in 6502 assembly language (and by extension, in this book) are in hexadecimal (hex) format. If you're not familiar with hex numbers, I recommend you read <a href=\"http://en.wikipedia.org/wiki/Hexadecimal\">the Wikipedia article</a>. Anything prefixed with <tt>#</tt> is a literal number value. Any other number refers to a memory location.": "Any numbers prefixed with <tt>$</tt> in 6502 assembly language (and by extension, in this book) are in hexadecimal (hex) format. If you're not familiar with hex numbers, I recommend you read <a href=\"http://en.wikipedia.org/wiki/Hexadecimal\">the Wikipedia article</a>. Anything prefixed with <tt>#</tt> is a literal number value. Any other number refers to a memory location.",
  "Equipped with that knowledge, you should be able to see that the instruction <tt>LDA #$01</tt> loads the hex value <tt>$01</tt> into register <tt>A</tt>. I'll go into more detail on registers in the next section.": "Equipped with that knowledge, you should be able to see that the instruction <tt>LDA #$01</tt> loads the hex value <tt>$01</tt> into register <tt>A</tt>. I'll go into more detail on registers in the next section.",
  "Press <b>Step</b> again to execute the second instruction. The top-left pixel of the game console should now be white. This simulator uses the memory locations <tt>$0200</tt> to <tt>$05ff</tt> to draw pixels on its display. The values <tt>$00</tt> to <tt>$0f</tt> represent 16 different colours (<tt>$00</tt> is black and <tt>$01</tt> is white), so storing the value <tt>$01</tt> at memory location <tt>$0200</tt> draws a white pixel at the top left corner. This is simpler than how an actual computer would output video, but it'll do for now.": "Press <b>Step</b> again to execute the second instruction. The top-left pixel of the game console should now be white. This simulator uses the memory locations <tt>$0200</tt> to <tt>$05ff</tt> to draw pixels on its display. The values <tt>$00</tt> to <tt>$0f</tt> represent 16 different colours (<tt>$00</tt> is black and <tt>$01</tt> is white), so storing the value <tt>$01</tt> at memory location <tt>$0200</tt> draws a white pixel at the top left corner. This is simpler than how an actual computer would output video, but it'll do for now.",
  "So, the instruction <tt>STA $0200</tt> stores the value of the <tt>A</tt> register to memory location <tt>$0200</tt>. Click <b>Step</b> four more times to execute the rest of the instructions, keeping an eye on the <tt>A</tt> register as it changes.": "So, the instruction <tt>STA $0200</tt> stores the value of the <tt>A</tt> register to memory location <tt>$0200</tt>. Click <b>Step</b> four more times to execute the rest of the instructions, keeping an eye on the <tt>A</tt> register as it changes.",
  "Exercises": "Exercises",
  "1.": "1.",
  "Try changing the colour of the three pixels.": "Try changing the colour of the three pixels.",
  "2.": "2.",
  "Change one of the pixels to draw at the bottom-right corner (memory location <tt>$05ff</tt>).": "Change one of the pixels to draw at the bottom-right corner (memory location <tt>$05ff</tt>).",
  "3.": "3.",
  "Add more instructions to draw extra pixels.": "Add more instructions to draw extra pixels.",
  "Registers and flags": "Registers and flags",
  "We've already had a little look at the processor status section (the bit with <tt>A</tt>, <tt>PC</tt> etc.), but what does it all mean?": "We've already had a little look at the processor status section (the bit with <tt>A</tt>, <tt>PC</tt> etc.), but what does it all mean?",
  "The first line shows the <tt>A</tt>, <tt>X</tt> and <tt>Y</tt> registers (<tt>A</tt> is often called the \"accumulator\"). Each register holds a single byte. Most operations work on the contents of these registers.": "The first line shows the <tt>A</tt>, <tt>X</tt> and <tt>Y</tt> registers (<tt>A</tt> is often called the \"accumulator\"). Each register holds a single byte. Most operations work on the contents of these registers.",
  "<tt>SP</tt> is the stack pointer. I won't get into the stack yet, but basically this register is decremented every time a byte is pushed onto the stack, and incremented when a byte is popped off the stack.": "<tt>SP</tt> is the stack pointer. I won't get into the stack yet, but basically this register is decremented every time a byte is pushed onto the stack, and incremented when a byte is popped off the stack.",
  "<tt>PC</tt> is the program counter - it's how the processor knows at what point in the program it currently is. It's like the current line number of an executing script. In the JavaScript simulator the code is assembled starting at memory location <tt>$0600</tt>, so <tt>PC</tt> always starts there.": "<tt>PC</tt> is the program counter - it's how the processor knows at what point in the program it currently is. It's like the current line number of an executing script. In the JavaScript simulator the code is assembled starting at memory location <tt>$0600</tt>, so <tt>PC</tt> always starts there.",
  "The last section shows the processor flags. Each flag is one bit, so all seven flags live in a single byte. The flags are set by the processor to give information about the previous instruction. More on that later. <a href=\"https://web.archive.org/web/20210626024532/http://www.obelisk.me.uk/6502/registers.html\">Read more about the registers and flags here</a>.": "The last section shows the processor flags. Each flag is one bit, so all seven flags live in a single byte. The flags are set by the processor to give information about the previous instruction. More on that later. <a href=\"https://web.archive.org/web/20210626024532/http://www.obelisk.me.uk/6502/registers.html\">Read more about the registers and flags here</a>.",
  "Instructions": "Instructions",
  "Instructions in assembly language are like a small set of predefined functions. All instructions take zero or one arguments. Here's some annotated source code to introduce a few different instructions:": "Instructions in assembly language are like a small set of predefined functions. All instructions take zero or one arguments. Here's some annotated source code to introduce a few different instructions:",
  "Assemble the code, then turn on the debugger and step through the code, watching the <tt>A</tt> and <tt>X</tt> registers. Something slightly odd happens on the line <tt>ADC #$c4</tt>. You might expect that adding <tt>$c4</tt> to <tt>$c0</tt> would give <tt>$184</tt>, but this processor gives the result as <tt>$84</tt>. What's up with that?": "Assemble the code, then turn on the debugger and step through the code, watching the <tt>A</tt> and <tt>X</tt> registers. Something slightly odd happens on the line <tt>ADC #$c4</tt>. You might expect that adding <tt>$c4</tt> to <tt>$c0</tt> would give <tt>$184</tt>, but this processor gives the result as <tt>$84</tt>. What's up with that?",
  "The problem is, <tt>$184</tt> is too big to fit in a single byte (the max is <tt>$FF</tt>), and the registers can only hold a single byte. It's OK though; the processor isn't actually dumb. If you were looking carefully enough, you'll have noticed that the carry flag was set to <tt>1</tt> after this operation. So that's how you know.": "The problem is, <tt>$184</tt> is too big to fit in a single byte (the max is <tt>$FF</tt>), and the registers can only hold a single byte. It's OK though; the processor isn't actually dumb. If you were looking carefully enough, you'll have noticed that the carry flag was set to <tt>1</tt> after this operation. So that's how you know.",
  "In the simulator below <b>type</b> (don't paste) the following code:": "In the simulator below <b>type</b> (don't paste) the following code:",
  "An important thing to notice here is the distinction between <tt>ADC #$01</tt> and <tt>ADC $01</tt>. The first one adds the value <tt>$01</tt> to the <tt>A</tt> register, but the second adds the value stored at memory location <tt>$01</tt> to the <tt>A</tt> register.": "An important thing to notice here is the distinction between <tt>ADC #$01</tt> and <tt>ADC $01</tt>. The first one adds the value <tt>$01</tt> to the <tt>A</tt> register, but the second adds the value stored at memory location <tt>$01</tt> to the <tt>A</tt> register.",
  "Assemble the code and select <b>Step</b> from the Run button's dropdown menu to step through these three instructions. The monitor in the debugger shows a section of memory, and can be helpful to visualise the execution of programs. <tt>STA $01</tt> stores the value of the <tt>A</tt> register at memory location <tt>$01</tt>, and <tt>ADC $01</tt> adds the value stored at the memory location <tt>$01</tt> to the <tt>A</tt> register. <tt>$80 + $80</tt> should equal <tt>$100</tt>, but because this is bigger than a byte, the <tt>A</tt> register is set to <tt>$00</tt> and the carry flag is set. As well as this though, the zero flag is set. The zero flag is set by all instructions where the result is zero.": "Assemble the code and select <b>Step</b> from the Run button's dropdown menu to step through these three instructions. The monitor in the debugger shows a section of memory, and can be helpful to visualise the execution of programs. <tt>STA $01</tt> stores the value of the <tt>A</tt> register at memory location <tt>$01</tt>, and <tt>ADC $01</tt> adds the value stored at the memory location <tt>$01</tt> to the <tt>A</tt> register. <tt>$80 + $80</tt> should equal <tt>$100</tt>, but because this is bigger than a byte, the <tt>A</tt> register is set to <tt>$00</tt> and the carry flag is set. As well as this though, the zero flag is set. The zero flag is set by all instructions where the result is zero.",
  "A full list of the 6502 instruction set is <a href=\"http://www.6502.org/tutorials/6502opcodes.html\">available here</a> and <a href=\"http://www.obelisk.me.uk/6502/reference.html\">here</a> (I usually refer to both pages as they have their strengths and weaknesses). These pages detail the arguments to each instruction, which registers they use, and which flags they set. They are your bible.": "A full list of the 6502 instruction set is <a href=\"http://www.6502.org/tutorials/6502opcodes.html\">available here</a> and <a href=\"http://www.obelisk.me.uk/6502/reference.html\">here</a> (I usually refer to both pages as they have their strengths and weaknesses). These pages detail the arguments to each instruction, which registers they use, and which flags they set. They are your bible.",
  "You've seen <tt>TAX</tt>. You can probably guess what <tt>TAY</tt>, <tt>TXA</tt> and <tt>TYA</tt> do, but write some code to test your assumptions.": "You've seen <tt>TAX</tt>. You can probably guess what <tt>TAY</tt>, <tt>TXA</tt> and <tt>TYA</tt> do, but write some code to test your assumptions.",
  "Rewrite the first example in this section to use the <tt>Y</tt> register instead of the <tt>X</tt> register.": "Rewrite the first example in this section to use the <tt>Y</tt> register instead of the <tt>X</tt> register.",
  "The opposite of <tt>ADC</tt> is <tt>SBC</tt> (subtract with carry). Write a program that uses this instruction.": "The opposite of <tt>ADC</tt> is <tt>SBC</tt> (subtract with carry). Write a program that uses this instruction.",
  "Branching": "Branching",
  "So far we're only able to write basic programs without any branching logic. Let's change that.": "So far we're only able to write basic programs without any branching logic. Let's change that.",
  "6502 assembly language has a bunch of branching instructions, all of which branch based on whether certain flags are set or not. In this example we'll be looking at <tt>BNE</tt>: \"Branch on not equal\".": "6502 assembly language has a bunch of branching instructions, all of which branch based on whether certain flags are set or not. In this example we'll be looking at <tt>BNE</tt>: \"Branch on not equal\".",
  "First we load the value <tt>$08</tt> into the <tt>X</tt> register. The next line is a label. Labels just mark certain points in a program so we can return to them later. After the label we decrement <tt>X</tt>, store it to <tt>$0200</tt> (the top-left pixel), and then compare it to the value <tt>$03</tt>. <a href=\"http://www.obelisk.me.uk/6502/reference.html#CPX\"><tt>CPX</tt></a> compares the value in the <tt>X</tt> register with another value. If the two values are equal, the <tt>Z</tt> flag is set to <tt>1</tt>, otherwise it is set to <tt>0</tt>.": "First we load the value <tt>$08</tt> into the <tt>X</tt> register. The next line is a label. Labels just mark certain points in a program so we can return to them later. After the label we decrement <tt>X</tt>, store it to <tt>$0200</tt> (the top-left pixel), and then compare it to the value <tt>$03</tt>. <a href=\"http://www.obelisk.me.uk/6502/reference.html#CPX\"><tt>CPX</tt></a> compares the value in the <tt>X</tt> register with another value. If the two values are equal, the <tt>Z</tt> flag is set to <tt>1</tt>, otherwise it is set to <tt>0</tt>.",
  "The next line, <tt>BNE decrement</tt>, will shift execution to the decrement label if the <tt>Z</tt> flag is set to <tt>0</tt> (meaning that the two values in the <tt>CPX</tt> comparison were not equal), otherwise it does nothing and we store <tt>X</tt> to <tt>$0201</tt>, then finish the program.": "The next line, <tt>BNE decrement</tt>, will shift execution to the decrement label if the <tt>Z</tt> flag is set to <tt>0</tt> (meaning that the two values in the <tt>CPX</tt> comparison were not equal), otherwise it does nothing and we store <tt>X</tt> to <tt>$0201</tt>, then finish the program.",
  "In assembly language, you'll usually use labels with branch instructions. When assembled though, this label is converted to a single-byte relative offset (a number of bytes to go backwards or forwards from the next instruction) so branch instructions can only go forward and back around 256 bytes. This means they can only be used to move around local code. For moving further you'll need to use the jumping instructions.": "In assembly language, you'll usually use labels with branch instructions. When assembled though, this label is converted to a single-byte relative offset (a number of bytes to go backwards or forwards from the next instruction) so branch instructions can only go forward and back around 256 bytes. This means they can only be used to move around local code. For moving further you'll need to use the jumping instructions.",
  "The opposite of <tt>BNE</tt> is <tt>BEQ</tt>. Try writing a program that uses <tt>BEQ</tt>.": "The opposite of <tt>BNE</tt> is <tt>BEQ</tt>. Try writing a program that uses <tt>BEQ</tt>.",
  "<tt>BCC</tt> and <tt>BCS</tt> (\"branch on carry clear\" and \"branch on carry set\") are used to branch on the carry flag. Write a program that uses one of these two.": "<tt>BCC</tt> and <tt>BCS</tt> (\"branch on carry clear\" and \"branch on carry set\") are used to branch on the carry flag. Write a program that uses one of these two.",
  "Addressing modes": "Addressing modes",
  "The 6502 uses a 16-bit address bus, meaning that there are 65536 bytes of memory available to the processor. Remember that a byte is represented by two hex characters, so the memory locations are generally represented as <tt>$0000 - $ffff</tt>. There are various ways to refer to these memory locations, as detailed below.": "The 6502 uses a 16-bit address bus, meaning that there are 65536 bytes of memory available to the processor. Remember that a byte is represented by two hex characters, so the memory locations are generally represented as <tt>$0000 - $ffff</tt>. There are various ways to refer to these memory locations, as detailed below.",
  "With all these examples you might find it helpful to use the memory monitor in the debugger to watch the memory change. The monitor takes a starting memory location and a number of bytes to display from that location. Both of these are hex values. For example, to display 16 bytes of memory from <tt>$c000</tt>, enter <tt>c000</tt> and <tt>10</tt> into <b>Start</b> and <b>Length</b>, respectively.": "With all these examples you might find it helpful to use the memory monitor in the debugger to watch the memory change. The monitor takes a starting memory location and a number of bytes to display from that location. Both of these are hex values. For example, to display 16 bytes of memory from <tt>$c000</tt>, enter <tt>c000</tt> and <tt>10</tt> into <b>Start</b> and <b>Length</b>, respectively.",
  "Absolute: <tt>$c000</tt>": "Absolute: <tt>$c000</tt>",
  "With absolute addressing, the full memory location is used as the argument to the instruction. For example:": "With absolute addressing, the full memory location is used as the argument to the instruction. For example:",
  "Zero page: <tt>$c0</tt>": "Zero page: <tt>$c0</tt>",
  "All instructions that support absolute addressing (with the exception of the jump instructions) also have the option to take a single-byte address. This type of addressing is called \"zero page\" - only the first page (the first 256 bytes) of memory is accessible. This is faster, as only one byte needs to be looked up, and takes up less space in the assembled code as well.": "All instructions that support absolute addressing (with the exception of the jump instructions) also have the option to take a single-byte address. This type of addressing is called \"zero page\" - only the first page (the first 256 bytes) of memory is accessible. This is faster, as only one byte needs to be looked up, and takes up less space in the assembled code as well.",
  "Zero page,X: <tt>$c0,X</tt>": "Zero page,X: <tt>$c0,X</tt>",
  "This is where addressing gets interesting. In this mode, a zero page address is given, and then the value of the <tt>X</tt> register is added. Here is an example:": "This is where addressing gets interesting. In this mode, a zero page address is given, and then the value of the <tt>X</tt> register is added. Here is an example:",
  "If the result of the addition is larger than a single byte, the address wraps around. For example:": "If the result of the addition is larger than a single byte, the address wraps around. For example:",
  "Zero page,Y: <tt>$c0,Y</tt>": "Zero page,Y: <tt>$c0,Y</tt>",
  "This is the equivalent of zero page,X, but can only be used with <tt>LDX</tt> and <tt>STX</tt>.": "This is the equivalent of zero page,X, but can only be used with <tt>LDX</tt> and <tt>STX</tt>.",
  "Absolute,X and absolute,Y: <tt>$c000,X</tt> and <tt>$c000,Y</tt>": "Absolute,X and absolute,Y: <tt>$c000,X</tt> and <tt>$c000,Y</tt>",
  "These are the absolute addressing versions of zero page,X and zero page,Y. For example:": "These are the absolute addressing versions of zero page,X and zero page,Y. For example:",
  "Unlike zero page,Y, absolute,Y can't be used with <tt>STX</tt> but can be used with <tt>LDA</tt> and <tt>STA</tt>.": "Unlike zero page,Y, absolute,Y can't be used with <tt>STX</tt> but can be used with <tt>LDA</tt> and <tt>STA</tt>.",
  "Immediate: <tt>#$c0</tt>": "Immediate: <tt>#$c0</tt>",
  "Immediate addressing doesn't strictly deal with memory addresses - this is the mode where actual values are used. For example, <tt>LDX #$01</tt> loads the value <tt>$01</tt> into the <tt>X</tt> register. This is very different to the zero page instruction <tt>LDX $01</tt> which loads the value at memory location <tt>$01</tt> into the <tt>X</tt> register.": "Immediate addressing doesn't strictly deal with memory addresses - this is the mode where actual values are used. For example, <tt>LDX #$01</tt> loads the value <tt>$01</tt> into the <tt>X</tt> register. This is very different to the zero page instruction <tt>LDX $01</tt> which loads the value at memory location <tt>$01</tt> into the <tt>X</tt> register.",
  "Relative: <tt>$c0</tt> (or label)": "Relative: <tt>$c0</tt> (or label)",
  "Relative addressing is used for branching instructions. These instructions take a single byte, which is used as an offset from the following instruction.": "Relative addressing is used for branching instructions. These instructions take a single byte, which is used as an offset from the following instruction.",
  "Assemble the following code, then check the debugger to see the hexdump of the assembled code.": "Assemble the following code, then check the debugger to see the hexdump of the assembled code.",
  "The hex should look something like this:": "The hex should look something like this:",
  "<tt>a9</tt> and <tt>c9</tt> are the processor opcodes for immediate-addressed <tt>LDA</tt> and <tt>CMP</tt> respectively. <tt>01</tt> and <tt>02</tt> are the arguments to these instructions. <tt>d0</tt> is the opcode for <tt>BNE</tt>, and its argument is <tt>02</tt>. This means \"skip over the next two bytes\" (<tt>85 22</tt>, the assembled version of <tt>STA $22</tt>). Try editing the code so <tt>STA</tt> takes a two-byte absolute address rather than a single-byte zero page address (e.g. change <tt>STA $22</tt> to <tt>STA $2222</tt>). Reassemble the code and look at the hexdump again - the argument to <tt>BNE</tt> should now be <tt>03</tt>, because the instruction the processor is skipping past is now three bytes long.": "<tt>a9</tt> and <tt>c9</tt> are the processor opcodes for immediate-addressed <tt>LDA</tt> and <tt>CMP</tt> respectively. <tt>01</tt> and <tt>02</tt> are the arguments to these instructions. <tt>d0</tt> is the opcode for <tt>BNE</tt>, and its argument is <tt>02</tt>. This means \"skip over the next two bytes\" (<tt>85 22</tt>, the assembled version of <tt>STA $22</tt>). Try editing the code so <tt>STA</tt> takes a two-byte absolute address rather than a single-byte zero page address (e.g. change <tt>STA $22</tt> to <tt>STA $2222</tt>). Reassemble the code and look at the hexdump again - the argument to <tt>BNE</tt> should now be <tt>03</tt>, because the instruction the processor is skipping past is now three bytes long.",
  "Implicit": "Implicit",
  "Some instructions don't deal with memory locations (e.g. <tt>INX</tt> - increment the <tt>X</tt> register). These are said to have implicit addressing - the argument is implied by the instruction.": "Some instructions don't deal with memory locations (e.g. <tt>INX</tt> - increment the <tt>X</tt> register). These are said to have implicit addressing - the argument is implied by the instruction.",
  "Indirect: <tt>($c000)</tt>": "Indirect: <tt>($c000)</tt>",
  "Indirect addressing uses an absolute address to look up another address. The first address gives the least significant byte of the address, and the following byte gives the most significant byte. That can be hard to wrap your head around, so here's an example:": "Indirect addressing uses an absolute address to look up another address. The first address gives the least significant byte of the address, and the following byte gives the most significant byte. That can be hard to wrap your head around, so here's an example:",
  "In this example, <tt>$f0</tt> contains the value <tt>$01</tt> and <tt>$f1</tt> contains the value <tt>$cc</tt>. The instruction <tt>JMP ($f0)</tt> causes the processor to look up the two bytes at <tt>$f0</tt> and <tt>$f1</tt> (<tt>$01</tt> and <tt>$cc</tt>) and put them together to form the address <tt>$cc01</tt>, which becomes the new program counter. Assemble and step through the program above to see what happens. I'll talk more about <tt>JMP</tt> in the section on <a href=\"#jumping\">Jumping</a>.": "In this example, <tt>$f0</tt> contains the value <tt>$01</tt> and <tt>$f1</tt> contains the value <tt>$cc</tt>. The instruction <tt>JMP ($f0)</tt> causes the processor to look up the two bytes at <tt>$f0</tt> and <tt>$f1</tt> (<tt>$01</tt> and <tt>$cc</tt>) and put them together to form the address <tt>$cc01</tt>, which becomes the new program counter. Assemble and step through the program above to see what happens. I'll talk more about <tt>JMP</tt> in the section on <a href=\"#jumping\">Jumping</a>.",
  "Indexed indirect: <tt>($c0,X)</tt>": "Indexed indirect: <tt>($c0,X)</tt>",
  "This one's kinda weird. It's like a cross between zero page,X and indirect. Basically, you take the zero page address, add the value of the <tt>X</tt> register to it, then use that to look up a two-byte address. For example:": "This one's kinda weird. It's like a cross between zero page,X and indirect. Basically, you take the zero page address, add the value of the <tt>X</tt> register to it, then use that to look up a two-byte address. For example:",
  "Memory locations <tt>$01</tt> and <tt>$02</tt> contain the values <tt>$05</tt> and <tt>$07</tt> respectively. Think of <tt>($00,X)</tt> as <tt>($00 + X)</tt>. In this case <tt>X</tt> is <tt>$01</tt>, so this simplifies to <tt>($01)</tt>. From here things proceed like standard indirect addressing - the two bytes at <tt>$01</tt> and <tt>$02</tt> (<tt>$05</tt> and <tt>$07</tt>) are looked up to form the address <tt>$0705</tt>. This is the address that the <tt>Y</tt> register was stored into in the previous instruction, so the <tt>A</tt> register gets the same value as <tt>Y</tt>, albeit through a much more circuitous route. You won't see this much.": "Memory locations <tt>$01</tt> and <tt>$02</tt> contain the values <tt>$05</tt> and <tt>$07</tt> respectively. Think of <tt>($00,X)</tt> as <tt>($00 + X)</tt>. In this case <tt>X</tt> is <tt>$01</tt>, so this simplifies to <tt>($01)</tt>. From here things proceed like standard indirect addressing - the two bytes at <tt>$01</tt> and <tt>$02</tt> (<tt>$05</tt> and <tt>$07</tt>) are looked up to form the address <tt>$0705</tt>. This is the address that the <tt>Y</tt> register was stored into in the previous instruction, so the <tt>A</tt> register gets the same value as <tt>Y</tt>, albeit through a much more circuitous route. You won't see this much.",
  "Indirect indexed: <tt>($c0),Y</tt>": "Indirect indexed: <tt>($c0),Y</tt>",
  "Indirect indexed is like indexed indirect but less insane. Instead of adding the <tt>X</tt> register to the address <i>before</i> dereferencing, the zero page address is dereferenced, and the <tt>Y</tt> register is added to the resulting address.": "Indirect indexed is like indexed indirect but less insane. Instead of adding the <tt>X</tt> register to the address <i>before</i> dereferencing, the zero page address is dereferenced, and the <tt>Y</tt> register is added to the resulting address.",
  "In this case, <tt>($01)</tt> looks up the two bytes at <tt>$01</tt> and <tt>$02</tt>: <tt>$03</tt> and <tt>$07</tt>. These form the address <tt>$0703</tt>. The value of the <tt>Y</tt> register is added to this address to give the final address <tt>$0704</tt>.": "In this case, <tt>($01)</tt> looks up the two bytes at <tt>$01</tt> and <tt>$02</tt>: <tt>$03</tt> and <tt>$07</tt>. These form the address <tt>$0703</tt>. The value of the <tt>Y</tt> register is added to this address to give the final address <tt>$0704</tt>.",
  "Exercise": "Exercise",
  "Try to write code snippets that use each of the 6502 addressing modes. Remember, you can use the monitor in the debugger to watch a section of memory.": "Try to write code snippets that use each of the 6502 addressing modes. Remember, you can use the monitor in the debugger to watch a section of memory.",
  "The stack": "The stack",
  "The stack in a 6502 processor is just like any other stack - values are pushed onto it and popped (\"pulled\" in 6502 parlance) off it. The current depth of the stack is measured by the stack pointer, a special register. The stack lives in memory between <tt>$0100</tt> and <tt>$01ff</tt>. The stack pointer is initially <tt>$ff</tt>, which points to memory location <tt>$01ff</tt>. When a byte is pushed onto the stack, the stack pointer becomes <tt>$fe</tt>, or memory location <tt>$01fe</tt>, and so on.": "The stack in a 6502 processor is just like any other stack - values are pushed onto it and popped (\"pulled\" in 6502 parlance) off it. The current depth of the stack is measured by the stack pointer, a special register. The stack lives in memory between <tt>$0100</tt> and <tt>$01ff</tt>. The stack pointer is initially <tt>$ff</tt>, which points to memory location <tt>$01ff</tt>. When a byte is pushed onto the stack, the stack pointer becomes <tt>$fe</tt>, or memory location <tt>$01fe</tt>, and so on.",
  "Two of the stack instructions are <tt>PHA</tt> and <tt>PLA</tt>, \"push accumulator\" and \"pull accumulator\". Below is an example of these two in action.": "Two of the stack instructions are <tt>PHA</tt> and <tt>PLA</tt>, \"push accumulator\" and \"pull accumulator\". Below is an example of these two in action.",
  "<tt>X</tt> holds the pixel colour, and <tt>Y</tt> holds the position of the current pixel. The first loop draws the current colour as a pixel (via the <tt>A</tt> register), pushes the colour to the stack, then increments the colour and position. The second loop pops the stack, draws the popped colour as a pixel, then increments the position. As should be expected, this creates a mirrored pattern.": "<tt>X</tt> holds the pixel colour, and <tt>Y</tt> holds the position of the current pixel. The first loop draws the current colour as a pixel (via the <tt>A</tt> register), pushes the colour to the stack, then increments the colour and position. The second loop pops the stack, draws the popped colour as a pixel, then increments the position. As should be expected, this creates a mirrored pattern.",
  "Jumping": "Jumping",
  "Jumping is like branching with two main differences. First, jumps are not conditionally executed, and second, they take a two-byte absolute address. For small programs, this second detail isn't very important, as you'll mostly be using labels, and the assembler works out the correct memory location from the label. For larger programs though, jumping is the only way to move from one section of the code to another.": "Jumping is like branching with two main differences. First, jumps are not conditionally executed, and second, they take a two-byte absolute address. For small programs, this second detail isn't very important, as you'll mostly be using labels, and the assembler works out the correct memory location from the label. For larger programs though, jumping is the only way to move from one section of the code to another.",
  "JMP": "JMP",
  "<tt>JMP</tt> is an unconditional jump. Here's a really simple example to show it in action:": "<tt>JMP</tt> is an unconditional jump. Here's a really simple example to show it in action:",
  "JSR/RTS": "JSR/RTS",
  "<tt>JSR</tt> and <tt>RTS</tt> (\"jump to subroutine\" and \"return from subroutine\") are a dynamic duo that you'll usually see used together. <tt>JSR</tt> is used to jump from the current location to another part of the code. <tt>RTS</tt> returns to the previous position. This is basically like calling a function and returning.": "<tt>JSR</tt> and <tt>RTS</tt> (\"jump to subroutine\" and \"return from subroutine\") are a dynamic duo that you'll usually see used together. <tt>JSR</tt> is used to jump from the current location to another part of the code. <tt>RTS</tt> returns to the previous position. This is basically like calling a function and returning.",
  "The processor knows where to return to because <tt>JSR</tt> pushes the address minus one of the next instruction onto the stack before jumping to the given location. <tt>RTS</tt> pops this location, adds one to it, and jumps to that location. An example:": "The processor knows where to return to because <tt>JSR</tt> pushes the address minus one of the next instruction onto the stack before jumping to the given location. <tt>RTS</tt> pops this location, adds one to it, and jumps to that location. An example:",
  "The first instruction causes execution to jump to the <tt>init</tt> label. This sets <tt>X</tt>, then returns to the next instruction, <tt>JSR loop</tt>. This jumps to the <tt>loop</tt> label, which increments <tt>X</tt> until it is equal to <tt>$05</tt>. After that we return to the next instruction, <tt>JSR end</tt>, which jumps to the end of the file. This illustrates how <tt>JSR</tt> and <tt>RTS</tt> can be used together to create modular code.": "The first instruction causes execution to jump to the <tt>init</tt> label. This sets <tt>X</tt>, then returns to the next instruction, <tt>JSR loop</tt>. This jumps to the <tt>loop</tt> label, which increments <tt>X</tt> until it is equal to <tt>$05</tt>. After that we return to the next instruction, <tt>JSR end</tt>, which jumps to the end of the file. This illustrates how <tt>JSR</tt> and <tt>RTS</tt> can be used together to create modular code.",
  "Creating a game": "Creating a game",
  "Now, let's put all this knowledge to good use, and make a game! We're going to be making a really simple version of the classic game 'Snake'.": "Now, let's put all this knowledge to good use, and make a game! We're going to be making a really simple version of the classic game 'Snake'.",
  "Even though this will be a simple version, the code will be substantially larger than all the previous examples. We will need to keep track of several memory locations together for the various aspects of the game. We can still do the necessary bookkeeping throughout the program ourselves, as before, but on a larger scale that quickly becomes tedious and can also lead to bugs that are difficult to spot. Instead we'll now let the assembler do some of the mundane work for us.": "Even though this will be a simple version, the code will be substantially larger than all the previous examples. We will need to keep track of several memory locations together for the various aspects of the game. We can still do the necessary bookkeeping throughout the program ourselves, as before, but on a larger scale that quickly becomes tedious and can also lead to bugs that are difficult to spot. Instead we'll now let the assembler do some of the mundane work for us.",
  "In this assembler, we can define descriptive constants (or symbols) that represent numbers. The rest of the code can then simply use the constants instead of the literal number, which immediately makes it obvious what we're dealing with. You can use letters, digits and underscores in a name.": "In this assembler, we can define descriptive constants (or symbols) that represent numbers. The rest of the code can then simply use the constants instead of the literal number, which immediately makes it obvious what we're dealing with. You can use letters, digits and underscores in a name.",
  "Here's an example. Note that immediate operands are still prefixed with a <tt>#</tt>.": "Here's an example. Note that immediate operands are still prefixed with a <tt>#</tt>.",
  "The code block below contains the entire source code of the game. I'll explain how it works in the following sections.": "The code block below contains the entire source code of the game. I'll explain how it works in the following sections.",
  "<a href=\"https://twitter.com/wkjagt\">Willem van der Jagt</a> made a <a href=\"https://gist.github.com/wkjagt/9043907\">fully annotated gist of this source code</a>, so follow along with that for more details.": "<a href=\"https://twitter.com/wkjagt\">Willem van der Jagt</a> made a <a href=\"https://gist.github.com/wkjagt/9043907\">fully annotated gist of this source code</a>, so follow along with that for more details.",
  "Overall structure": "Overall structure",
  "After the initial block of comments (lines starting with semicolons), the first two lines are:": "After the initial block of comments (lines starting with semicolons), the first two lines are:",
  "<tt>init</tt> and <tt>loop</tt> are both subroutines. <tt>init</tt> initializes the game state, and <tt>loop</tt> is the main game loop.": "<tt>init</tt> and <tt>loop</tt> are both subroutines. <tt>init</tt> initializes the game state, and <tt>loop</tt> is the main game loop.",
  "The <tt>loop</tt> subroutine itself just calls a number of subroutines sequentially, before looping back on itself:": "The <tt>loop</tt> subroutine itself just calls a number of subroutines sequentially, before looping back on itself:",
  "First, <tt>readkeys</tt> checks to see if one of the direction keys (W, A, S, D) was pressed, and if so, sets the direction of the snake accordingly. Then, <tt>checkCollision</tt> checks to see if the snake collided with itself or the apple. <tt>updateSnake</tt> updates the internal representation of the snake, based on its direction. Next, the apple and snake are drawn. Finally, <tt>spinWheels</tt> makes the processor do some busy work, to stop the game from running too quickly. Think of it like a sleep command. The game keeps running until the snake collides with the wall or itself.": "First, <tt>readkeys</tt> checks to see if one of the direction keys (W, A, S, D) was pressed, and if so, sets the direction of the snake accordingly. Then, <tt>checkCollision</tt> checks to see if the snake collided with itself or the apple. <tt>updateSnake</tt> updates the internal representation of the snake, based on its direction. Next, the apple and snake are drawn. Finally, <tt>spinWheels</tt> makes the processor do some busy work, to stop the game from running too quickly. Think of it like a sleep command. The game keeps running until the snake collides with the wall or itself.",
  "Zero page usage": "Zero page usage",
  "The zero page of memory is used to store a number of game state variables, as noted in the comment block at the top of the game. Everything in <tt>$00</tt>, <tt>$01</tt> and <tt>$10</tt> upwards is a pair of bytes representing a two-byte memory location that will be looked up using indirect addressing. These memory locations will all be between <tt>$0200</tt> and <tt>$05ff</tt> - the section of memory corresponding to the game console. For example, if <tt>$00</tt> and <tt>$01</tt> contained the values <tt>$01</tt> and <tt>$02</tt>, they would be referring to the second pixel of the display ( <tt>$0201</tt> - remember, the least significant byte comes first in indirect addressing).": "The zero page of memory is used to store a number of game state variables, as noted in the comment block at the top of the game. Everything in <tt>$00</tt>, <tt>$01</tt> and <tt>$10</tt> upwards is a pair of bytes representing a two-byte memory location that will be looked up using indirect addressing. These memory locations will all be between <tt>$0200</tt> and <tt>$05ff</tt> - the section of memory corresponding to the game console. For example, if <tt>$00</tt> and <tt>$01</tt> contained the values <tt>$01</tt> and <tt>$02</tt>, they would be referring to the second pixel of the display ( <tt>$0201</tt> - remember, the least significant byte comes first in indirect addressing).",
  "The first two bytes hold the location of the apple. This is updated every time the snake eats the apple. Byte <tt>$02</tt> contains the current direction. <tt>1</tt> means up, <tt>2</tt> right, <tt>4</tt> down, and <tt>8</tt> left. The reasoning behind these numbers will become clear later.": "The first two bytes hold the location of the apple. This is updated every time the snake eats the apple. Byte <tt>$02</tt> contains the current direction. <tt>1</tt> means up, <tt>2</tt> right, <tt>4</tt> down, and <tt>8</tt> left. The reasoning behind these numbers will become clear later.",
  "Finally, byte <tt>$03</tt> contains the current length of the snake, in terms of bytes in memory (so a length of 4 means 2 pixels).": "Finally, byte <tt>$03</tt> contains the current length of the snake, in terms of bytes in memory (so a length of 4 means 2 pixels).",
  "Initialization": "Initialization",
  "The <tt>init</tt> subroutine defers to two subroutines, <tt>initSnake</tt> and <tt>generateApplePosition</tt>. <tt>initSnake</tt> sets the snake direction, length, and then loads the initial memory locations of the snake head and body. The byte pair at <tt>$10</tt> contains the screen location of the head, the pair at <tt>$12</tt> contains the location of the single body segment, and <tt>$14</tt> contains the location of the tail (the tail is the last segment of the body and is drawn in black to keep the snake moving). This happens in the following code:": "The <tt>init</tt> subroutine defers to two subroutines, <tt>initSnake</tt> and <tt>generateApplePosition</tt>. <tt>initSnake</tt> sets the snake direction, length, and then loads the initial memory locations of the snake head and body. The byte pair at <tt>$10</tt> contains the screen location of the head, the pair at <tt>$12</tt> contains the location of the single body segment, and <tt>$14</tt> contains the location of the tail (the tail is the last segment of the body and is drawn in black to keep the snake moving). This happens in the following code:",
  "This loads the value <tt>$11</tt> into the memory location <tt>$10</tt>, the value <tt>$10</tt> into <tt>$12</tt>, and <tt>$0f</tt> into <tt>$14</tt>. It then loads the value <tt>$04</tt> into <tt>$11</tt>, <tt>$13</tt> and <tt>$15</tt>. This leads to memory like this:": "This loads the value <tt>$11</tt> into the memory location <tt>$10</tt>, the value <tt>$10</tt> into <tt>$12</tt>, and <tt>$0f</tt> into <tt>$14</tt>. It then loads the value <tt>$04</tt> into <tt>$11</tt>, <tt>$13</tt> and <tt>$15</tt>. This leads to memory like this:",
  "which represents the indirectly-addressed memory locations <tt>$0411</tt>, <tt>$0410</tt> and <tt>$040f</tt> (three pixels in the middle of the display). I'm labouring this point, but it's important to fully grok how indirect addressing works.": "which represents the indirectly-addressed memory locations <tt>$0411</tt>, <tt>$0410</tt> and <tt>$040f</tt> (three pixels in the middle of the display). I'm labouring this point, but it's important to fully grok how indirect addressing works.",
  "The next subroutine, <tt>generateApplePosition</tt>, sets the apple location to a random position on the display. First, it loads a random byte into the accumulator (<tt>$fe</tt> is a random number generator in this simulator). This is stored into <tt>$00</tt>. Next, a different random byte is loaded into the accumulator, which is then <tt>AND</tt>-ed with the value <tt>$03</tt>. This part requires a bit of a detour.": "The next subroutine, <tt>generateApplePosition</tt>, sets the apple location to a random position on the display. First, it loads a random byte into the accumulator (<tt>$fe</tt> is a random number generator in this simulator). This is stored into <tt>$00</tt>. Next, a different random byte is loaded into the accumulator, which is then <tt>AND</tt>-ed with the value <tt>$03</tt>. This part requires a bit of a detour.",
  "The hex value <tt>$03</tt> is represented in binary as <tt>00000011</tt>. The <tt>AND</tt> opcode performs a bitwise AND of the argument with the accumulator. For example, if the accumulator contains the binary value <tt>10101010</tt>, then the result of <tt>AND</tt> with <tt>00000011</tt> will be <tt>00000010</tt>.": "The hex value <tt>$03</tt> is represented in binary as <tt>00000011</tt>. The <tt>AND</tt> opcode performs a bitwise AND of the argument with the accumulator. For example, if the accumulator contains the binary value <tt>10101010</tt>, then the result of <tt>AND</tt> with <tt>00000011</tt> will be <tt>00000010</tt>.",
  "The effect of this is to mask out the least significant two bits of the accumulator, setting the others to zero. This converts a number in the range of 0–255 to a number in the range of 0–3.": "The effect of this is to mask out the least significant two bits of the accumulator, setting the others to zero. This converts a number in the range of 0–255 to a number in the range of 0–3.",
  "After this, the value <tt>2</tt> is added to the accumulator, to create a final random number in the range 2–5.": "After this, the value <tt>2</tt> is added to the accumulator, to create a final random number in the range 2–5.",
  "The result of this subroutine is to load a random byte into <tt>$00</tt>, and a random number between 2 and 5 into <tt>$01</tt>. Because the least significant byte comes first with indirect addressing, this translates into a memory address between <tt>$0200</tt> and <tt>$05ff</tt>: the exact range used to draw the display.": "The result of this subroutine is to load a random byte into <tt>$00</tt>, and a random number between 2 and 5 into <tt>$01</tt>. Because the least significant byte comes first with indirect addressing, this translates into a memory address between <tt>$0200</tt> and <tt>$05ff</tt>: the exact range used to draw the display.",
  "The game loop": "The game loop",
  "Nearly all games have at their heart a game loop. All game loops have the same basic form: accept user input, update the game state, and render the game state. This loop is no different.": "Nearly all games have at their heart a game loop. All game loops have the same basic form: accept user input, update the game state, and render the game state. This loop is no different.",
  "Reading the input": "Reading the input",
  "The first subroutine, <tt>readKeys</tt>, takes the job of accepting user input. The memory location <tt>$ff</tt> holds the ascii code of the most recent key press in this simulator. The value is loaded into the accumulator, then compared to <tt>$77</tt> (the hex code for W), <tt>$64</tt> (D), <tt>$73</tt> (S) and <tt>$61</tt> (A). If any of these comparisons are successful, the program branches to the appropriate section.": "The first subroutine, <tt>readKeys</tt>, takes the job of accepting user input. The memory location <tt>$ff</tt> holds the ascii code of the most recent key press in this simulator. The value is loaded into the accumulator, then compared to <tt>$77</tt> (the hex code for W), <tt>$64</tt> (D), <tt>$73</tt> (S) and <tt>$61</tt> (A). If any of these comparisons are successful, the program branches to the appropriate section.",
  "Additional button inputs are also available: button A (Enter/Return key, ASCII code <tt>$0D</tt>) and button B (Space key, ASCII code <tt>$20</tt>). These can be used to add more interaction to your games. For directional controls, both WASD keys and arrow keys can be used interchangeably.": "Additional button inputs are also available: button A (Enter/Return key, ASCII code <tt>$0D</tt>) and button B (Space key, ASCII code <tt>$20</tt>). These can be used to add more interaction to your games. For directional controls, both WASD keys and arrow keys can be used interchangeably.",
  "Each section (<tt>upKey</tt>, <tt>rightKey</tt>, etc.) first checks to see if the current direction is the opposite of the new direction. This requires another little detour.": "Each section (<tt>upKey</tt>, <tt>rightKey</tt>, etc.) first checks to see if the current direction is the opposite of the new direction. This requires another little detour.",
  "As stated before, the four directions are represented internally by the numbers 1, 2, 4 and 8. Each of these numbers is a power of 2, thus they are represented by a binary number with a single <tt>1</tt>:": "As stated before, the four directions are represented internally by the numbers 1, 2, 4 and 8. Each of these numbers is a power of 2, thus they are represented by a binary number with a single <tt>1</tt>:",
  "The <tt>BIT</tt> opcode is similar to <tt>AND</tt>, but the calculation is only used to set the zero flag - the actual result is discarded. The zero flag is set only if the result of AND-ing the accumulator with argument is zero. When we're looking at powers of two, the zero flag will only be set if the two numbers are not the same. For example, <tt>0001 AND 0001</tt> is not zero, but <tt>0001 AND 0010</tt> is zero.": "The <tt>BIT</tt> opcode is similar to <tt>AND</tt>, but the calculation is only used to set the zero flag - the actual result is discarded. The zero flag is set only if the result of AND-ing the accumulator with argument is zero. When we're looking at powers of two, the zero flag will only be set if the two numbers are not the same. For example, <tt>0001 AND 0001</tt> is not zero, but <tt>0001 AND 0010</tt> is zero.",
  "So, looking at <tt>upKey</tt>, if the current direction is down (4), the bit test will be zero. <tt>BNE</tt> means \"branch if the zero flag is clear\", so in this case we'll branch to <tt>illegalMove</tt>, which just returns from the subroutine. Otherwise, the new direction (1 in this case) is stored in the appropriate memory location.": "So, looking at <tt>upKey</tt>, if the current direction is down (4), the bit test will be zero. <tt>BNE</tt> means \"branch if the zero flag is clear\", so in this case we'll branch to <tt>illegalMove</tt>, which just returns from the subroutine. Otherwise, the new direction (1 in this case) is stored in the appropriate memory location.",
  "Updating the game state": "Updating the game state",
  "The next subroutine, <tt>checkCollision</tt>, defers to <tt>checkAppleCollision</tt> and <tt>checkSnakeCollision</tt>. <tt>checkAppleCollision</tt> just checks to see if the two bytes holding the location of the apple match the two bytes holding the location of the head. If they do, the length is increased and a new apple position is generated.": "The next subroutine, <tt>checkCollision</tt>, defers to <tt>checkAppleCollision</tt> and <tt>checkSnakeCollision</tt>. <tt>checkAppleCollision</tt> just checks to see if the two bytes holding the location of the apple match the two bytes holding the location of the head. If they do, the length is increased and a new apple position is generated.",
  "<tt>checkSnakeCollision</tt> loops through the snake's body segments, checking each byte pair against the head pair. If there is a match, then game over.": "<tt>checkSnakeCollision</tt> loops through the snake's body segments, checking each byte pair against the head pair. If there is a match, then game over.",
  "After collision detection, we update the snake's location. This is done at a high level like so: First, move each byte pair of the body up one position in memory. Second, update the head according to the current direction. Finally, if the head is out of bounds, handle it as a collision. I'll illustrate this with some ascii art. Each pair of brackets contains an x,y coordinate rather than a pair of bytes for simplicity.": "After collision detection, we update the snake's location. This is done at a high level like so: First, move each byte pair of the body up one position in memory. Second, update the head according to the current direction. Finally, if the head is out of bounds, handle it as a collision. I'll illustrate this with some ascii art. Each pair of brackets contains an x,y coordinate rather than a pair of bytes for simplicity.",
  "At a low level, this subroutine is slightly more complex. First, the length is loaded into the <tt>X</tt> register, which is then decremented. The snippet below shows the starting memory for the snake.": "At a low level, this subroutine is slightly more complex. First, the length is loaded into the <tt>X</tt> register, which is then decremented. The snippet below shows the starting memory for the snake.",
  "The length is initialized to <tt>4</tt>, so <tt>X</tt> starts off as <tt>3</tt>. <tt>LDA $10,x</tt> loads the value of <tt>$13</tt> into <tt>A</tt>, then <tt>STA $12,x</tt> stores this value into <tt>$15</tt>. <tt>X</tt> is decremented, and we loop. Now <tt>X</tt> is <tt>2</tt>, so we load <tt>$12</tt> and store it into <tt>$14</tt>. This loops while <tt>X</tt> is positive (<tt>BPL</tt> means \"branch if positive\").": "The length is initialized to <tt>4</tt>, so <tt>X</tt> starts off as <tt>3</tt>. <tt>LDA $10,x</tt> loads the value of <tt>$13</tt> into <tt>A</tt>, then <tt>STA $12,x</tt> stores this value into <tt>$15</tt>. <tt>X</tt> is decremented, and we loop. Now <tt>X</tt> is <tt>2</tt>, so we load <tt>$12</tt> and store it into <tt>$14</tt>. This loops while <tt>X</tt> is positive (<tt>BPL</tt> means \"branch if positive\").",
  "Once the values have been shifted down the snake, we have to work out what to do with the head. The direction is first loaded into <tt>A</tt>. <tt>LSR</tt> means \"logical shift right\", or \"shift all the bits one position to the right\". The least significant bit is shifted into the carry flag, so if the accumulator is <tt>1</tt>, after <tt>LSR</tt> it is <tt>0</tt>, with the carry flag set.": "Once the values have been shifted down the snake, we have to work out what to do with the head. The direction is first loaded into <tt>A</tt>. <tt>LSR</tt> means \"logical shift right\", or \"shift all the bits one position to the right\". The least significant bit is shifted into the carry flag, so if the accumulator is <tt>1</tt>, after <tt>LSR</tt> it is <tt>0</tt>, with the carry flag set.",
  "To test whether the direction is <tt>1</tt>, <tt>2</tt>, <tt>4</tt> or <tt>8</tt>, the code continually shifts right until the carry is set. One <tt>LSR</tt> means \"up\", two means \"right\", and so on.": "To test whether the direction is <tt>1</tt>, <tt>2</tt>, <tt>4</tt> or <tt>8</tt>, the code continually shifts right until the carry is set. One <tt>LSR</tt> means \"up\", two means \"right\", and so on.",
  "The next bit updates the head of the snake depending on the direction. This is probably the most complicated part of the code, and it's all reliant on how memory locations map to the screen, so let's look at that in more detail.": "The next bit updates the head of the snake depending on the direction. This is probably the most complicated part of the code, and it's all reliant on how memory locations map to the screen, so let's look at that in more detail.",
  "You can think of the screen as four horizontal strips of 32 × 8 pixels. These strips map to <tt>$0200-$02ff</tt>, <tt>$0300-$03ff</tt>, <tt>$0400-$04ff</tt> and <tt>$0500-$05ff</tt>. The first rows of pixels are <tt>$0200-$021f</tt>, <tt>$0220-$023f</tt>, <tt>$0240-$025f</tt>, etc.": "You can think of the screen as four horizontal strips of 32 × 8 pixels. These strips map to <tt>$0200-$02ff</tt>, <tt>$0300-$03ff</tt>, <tt>$0400-$04ff</tt> and <tt>$0500-$05ff</tt>. The first rows of pixels are <tt>$0200-$021f</tt>, <tt>$0220-$023f</tt>, <tt>$0240-$025f</tt>, etc.",
  "As long as you're moving within one of these horizontal strips, things are simple. For example, to move right, just increment the least significant byte (e.g. <tt>$0200</tt> becomes <tt>$0201</tt>). To go down, add <tt>$20</tt> (e.g. <tt>$0200</tt> becomes <tt>$0220</tt>). Left and up are the reverse.": "As long as you're moving within one of these horizontal strips, things are simple. For example, to move right, just increment the least significant byte (e.g. <tt>$0200</tt> becomes <tt>$0201</tt>). To go down, add <tt>$20</tt> (e.g. <tt>$0200</tt> becomes <tt>$0220</tt>). Left and up are the reverse.",
  "Going between sections is more complicated, as we have to take into account the most significant byte as well. For example, going down from <tt>$02e1</tt> should lead to <tt>$0301</tt>. Luckily, this is fairly easy to accomplish. Adding <tt>$20</tt> to <tt>$e1</tt> results in <tt>$01</tt> and sets the carry bit. If the carry bit was set, we know we also need to increment the most significant byte.": "Going between sections is more complicated, as we have to take into account the most significant byte as well. For example, going down from <tt>$02e1</tt> should lead to <tt>$0301</tt>. Luckily, this is fairly easy to accomplish. Adding <tt>$20</tt> to <tt>$e1</tt> results in <tt>$01</tt> and sets the carry bit. If the carry bit was set, we know we also need to increment the most significant byte.",
  "After a move in each direction, we also need to check to see if the head would become out of bounds. This is handled differently for each direction. For left and right, we can check to see if the head has effectively \"wrapped around\". Going right from <tt>$021f</tt> by incrementing the least significant byte would lead to <tt>$0220</tt>, but this is actually jumping from the last pixel of the first row to the first pixel of the second row. So, every time we move right, we need to check if the new least significant byte is a multiple of <tt>$20</tt>. This is done using a bit check against the mask <tt>$1f</tt>. Hopefully the illustration below will show you how masking out the lowest 5 bits reveals whether a number is a multiple of <tt>$20</tt> or not.": "After a move in each direction, we also need to check to see if the head would become out of bounds. This is handled differently for each direction. For left and right, we can check to see if the head has effectively \"wrapped around\". Going right from <tt>$021f</tt> by incrementing the least significant byte would lead to <tt>$0220</tt>, but this is actually jumping from the last pixel of the first row to the first pixel of the second row. So, every time we move right, we need to check if the new least significant byte is a multiple of <tt>$20</tt>. This is done using a bit check against the mask <tt>$1f</tt>. Hopefully the illustration below will show you how masking out the lowest 5 bits reveals whether a number is a multiple of <tt>$20</tt> or not.",
  "I won't explain in depth how each of the directions work, but the above explanation should give you enough to work it out with a bit of study.": "I won't explain in depth how each of the directions work, but the above explanation should give you enough to work it out with a bit of study.",
  "Rendering the game": "Rendering the game",
  "Because the game state is stored in terms of pixel locations, rendering the game is very straightforward. The first subroutine, <tt>drawApple</tt>, is extremely simple. It sets <tt>Y</tt> to zero, loads a random colour into the accumulator, then stores this value into <tt>($00),y</tt>. <tt>$00</tt> is where the location of the apple is stored, so <tt>($00),y</tt> dereferences to this memory location. Read the \"Indirect indexed\" section in <a href=\"#addressing\">Addressing modes</a> for more details.": "Because the game state is stored in terms of pixel locations, rendering the game is very straightforward. The first subroutine, <tt>drawApple</tt>, is extremely simple. It sets <tt>Y</tt> to zero, loads a random colour into the accumulator, then stores this value into <tt>($00),y</tt>. <tt>$00</tt> is where the location of the apple is stored, so <tt>($00),y</tt> dereferences to this memory location. Read the \"Indirect indexed\" section in <a href=\"#addressing\">Addressing modes</a> for more details.",
  "Next comes <tt>drawSnake</tt>. This is pretty simple too - we first undraw the tail and then draw the head. <tt>X</tt> is set to the length of the snake, so we can index to the right pixel, and we set <tt>A</tt> to zero then perform the write using the indexed indirect addressing mode. Then we reload <tt>X</tt> to index to the head, set <tt>A</tt> to one and store it at <tt>($10,x)</tt>. <tt>$10</tt> stores the two-byte location of the head, so this draws a white pixel at the current head position. As only the head and the tail of the snake move, this is enough to keep the snake moving.": "Next comes <tt>drawSnake</tt>. This is pretty simple too - we first undraw the tail and then draw the head. <tt>X</tt> is set to the length of the snake, so we can index to the right pixel, and we set <tt>A</tt> to zero then perform the write using the indexed indirect addressing mode. Then we reload <tt>X</tt> to index to the head, set <tt>A</tt> to one and store it at <tt>($10,x)</tt>. <tt>$10</tt> stores the two-byte location of the head, so this draws a white pixel at the current head position. As only the head and the tail of the snake move, this is enough to keep the snake moving.",
  "The last subroutine, <tt>spinWheels</tt>, is just there because the game would run too fast otherwise. All <tt>spinWheels</tt> does is count <tt>X</tt> down from zero until it hits zero again. The first <tt>dex</tt> wraps, making <tt>X</tt> <tt>#$ff</tt>.": "The last subroutine, <tt>spinWheels</tt>, is just there because the game would run too fast otherwise. All <tt>spinWheels</tt> does is count <tt>X</tt> down from zero until it hits zero again. The first <tt>dex</tt> wraps, making <tt>X</tt> <tt>#$ff</tt>."
}