{
  "6502": "6502",
  "Unable to relocate code outside 64k memory": "Code kann nicht außerhalb des 64k Speicherbereichs verschoben werden",
  "Assembling code ...": "Code wird assembliert...",
  "No code to run.": "Kein Code zum Ausführen vorhanden.",
  "Syntax error line %d: %s": "Syntaxfehler in Zeile %d: %s",
  "Out of range branch on line %d (branches are limited to -128 to +127): %s": "Sprungbefehl außerhalb des gültigen Bereichs in Zeile %d (Sprünge sind auf -128 bis +127 begrenzt): %s",
  "Code assembled successfully, %d bytes.": "Code erfolgreich assembliert, %d Bytes.",
  "Preprocessing ...": "Vorverarbeitung läuft...",
  "Found $d labels.": "%d Labels gefunden.",
  "Found $d label.": "%d Label gefunden.",
  "Indexing labels...": "Labels werden indiziert...",
  "Label already defined at line %s: %d": "Label wurde bereits in Zeile %d definiert: %s",
  "Label {label} is already used as a symbol; please rename one of them": "Label {label} wird bereits als Symbol verwendet; bitte eines davon umbenennen",
  "No address or label provided": "Keine Adresse oder Label angegeben",
  "Unable to find/parse given address/label": "Die angegebene Adresse/Label konnte nicht gefunden oder verarbeitet werden",
  "Stopped": "Angehalten",
  "wdm-output": "WDM-Ausgabe",
  "Address %s - unknown opcode": "Adresse %s - unbekannter Opcode",
  "6502 Stack filled! Wrapping...": "6502 Stack voll! Überlauf...",
  "6502 Stack emptied! Wrapping...": "6502 Stack leer! Unterlauf...",
  "Program completed at PC=$%s": "Programm beendet bei PC=$%s",
  "Open Assembly File": "Assembler-Datei öffnen",
  "Save Assembly File": "Assembler Datei speichern",
  "Unsaved changes": "Uneingespeicherte Änderungen",
  "File \"%s\" has unsaved changes": "Datei \"%s\" enthält ungespeicherte Änderungen",
  "Assembly Files": "Assembler-Dateien",
  "All Files": "Alle Dateien",
  "Cancel": "Abbrechen",
  "Unsaved Changes": "Uneingespeicherte Änderungen",
  "Discard": "Verwerfen",
  "Save": "Speichern",
  "Code copied to editor": "Code in Editor kopiert",
  "Copied to clipboard": "In die Zwischenablage kopiert",
  "Failed to copy to clipboard": "Konnte nicht in die Zwischenablage kopiert werden",
  "Program paused automatically": "Programm automatisch pausiert",
  "Assembled successfully": "Erfolgreich assembliert",
  "Assemble failed": "Assemblierung fehlgeschlagen",
  "Hexdump:": "Hexdump:",
  "Disassembly:": "Disassemblierung:",
  "Simulator failure": "Simulator-Fehler",
  "Labels failure": "Label-Fehler",
  "Gamepad key pressed:": "Gamepad-Taste gedrückt:",
  "Failed to load file": "Datei konnte nicht geladen werden",
  "File loaded successfully": "Datei erfolgreich geladen",
  "Error opening file": "Fehler beim Öffnen der Datei",
  "untitled": "unbenannt",
  "Error saving file": "Fehler beim Speichern der Datei",
  "File saved successfully": "Datei erfolgreich gespeichert",
  "Assemble": "Assemblieren",
  "Run": "Ausführen",
  "Pause": "Pause",
  "Resume": "Fortsetzen",
  "Reset": "Zurücksetzen",
  "Step": "Schritt",
  "Help": "Hilfe",
  "Learn 6502 Assembly": "Lerne 6502 Assembler",
  "Menu": "Menü",
  "Learn": "Lernen",
  "Editor": "Editor",
  "Debugger": "Debugger",
  "Game Console": "Spielkonsole",
  "Open...": "Öffnen...",
  "Save as...": "Speichern unter...",
  "About Learn 6502 Assembly": "Über Lerne 6502 Assembler",
  "Quit": "Beenden",
  "Save changes?": "Änderungen speichern?",
  "Your file has unsaved changes. Changes will be lost if you don't save them.": "Deine Datei enthält ungespeicherte Änderungen. Die Änderungen gehen verloren, wenn du sie nicht speicherst.",
  "Preferences": "Einstellungen",
  "Appearance": "Erscheinungsbild",
  "Main Settings": "Haupteinstellungen",
  "There are currently no settings.": "Derzeit gibt es keine Einstellungen.",
  "Continue": "Fortfahren",
  "Copy to editor": "In Editor kopieren",
  "Debug your 6502 assembly code, step through your program, and view memory and registers. To get started, assemble and run your program.": "Debugge deinen 6502-Assemblercode, gehe dein Programm schrittweise durch und betrachte Speicher und Register. Kompiliere und starte dein Programm, um zu beginnen.",
  "Information": "Information",
  "Messages": "Meldungen",
  "Hex Monitor": "Hex-Monitor",
  "Hexdump": "Hexdump",
  "Disassembled": "Disassemblierter Code",
  "Learn how to program the 6502 microprocessor.": "Lerne, wie man den 6502-Mikroprozessor programmiert.",
  "Zero Page ($0000-$00FF)": "Nullseite ($0000-$00FF)",
  "Stack ($0100-$01FF)": "Stack ($0100-$01FF)",
  "Display Memory ($0200-$05FF)": "Anzeigespeicher ($0200-$05FF)",
  "Program Storage ($0600-$FFFF)": "Programmspeicher ($0600-$FFFF)",
  "Snake Game Data ($00-$15)": "Snake-Spieldaten ($00-$15)",
  "Random/Input ($FE-$FF)": "Zufalls-/Eingabedaten ($FE-$FF)",
  "Full Memory ($0000-$FFFF)": "Gesamter Speicher ($0000-$FFFF)",
  "Copy to clipboard": "In die Zwischenablage kopieren",
  "6502 Assembly Learning Environment": "Lernumgebung für 6502-Assembler",
  "A comprehensive learning environment for programming vintage computers and game consoles using 6502 assembly language.": "Eine umfassende Lernumgebung für die Programmierung von Retro-Computern und Spielkonsolen mit 6502-Assembler.",
  "Features:": "Funktionen:",
  "Learn step-by-step with an interactive tutorial": "Lerne Schritt für Schritt mit einem interaktiven Tutorial",
  "Write code with a built-in editor": "Schreibe Code mit einem integrierten Editor",
  "Debug your programs with real-time tools": "Debugge deine Programme mit Echtzeit-Tools",
  "See your code run on a virtual game console": "Führe deinen Code auf einer virtuellen Spielkonsole aus",
  "Interactive tutorial interface in light theme": "Interaktive Tutorial-Oberfläche im hellen Design",
  "Interactive tutorial interface in dark theme": "Interaktive Tutorial-Oberfläche im dunklen Design",
  "Code editor with 6502 assembly syntax highlighting and visible help": "Code-Editor mit Syntaxhervorhebung für 6502-Assembler und sichtbarer Hilfe",
  "Built-in debugger showing real-time registers, flags, and memory": "Integrierter Debugger mit Echtzeit-Anzeige von Registern, Flags und Speicher",
  "Virtual game console displaying three colored pixels": "Virtuelle Spielkonsole mit drei farbigen Pixeln",
  "Major update focusing on improved learning experience and usability": "Umfangreiches Update mit Fokus auf verbessertes Lernerlebnis und Benutzerfreundlichkeit",
  "Added help feature to make code editing easier for beginners": "Hilfefunktion hinzugefügt, um die Codebearbeitung für Anfänger zu erleichtern",
  "Improved game screen and controls for mobile devices": "Verbesserte Spieloberfläche und Steuerung für mobile Geräte",
  "New tools to examine your code, including disassembler and fast switchable memory viewer": "Neue Werkzeuge zur Code-Analyse, einschließlich Disassembler und schnell umschaltbarer Speicheransicht",
  "Many minor bugs have been fixed to improve overall usability": "Zahlreiche kleine Fehler wurden behoben, um die allgemeine Benutzerfreundlichkeit zu verbessern",
  "Games now automatically pause when switching between screens": "Spiele werden jetzt automatisch pausiert, wenn zwischen Bildschirmen gewechselt wird",
  "Added file management to save and load your programs": "Dateiverwaltung zum Speichern und Laden von Programmen hinzugefügt",
  "Enhanced app presentation and accessibility": "Verbesserte App-Darstellung und Zugänglichkeit",
  "Improved descriptions to be more welcoming for non-technical users": "Verbesserte Beschreibungen für nicht-technische Benutzer",
  "Optimized Flatpak configuration by removing unnecessary permissions": "Optimierte Flatpak-Konfiguration durch Entfernen unnötiger Berechtigungen",
  "Improved the game console performance for smoother gameplay": "Verbesserte Leistung der Spielekonsole für flüssigeres Gameplay",
  "Enhanced the hex monitor address range input for easier value editing": "Verbesserte Eingabe des Adressbereichs im Hex-Monitor",
  "Reduced default hex monitor address range for better efficiency": "Reduzierter Standard-Adressbereich des Hex-Monitors für bessere Effizienz",
  "Debugger now only updates when visible, reducing unnecessary processing": "Debugger wird nur noch aktualisiert, wenn er sichtbar ist, reduziert unnötige Verarbeitung",
  "Fixed build error on PostmarketOS, improving mobile compatibility": "Build-Fehler unter PostmarketOS behoben, verbessert Kompatibilität mit Mobilgeräten",
  "First release of Learn 6502 Assembly for GNOME": "Erste Veröffentlichung von Lerne 6502 Assembler für GNOME",
  "Assembly": "Assembler",
  "Programming": "Programmierung",
  "Learning": "Lernen",
  "Emulator": "Emulator",
  "Memory Map": "Speicherbelegung",
  "<b>Zero Page</b>: <tt>$0000</tt>-<tt>$00FF</tt> (first 256 bytes, faster access)": "<b>Zero Page</b>: <tt>$0000</tt>-<tt>$00FF</tt> (erste 256 Bytes, schnellerer Zugriff)",
  "<b>Stack</b>: <tt>$0100</tt>-<tt>$01FF</tt>": "<b>Stack</b>: <tt>$0100</tt>-<tt>$01FF</tt>",
  "<b>Display Memory</b>: <tt>$0200</tt>-<tt>$05FF</tt> (used for screen output)": "<b>Anzeigespeicher</b>: <tt>$0200</tt>-<tt>$05FF</tt> (für Bildschirmausgabe)",
  "<b>Program Storage</b>: Starting at <tt>$0600</tt>": "<b>Programmspeicher</b>: Beginnt bei <tt>$0600</tt>",
  "Display Organization": "Bildschirmorganisation",
  "Screen maps to memory range <tt>$0200</tt>-<tt>$05FF</tt>": "Bildschirm wird auf Speicherbereich <tt>$0200</tt>-<tt>$05FF</tt> abgebildet",
  "Values <tt>$00</tt>-<tt>$0F</tt> represent 16 different colors (<tt>$00</tt>=black, <tt>$01</tt>=white)": "Werte <tt>$00</tt>-<tt>$0F</tt> stellen 16 verschiedene Farben dar (<tt>$00</tt>=schwarz, <tt>$01</tt>=weiß)",
  "Organized as four horizontal strips of 32×8 pixels": "Organisiert als vier horizontale Streifen von 32×8 Pixeln",
  "First row: <tt>$0200</tt>-<tt>$021F</tt>, second row: <tt>$0220</tt>-<tt>$023F</tt>, etc.": "Erste Zeile: <tt>$0200</tt>-<tt>$021F</tt>, zweite Zeile: <tt>$0220</tt>-<tt>$023F</tt>, usw.",
  "Color Palette": "Farbpalette",
  "<b><tt>$0</tt></b>: Black (<tt>#000000</tt>)": "<b><tt>$0</tt></b>: Schwarz (<tt>#000000</tt>)",
  "<b><tt>$1</tt></b>: White (<tt>#ffffff</tt>)": "<b><tt>$1</tt></b>: Weiß (<tt>#ffffff</tt>)",
  "<b><tt>$2</tt></b>: Red (<tt>#880000</tt>)": "<b><tt>$2</tt></b>: Rot (<tt>#880000</tt>)",
  "<b><tt>$3</tt></b>: Cyan (<tt>#aaffee</tt>)": "<b><tt>$3</tt></b>: Cyan (<tt>#aaffee</tt>)",
  "<b><tt>$4</tt></b>: Purple (<tt>#cc44cc</tt>)": "<b><tt>$4</tt></b>: Lila (<tt>#cc44cc</tt>)",
  "<b><tt>$5</tt></b>: Green (<tt>#00cc55</tt>)": "<b><tt>$5</tt></b>: Grün (<tt>#00cc55</tt>)",
  "<b><tt>$6</tt></b>: Blue (<tt>#0000aa</tt>)": "<b><tt>$6</tt></b>: Blau (<tt>#0000aa</tt>)",
  "<b><tt>$7</tt></b>: Yellow (<tt>#eeee77</tt>)": "<b><tt>$7</tt></b>: Gelb (<tt>#eeee77</tt>)",
  "<b><tt>$8</tt></b>: Orange (<tt>#dd8855</tt>)": "<b><tt>$8</tt></b>: Orange (<tt>#dd8855</tt>)",
  "<b><tt>$9</tt></b>: Brown (<tt>#664400</tt>)": "<b><tt>$9</tt></b>: Braun (<tt>#664400</tt>)",
  "<b><tt>$a</tt></b>: Light red (<tt>#ff7777</tt>)": "<b><tt>$a</tt></b>: Hellrot (<tt>#ff7777</tt>)",
  "<b><tt>$b</tt></b>: Dark grey (<tt>#333333</tt>)": "<b><tt>$b</tt></b>: Dunkelgrau (<tt>#333333</tt>)",
  "<b><tt>$c</tt></b>: Grey (<tt>#777777</tt>)": "<b><tt>$c</tt></b>: Grau (<tt>#777777</tt>)",
  "<b><tt>$d</tt></b>: Light green (<tt>#aaff66</tt>)": "<b><tt>$d</tt></b>: Hellgrün (<tt>#aaff66</tt>)",
  "<b><tt>$e</tt></b>: Light blue (<tt>#0088ff</tt>)": "<b><tt>$e</tt></b>: Hellblau (<tt>#0088ff</tt>)",
  "<b><tt>$f</tt></b>: Light grey (<tt>#bbbbbb</tt>)": "<b><tt>$f</tt></b>: Hellgrau (<tt>#bbbbbb</tt>)",
  "Registers": "Register",
  "<b>A</b> (Accumulator): Main register for calculations and data manipulation": "<b>A</b> (Akkumulator): Hauptregister für Berechnungen und Datenmanipulation",
  "<b>X, Y</b>: Index registers for addressing and counting": "<b>X, Y</b>: Indexregister für Adressierung und Zählung",
  "<b>SP</b> (Stack Pointer): Points to current stack position (starts at <tt>$FF</tt>)": "<b>SP</b> (Stack Pointer): Zeigt auf aktuelle Stack-Position (beginnt bei <tt>$FF</tt>)",
  "<b>PC</b> (Program Counter): Points to the next instruction to execute": "<b>PC</b> (Program Counter): Zeigt auf die nächste auszuführende Anweisung",
  "Processor Flags": "Prozessor-Flags",
  "<b>N</b> (Negative): Set when bit 7 of result is set": "<b>N</b> (Negativ): Gesetzt, wenn Bit 7 des Ergebnisses gesetzt ist",
  "<b>V</b> (Overflow): Set when arithmetic operation causes signed overflow": "<b>V</b> (Überlauf): Gesetzt, wenn arithmetische Operation einen Vorzeichenüberlauf verursacht",
  "<b>B</b> (Break): Set when BRK instruction is executed": "<b>B</b> (Break): Gesetzt, wenn BRK-Anweisung ausgeführt wird",
  "<b>D</b> (Decimal): Set when processor is in BCD (Binary Coded Decimal) mode": "<b>D</b> (Dezimal): Gesetzt, wenn Prozessor im BCD-Modus (Binary Coded Decimal) ist",
  "<b>I</b> (Interrupt): Set when interrupts are disabled": "<b>I</b> (Interrupt): Gesetzt, wenn Interrupts deaktiviert sind",
  "<b>Z</b> (Zero): Set when result is zero": "<b>Z</b> (Null): Gesetzt, wenn Ergebnis null ist",
  "<b>C</b> (Carry): Set when arithmetic operations overflow a byte": "<b>C</b> (Übertrag): Gesetzt, wenn arithmetische Operationen ein Byte überlaufen",
  "Used for conditional branching": "Wird für bedingte Verzweigungen verwendet",
  "Addressing Modes": "Adressierungsmodi",
  "<b>Immediate</b> (<tt>#$c0</tt>): Use the actual value": "<b>Unmittelbar</b> (<tt>#$c0</tt>): Verwendet den tatsächlichen Wert",
  "<b>Zero Page</b> (<tt>$c0</tt>): Access memory locations <tt>$00</tt>-<tt>$FF</tt>": "<b>Nullseite</b> (<tt>$c0</tt>): Greift auf Speicheradressen <tt>$00</tt>-<tt>$FF</tt> zu",
  "<b>Absolute</b> (<tt>$c000</tt>): Access any memory location": "<b>Absolut</b> (<tt>$c000</tt>): Greift auf beliebige Speicheradressen zu",
  "<b>Zero Page,X/Y</b> (<tt>$c0,X</tt>): Add X/Y register to zero page address": "<b>Nullseite,X/Y</b> (<tt>$c0,X</tt>): Addiert X/Y-Register zur Nullseitenadresse",
  "<b>Absolute,X/Y</b> (<tt>$c000,X</tt>): Add X/Y register to absolute address": "<b>Absolut,X/Y</b> (<tt>$c000,X</tt>): Addiert X/Y-Register zur absoluten Adresse",
  "<b>Indirect</b> (<tt>($c000)</tt>): Look up address stored at given location": "<b>Indirekt</b> (<tt>($c000)</tt>): Liest die an der angegebenen Adresse gespeicherte Adresse",
  "<b>Indexed Indirect</b> (<tt>($c0,X)</tt>): Add X to zero page address, then dereference": "<b>Indiziert Indirekt</b> (<tt>($c0,X)</tt>): Addiert X zur Nullseitenadresse, dann dereferenzieren",
  "<b>Indirect Indexed</b> (<tt>($c0),Y</tt>): Dereference zero page address, then add Y": "<b>Indirekt Indiziert</b> (<tt>($c0),Y</tt>): Dereferenziert Nullseitenadresse, dann Y addieren",
  "Common Instructions": "Häufige Anweisungen",
  "<b>LDA/LDX/LDY</b>: Load registers": "<b>LDA/LDX/LDY</b>: Register laden",
  "<b>STA/STX/STY</b>: Store registers to memory": "<b>STA/STX/STY</b>: Register im Speicher ablegen",
  "<b>INX/INY/DEX/DEY</b>: Increment/decrement registers": "<b>INX/INY/DEX/DEY</b>: Register erhöhen/verringern",
  "<b>ADC/SBC</b>: Add/subtract with carry": "<b>ADC/SBC</b>: Addieren/Subtrahieren mit Übertrag",
  "<b>JMP</b>: Unconditional jump": "<b>JMP</b>: Unbedingter Sprung",
  "<b>JSR/RTS</b>: Jump to subroutine / Return from subroutine": "<b>JSR/RTS</b>: Sprung zu Unterprogramm / Rückkehr aus Unterprogramm",
  "<b>BEQ/BNE/BCC/BCS</b>: Branch if equal/not equal/carry clear/carry set": "<b>BEQ/BNE/BCC/BCS</b>: Verzweige wenn gleich/ungleich/Übertrag gelöscht/Übertrag gesetzt",
  "<b>PHA/PLA</b>: Push/pull accumulator to/from stack": "<b>PHA/PLA</b>: Akkumulator auf Stack legen/vom Stack holen",
  "Special Memory Locations (in Simulator)": "Spezielle Speicheradressen (im Simulator)",
  "<b><tt>$FE</tt></b>: Random number generator (reads as a random value 0-255)": "<b><tt>$FE</tt></b>: Zufallszahlengenerator (liefert einen Zufallswert 0-255)",
  "<b><tt>$FF</tt></b>: Last pressed key (ASCII code)": "<b><tt>$FF</tt></b>: Zuletzt gedrückte Taste (ASCII-Code)",
  "<b>Directional controls</b>:": "<b>Richtungssteuerung</b>:",
  "<b>W</b> or Up Arrow key (<tt>$77</tt>)": "<b>W</b> oder Pfeil nach oben (<tt>$77</tt>)",
  "<b>A</b> or Left Arrow key (<tt>$61</tt>)": "<b>A</b> oder Pfeil nach links (<tt>$61</tt>)",
  "<b>S</b> or Down Arrow key (<tt>$73</tt>)": "<b>S</b> oder Pfeil nach unten (<tt>$73</tt>)",
  "<b>D</b> or Right Arrow key (<tt>$64</tt>)": "<b>D</b> oder Pfeil nach rechts (<tt>$64</tt>)",
  "<b>Action buttons</b>:": "<b>Aktionstasten</b>:",
  "<b>Q</b> or Enter/Return key (<tt>$0D</tt>)": "<b>Q</b> oder Eingabe/Return-Taste (<tt>$0D</tt>)",
  "<b>E</b> or Space key (<tt>$20</tt>)": "<b>E</b> oder Leertaste (<tt>$20</tt>)",
  "Snake Game Memory Usage": "Speichernutzung im Snake-Spiel",
  "<b><tt>$00</tt>-<tt>$01</tt></b>: Apple position": "<b><tt>$00</tt>-<tt>$01</tt></b>: Apfel-Position",
  "<b><tt>$02</tt></b>: Snake direction (1=up, 2=right, 4=down, 8=left)": "<b><tt>$02</tt></b>: Schlangen-Richtung (1=oben, 2=rechts, 4=unten, 8=links)",
  "<b><tt>$03</tt></b>: Snake length": "<b><tt>$03</tt></b>: Schlangen-Länge",
  "<b><tt>$10</tt>-<tt>$15</tt></b>: Snake position data (head, body segments, tail)": "<b><tt>$10</tt>-<tt>$15</tt></b>: Schlangen-Positionsdaten (Kopf, Körpersegmente, Schwanz)",
  "Tutorial <sub>by <a href=\"https://www.skilldrick.co.uk/\">Nick Morgan</a>, licensed under CC BY 4.0</sub>": "Tutorial <sub>von <a href=\"https://www.skilldrick.co.uk/\">Nick Morgan</a>, lizenziert unter CC BY 4.0</sub>",
  "Introduction": "Einführung",
  "In this tiny tutorial I'm going to show you how to get started writing 6502 assembly language. The 6502 processor was massive in the seventies and eighties, powering famous computers like the <a href=\"http://en.wikipedia.org/wiki/BBC_Micro\">BBC Micro</a>, <a href=\"http://en.wikipedia.org/wiki/Atari_2600\">Atari 2600</a>, <a href=\"http://en.wikipedia.org/wiki/Commodore_64\">Commodore 64</a>, <a href=\"http://en.wikipedia.org/wiki/Apple_II\">Apple II</a>, and the <a href=\"http://en.wikipedia.org/wiki/Nintendo_Entertainment_System\">Nintendo Entertainment System</a>. Bender in Futurama <a href=\"http://www.transbyte.org/SID/SID-files/Bender_6502.jpg\">has a 6502 processor for a brain</a>. <a href=\"http://www.pagetable.com/docs/terminator/00-37-23.jpg\">Even the Terminator was programmed in 6502</a>.": "In diesem kleinen Tutorial zeige ich dir, wie du mit der 6502-Assemblersprache loslegen kannst. Der 6502-Prozessor war in den Siebzigern und Achtzigern riesig und trieb berühmte Computer wie den <a href=\"http://en.wikipedia.org/wiki/BBC_Micro\">BBC Micro</a>, <a href=\"http://en.wikipedia.org/wiki/Atari_2600\">Atari 2600</a>, <a href=\"http://en.wikipedia.org/wiki/Commodore_64\">Commodore 64</a>, <a href=\"http://en.wikipedia.org/wiki/Apple_II\">Apple II</a> und das <a href=\"http://en.wikipedia.org/wiki/Nintendo_Entertainment_System\">Nintendo Entertainment System</a> an. Bender aus Futurama <a href=\"http://www.transbyte.org/SID/SID-files/Bender_6502.jpg\">hat einen 6502-Prozessor als Gehirn</a>. <a href=\"http://www.pagetable.com/docs/terminator/00-37-23.jpg\">Sogar der Terminator wurde in 6502 programmiert</a>.",
  "So, why would you want to learn 6502? It's a dead language isn't it? Well, so's Latin. And they still teach that. <a href=\"http://en.wikipedia.org/wiki/Q.E.D.\">Q.E.D.</a>": "Warum solltest du also 6502 lernen wollen? Es ist doch eine tote Sprache, oder? Nun, Latein ist das auch. Und das wird immer noch unterrichtet. <a href=\"http://en.wikipedia.org/wiki/Q.E.D.\">Q.E.D.</a>",
  "(Actually, I've been reliably informed that 6502 processors are still being produced by <a href=\"http://www.westerndesigncenter.com/wdc/w65c02s-chip.cfm\">Western Design Center</a> and <a href=\"http://www.mouser.co.uk/Search/Refine.aspx?Keyword=65C02\">sold to hobbyists</a>, so clearly 6502 <i>isn&apos;t</i> a dead language! Who knew?)": "(Tatsächlich wurde mir zuverlässig mitgeteilt, dass 6502-Prozessoren immer noch von <a href=\"http://www.westerndesigncenter.com/wdc/w65c02s-chip.cfm\">Western Design Center</a> hergestellt und <a href=\"http://www.mouser.co.uk/Search/Refine.aspx?Keyword=65C02\">an Bastler verkauft</a> werden, also ist 6502 offensichtlich <i>keine</i> tote Sprache! Wer hätte das gedacht?)",
  "Seriously though, I think it's valuable to have an understanding of assembly language. Assembly language is the lowest level of abstraction in computers - the point at which the code is still readable. Assembly language translates directly to the bytes that are executed by your computer's processor. If you understand how it works, you've basically become a computer <a href=\"http://skilldrick.co.uk/2011/04/magic-in-software-development/\">magician</a>.": "Aber ernsthaft, ich denke es ist wertvoll, ein Verständnis für Assemblersprache zu haben. Assemblersprache ist die niedrigste Abstraktionsebene in Computern - der Punkt, an dem der Code noch lesbar ist. Assemblersprache wird direkt in die Bytes übersetzt, die von deinem Computerprozessor ausgeführt werden. Wenn du verstehst, wie es funktioniert, bist du im Grunde ein Computer-<a href=\"http://skilldrick.co.uk/2011/04/magic-in-software-development/\">Magier</a> geworden.",
  "Then why 6502? Why not a <i>useful</i> assembly language, like <a href=\"http://en.wikipedia.org/wiki/X86\">x86</a>? Well, I don't think learning x86 is useful. I don't think you'll ever have to <i>write</i> assembly language in your day job - this is purely an academic exercise, something to expand your mind and your thinking. 6502 was originally written in a different age, a time when the majority of developers were writing assembly directly, rather than in these new-fangled high-level programming languages. So, it was designed to be written by humans. More modern assembly languages are meant to written by compilers, so let's leave it to them. Plus, 6502 is <i>fun</i>. Nobody ever called x86 <i>fun</i>.": "Warum dann 6502? Warum nicht eine <i>nützliche</i> Assemblersprache wie <a href=\"http://en.wikipedia.org/wiki/X86\">x86</a>? Nun, ich denke nicht, dass das Lernen von x86 nützlich ist. Ich glaube nicht, dass du jemals in deinem Arbeitsalltag Assemblersprache <i>schreiben</i> musst - dies ist eine rein akademische Übung, etwas um deinen Geist und dein Denken zu erweitern. 6502 wurde ursprünglich in einer anderen Zeit geschrieben, als die Mehrheit der Entwickler direkt in Assembler programmierte, statt in diesen neumodischen höheren Programmiersprachen. Daher wurde es für Menschen geschrieben. Modernere Assemblersprachen sind dafür gedacht, von Compilern geschrieben zu werden, also überlassen wir es ihnen. Außerdem macht 6502 <i>Spaß</i>. Niemand hat je x86 als <i>spaßig</i> bezeichnet.",
  "Our first program": "Unser erstes Programm",
  "So, let's dive in! This application contains a <a href=\"https://github.com/skilldrick/6502js\">JavaScript 6502 Assembler and Simulator</a> that I have adapted for this interactive tutorial. Click the <b>Copy</b> button in the code block below to copy the example code to the editor. Then click the button in the top right to assemble the code, then click it again to run the program. You can also access these actions through the dropdown menu.": "Also, lass uns loslegen! Diese Anwendung enthält einen <a href=\"https://github.com/skilldrick/6502js\">JavaScript 6502 Assembler und Simulator</a>, den ich für dieses interaktive Tutorial angepasst habe. Klicke auf den <b>Kopieren</b>-Button im Code-Block unten, um den Beispielcode in den Editor zu kopieren. Klicke dann auf den Button oben rechts, um den Code zu assemblieren, und klicke erneut, um das Programm auszuführen. Diese Aktionen kannst du auch über das Dropdown-Menü aufrufen.",
  "The black game console screen now should show three coloured \"pixels\" at the top left.": "Der schwarze Spielkonsolenbildschirm sollte jetzt drei farbige \"Pixel\" oben links zeigen.",
  "So, what's this program actually doing? Let's step through it. Hit <b>Reset</b>, then select <b>Step</b> from the dropdown menu. The button will switch to step mode, allowing you to execute the program one instruction at a time. Click once and you'll notice in the debugger that <tt>A=</tt> changed from <tt>$00</tt> to <tt>$01</tt>, and <tt>PC=</tt> changed from <tt>$0600</tt> to <tt>$0602</tt>.": "Was macht dieses Programm eigentlich? Lass uns es Schritt für Schritt durchgehen. Klicke auf <b>Zurücksetzen</b> und wähle dann <b>Schritt</b> aus dem Dropdown-Menü. Der Button wechselt in den Schritt-Modus, wodurch du das Programm Anweisung für Anweisung ausführen kannst. Nach einem Klick wirst du im Debugger sehen, dass sich <tt>A=</tt> von <tt>$00</tt> zu <tt>$01</tt> und <tt>PC=</tt> von <tt>$0600</tt> zu <tt>$0602</tt> geändert hat.",
  "Any numbers prefixed with <tt>$</tt> in 6502 assembly language (and by extension, in this book) are in hexadecimal (hex) format. If you're not familiar with hex numbers, I recommend you read <a href=\"http://en.wikipedia.org/wiki/Hexadecimal\">the Wikipedia article</a>. Anything prefixed with <tt>#</tt> is a literal number value. Any other number refers to a memory location.": "Alle Zahlen mit dem Präfix <tt>$</tt> in der 6502-Assemblersprache (und folglich auch in diesem Buch) sind im Hexadezimal-(Hex)-Format. Wenn du mit Hexadezimalzahlen nicht vertraut bist, empfehle ich dir, <a href=\"http://en.wikipedia.org/wiki/Hexadecimal\">den Wikipedia-Artikel</a> zu lesen. Alles mit dem Präfix <tt>#</tt> ist ein Literalwert. Alle anderen Zahlen beziehen sich auf Speicheradressen.",
  "Equipped with that knowledge, you should be able to see that the instruction <tt>LDA #$01</tt> loads the hex value <tt>$01</tt> into register <tt>A</tt>. I'll go into more detail on registers in the next section.": "Mit diesem Wissen solltest du erkennen können, dass die Anweisung <tt>LDA #$01</tt> den Hexadezimalwert <tt>$01</tt> in das Register <tt>A</tt> lädt. Ich werde im nächsten Abschnitt näher auf Register eingehen.",
  "Press <b>Step</b> again to execute the second instruction. The top-left pixel of the game console should now be white. This simulator uses the memory locations <tt>$0200</tt> to <tt>$05ff</tt> to draw pixels on its display. The values <tt>$00</tt> to <tt>$0f</tt> represent 16 different colours (<tt>$00</tt> is black and <tt>$01</tt> is white), so storing the value <tt>$01</tt> at memory location <tt>$0200</tt> draws a white pixel at the top left corner. This is simpler than how an actual computer would output video, but it'll do for now.": "Drücke erneut <b>Schritt</b>, um die zweite Anweisung auszuführen. Das Pixel oben links in der Spielkonsole sollte jetzt weiß sein. Dieser Simulator verwendet die Speicheradressen von <tt>$0200</tt> bis <tt>$05ff</tt>, um Pixel auf seinem Display zu zeichnen. Die Werte von <tt>$00</tt> bis <tt>$0f</tt> repräsentieren 16 verschiedene Farben (<tt>$00</tt> ist schwarz und <tt>$01</tt> ist weiß), daher zeichnet das Speichern des Wertes <tt>$01</tt> an der Speicheradresse <tt>$0200</tt> ein weißes Pixel in der oberen linken Ecke. Das ist einfacher als die Art und Weise, wie ein echter Computer Video ausgeben würde, aber für den Moment reicht es.",
  "So, the instruction <tt>STA $0200</tt> stores the value of the <tt>A</tt> register to memory location <tt>$0200</tt>. Click <b>Step</b> four more times to execute the rest of the instructions, keeping an eye on the <tt>A</tt> register as it changes.": "Die Anweisung <tt>STA $0200</tt> speichert also den Wert des <tt>A</tt>-Registers an der Speicheradresse <tt>$0200</tt>. Klicke noch vier Mal auf <b>Schritt</b>, um die restlichen Anweisungen auszuführen, und beobachte dabei, wie sich das <tt>A</tt>-Register verändert.",
  "Exercises": "Übungen",
  "1.": "1.",
  "Try changing the colour of the three pixels.": "Versuche die Farbe der drei Pixel zu ändern.",
  "2.": "2.",
  "Change one of the pixels to draw at the bottom-right corner (memory location <tt>$05ff</tt>).": "Ändere eines der Pixel so, dass es in der unteren rechten Ecke gezeichnet wird (Speicheradresse <tt>$05ff</tt>).",
  "3.": "3.",
  "Add more instructions to draw extra pixels.": "Füge weitere Anweisungen hinzu, um zusätzliche Pixel zu zeichnen.",
  "Registers and flags": "Register und Flags",
  "We've already had a little look at the processor status section (the bit with <tt>A</tt>, <tt>PC</tt> etc.), but what does it all mean?": "Wir haben bereits einen kurzen Blick auf den Prozessorstatus-Bereich geworfen (den Teil mit <tt>A</tt>, <tt>PC</tt> usw.), aber was bedeutet das alles?",
  "The first line shows the <tt>A</tt>, <tt>X</tt> and <tt>Y</tt> registers (<tt>A</tt> is often called the \"accumulator\"). Each register holds a single byte. Most operations work on the contents of these registers.": "Die erste Zeile zeigt die Register <tt>A</tt>, <tt>X</tt> und <tt>Y</tt> (<tt>A</tt> wird oft als \"Akkumulator\" bezeichnet). Jedes Register enthält ein einzelnes Byte. Die meisten Operationen arbeiten mit dem Inhalt dieser Register.",
  "<tt>SP</tt> is the stack pointer. I won't get into the stack yet, but basically this register is decremented every time a byte is pushed onto the stack, and incremented when a byte is popped off the stack.": "<tt>SP</tt> ist der Stack-Pointer. Ich werde jetzt noch nicht auf den Stack eingehen, aber im Grunde wird dieses Register jedes Mal dekrementiert, wenn ein Byte auf den Stack geschoben wird, und inkrementiert, wenn ein Byte vom Stack genommen wird.",
  "<tt>PC</tt> is the program counter - it's how the processor knows at what point in the program it currently is. It's like the current line number of an executing script. In the JavaScript simulator the code is assembled starting at memory location <tt>$0600</tt>, so <tt>PC</tt> always starts there.": "<tt>PC</tt> ist der Programmzähler (program counter) - damit weiß der Prozessor, an welcher Stelle im Programm er sich gerade befindet. Es ist wie die aktuelle Zeilennummer eines ausgeführten Skripts. Im JavaScript-Simulator wird der Code ab der Speicheradresse <tt>$0600</tt> assembliert, daher beginnt <tt>PC</tt> immer dort.",
  "The last section shows the processor flags. Each flag is one bit, so all seven flags live in a single byte. The flags are set by the processor to give information about the previous instruction. More on that later. <a href=\"https://web.archive.org/web/20210626024532/http://www.obelisk.me.uk/6502/registers.html\">Read more about the registers and flags here</a>.": "Der letzte Abschnitt zeigt die Prozessor-Flags. Jedes Flag ist ein Bit, sodass alle sieben Flags in einem einzigen Byte untergebracht sind. Die Flags werden vom Prozessor gesetzt, um Informationen über die vorherige Anweisung zu geben. Mehr dazu später. <a href=\"https://web.archive.org/web/20210626024532/http://www.obelisk.me.uk/6502/registers.html\">Lies hier mehr über Register und Flags</a>.",
  "Instructions": "Anweisungen",
  "Instructions in assembly language are like a small set of predefined functions. All instructions take zero or one arguments. Here's some annotated source code to introduce a few different instructions:": "Anweisungen in der Assemblersprache sind wie eine kleine Sammlung vordefinierter Funktionen. Alle Anweisungen nehmen null oder ein Argument. Hier ist etwas kommentierter Quellcode, um einige verschiedene Anweisungen vorzustellen:",
  "Assemble the code, then turn on the debugger and step through the code, watching the <tt>A</tt> and <tt>X</tt> registers. Something slightly odd happens on the line <tt>ADC #$c4</tt>. You might expect that adding <tt>$c4</tt> to <tt>$c0</tt> would give <tt>$184</tt>, but this processor gives the result as <tt>$84</tt>. What's up with that?": "Assembliere den Code, schalte dann den Debugger ein und gehe den Code schrittweise durch, während du die Register <tt>A</tt> und <tt>X</tt> beobachtest. Etwas Seltsames passiert in der Zeile <tt>ADC #$c4</tt>. Du könntest erwarten, dass das Addieren von <tt>$c4</tt> zu <tt>$c0</tt> <tt>$184</tt> ergibt, aber dieser Prozessor gibt das Ergebnis als <tt>$84</tt> aus. Was hat es damit auf sich?",
  "The problem is, <tt>$184</tt> is too big to fit in a single byte (the max is <tt>$FF</tt>), and the registers can only hold a single byte. It's OK though; the processor isn't actually dumb. If you were looking carefully enough, you'll have noticed that the carry flag was set to <tt>1</tt> after this operation. So that's how you know.": "Das Problem ist, dass <tt>$184</tt> zu groß ist, um in ein einzelnes Byte zu passen (das Maximum ist <tt>$FF</tt>), und die Register können nur ein einzelnes Byte speichern. Aber keine Sorge; der Prozessor ist nicht wirklich dumm. Wenn du genau aufgepasst hast, wirst du bemerkt haben, dass das Carry-Flag nach dieser Operation auf <tt>1</tt> gesetzt wurde. So weißt du Bescheid.",
  "In the simulator below <b>type</b> (don't paste) the following code:": "Tippe (nicht einfügen) den folgenden Code in den Simulator ein:",
  "An important thing to notice here is the distinction between <tt>ADC #$01</tt> and <tt>ADC $01</tt>. The first one adds the value <tt>$01</tt> to the <tt>A</tt> register, but the second adds the value stored at memory location <tt>$01</tt> to the <tt>A</tt> register.": "Ein wichtiger Punkt hier ist der Unterschied zwischen <tt>ADC #$01</tt> und <tt>ADC $01</tt>. Der erste Befehl addiert den Wert <tt>$01</tt> zum <tt>A</tt>-Register, aber der zweite addiert den an der Speicheradresse <tt>$01</tt> gespeicherten Wert zum <tt>A</tt>-Register.",
  "Assemble the code and select <b>Step</b> from the Run button's dropdown menu to step through these three instructions. The monitor in the debugger shows a section of memory, and can be helpful to visualise the execution of programs. <tt>STA $01</tt> stores the value of the <tt>A</tt> register at memory location <tt>$01</tt>, and <tt>ADC $01</tt> adds the value stored at the memory location <tt>$01</tt> to the <tt>A</tt> register. <tt>$80 + $80</tt> should equal <tt>$100</tt>, but because this is bigger than a byte, the <tt>A</tt> register is set to <tt>$00</tt> and the carry flag is set. As well as this though, the zero flag is set. The zero flag is set by all instructions where the result is zero.": "Assembliere den Code und wähle <b>Schritt</b> aus dem Dropdown-Menü des Run-Buttons, um diese drei Anweisungen schrittweise durchzugehen. Der Monitor im Debugger zeigt einen Speicherbereich an und kann hilfreich sein, um die Ausführung von Programmen zu visualisieren. <tt>STA $01</tt> speichert den Wert des <tt>A</tt>-Registers an der Speicheradresse <tt>$01</tt>, und <tt>ADC $01</tt> addiert den an der Speicheradresse <tt>$01</tt> gespeicherten Wert zum <tt>A</tt>-Register. <tt>$80 + $80</tt> sollte <tt>$100</tt> ergeben, aber da dies größer als ein Byte ist, wird das <tt>A</tt>-Register auf <tt>$00</tt> gesetzt und das Carry-Flag wird gesetzt. Zusätzlich wird auch das Zero-Flag gesetzt. Das Zero-Flag wird bei allen Anweisungen gesetzt, bei denen das Ergebnis null ist.",
  "A full list of the 6502 instruction set is <a href=\"http://www.6502.org/tutorials/6502opcodes.html\">available here</a> and <a href=\"http://www.obelisk.me.uk/6502/reference.html\">here</a> (I usually refer to both pages as they have their strengths and weaknesses). These pages detail the arguments to each instruction, which registers they use, and which flags they set. They are your bible.": "Eine vollständige Liste des 6502-Befehlssatzes ist <a href=\"http://www.6502.org/tutorials/6502opcodes.html\">hier</a> und <a href=\"http://www.obelisk.me.uk/6502/reference.html\">hier</a> verfügbar (ich verweise normalerweise auf beide Seiten, da sie ihre Stärken und Schwächen haben). Diese Seiten beschreiben die Argumente für jede Anweisung, welche Register sie verwenden und welche Flags sie setzen. Sie sind deine Bibel.",
  "You've seen <tt>TAX</tt>. You can probably guess what <tt>TAY</tt>, <tt>TXA</tt> and <tt>TYA</tt> do, but write some code to test your assumptions.": "Du hast <tt>TAX</tt> gesehen. Du kannst wahrscheinlich erraten, was <tt>TAY</tt>, <tt>TXA</tt> und <tt>TYA</tt> tun, aber schreibe etwas Code, um deine Vermutungen zu testen.",
  "Rewrite the first example in this section to use the <tt>Y</tt> register instead of the <tt>X</tt> register.": "Schreibe das erste Beispiel in diesem Abschnitt so um, dass es das <tt>Y</tt>-Register anstelle des <tt>X</tt>-Registers verwendet.",
  "The opposite of <tt>ADC</tt> is <tt>SBC</tt> (subtract with carry). Write a program that uses this instruction.": "Das Gegenteil von <tt>ADC</tt> ist <tt>SBC</tt> (subtract with carry). Schreibe ein Programm, das diese Anweisung verwendet.",
  "Branching": "Verzweigungen",
  "So far we're only able to write basic programs without any branching logic. Let's change that.": "Bisher können wir nur einfache Programme ohne Verzweigungslogik schreiben. Lass uns das ändern.",
  "6502 assembly language has a bunch of branching instructions, all of which branch based on whether certain flags are set or not. In this example we'll be looking at <tt>BNE</tt>: \"Branch on not equal\".": "Die 6502-Assemblersprache hat eine Reihe von Verzweigungsanweisungen, die alle basierend darauf verzweigen, ob bestimmte Flags gesetzt sind oder nicht. In diesem Beispiel schauen wir uns <tt>BNE</tt> an: \"Branch on not equal\" (Verzweige bei Ungleichheit).",
  "First we load the value <tt>$08</tt> into the <tt>X</tt> register. The next line is a label. Labels just mark certain points in a program so we can return to them later. After the label we decrement <tt>X</tt>, store it to <tt>$0200</tt> (the top-left pixel), and then compare it to the value <tt>$03</tt>. <a href=\"http://www.obelisk.me.uk/6502/reference.html#CPX\"><tt>CPX</tt></a> compares the value in the <tt>X</tt> register with another value. If the two values are equal, the <tt>Z</tt> flag is set to <tt>1</tt>, otherwise it is set to <tt>0</tt>.": "Zuerst laden wir den Wert <tt>$08</tt> in das <tt>X</tt>-Register. Die nächste Zeile ist ein Label. Labels markieren bestimmte Stellen in einem Programm, damit wir später dorthin zurückkehren können. Nach dem Label dekrementieren wir <tt>X</tt>, speichern es in <tt>$0200</tt> (das Pixel oben links) und vergleichen es dann mit dem Wert <tt>$03</tt>. <a href=\"http://www.obelisk.me.uk/6502/reference.html#CPX\"><tt>CPX</tt></a> vergleicht den Wert im <tt>X</tt>-Register mit einem anderen Wert. Wenn die beiden Werte gleich sind, wird das <tt>Z</tt>-Flag auf <tt>1</tt> gesetzt, andernfalls auf <tt>0</tt>.",
  "The next line, <tt>BNE decrement</tt>, will shift execution to the decrement label if the <tt>Z</tt> flag is set to <tt>0</tt> (meaning that the two values in the <tt>CPX</tt> comparison were not equal), otherwise it does nothing and we store <tt>X</tt> to <tt>$0201</tt>, then finish the program.": "Die nächste Zeile, <tt>BNE decrement</tt>, wird die Ausführung zum decrement-Label verschieben, wenn das <tt>Z</tt>-Flag auf <tt>0</tt> gesetzt ist (was bedeutet, dass die beiden Werte im <tt>CPX</tt>-Vergleich nicht gleich waren), andernfalls passiert nichts und wir speichern <tt>X</tt> in <tt>$0201</tt> und beenden dann das Programm.",
  "In assembly language, you'll usually use labels with branch instructions. When assembled though, this label is converted to a single-byte relative offset (a number of bytes to go backwards or forwards from the next instruction) so branch instructions can only go forward and back around 256 bytes. This means they can only be used to move around local code. For moving further you'll need to use the jumping instructions.": "In der Assemblersprache verwendet man normalerweise Labels mit Verzweigungsanweisungen. Beim Assemblieren wird dieses Label jedoch in einen einbytigen relativen Offset umgewandelt (eine Anzahl von Bytes, die von der nächsten Anweisung aus vor- oder rückwärts gegangen werden soll), sodass Verzweigungsanweisungen nur etwa 256 Bytes vor und zurück gehen können. Das bedeutet, dass sie nur für Bewegungen innerhalb von lokalem Code verwendet werden können. Für weitere Bewegungen musst du die Sprunganweisungen verwenden.",
  "The opposite of <tt>BNE</tt> is <tt>BEQ</tt>. Try writing a program that uses <tt>BEQ</tt>.": "Das Gegenteil von <tt>BNE</tt> ist <tt>BEQ</tt>. Versuche ein Programm zu schreiben, das <tt>BEQ</tt> verwendet.",
  "<tt>BCC</tt> and <tt>BCS</tt> (\"branch on carry clear\" and \"branch on carry set\") are used to branch on the carry flag. Write a program that uses one of these two.": "<tt>BCC</tt> und <tt>BCS</tt> (\"branch on carry clear\" und \"branch on carry set\") werden verwendet, um abhängig vom Carry-Flag zu verzweigen. Schreibe ein Programm, das eine dieser beiden Anweisungen verwendet.",
  "Addressing modes": "Adressierungsmodi",
  "The 6502 uses a 16-bit address bus, meaning that there are 65536 bytes of memory available to the processor. Remember that a byte is represented by two hex characters, so the memory locations are generally represented as <tt>$0000 - $ffff</tt>. There are various ways to refer to these memory locations, as detailed below.": "Der 6502 verwendet einen 16-Bit-Adressbus, was bedeutet, dass dem Prozessor 65536 Bytes Speicher zur Verfügung stehen. Denk daran, dass ein Byte durch zwei Hex-Zeichen dargestellt wird, sodass die Speicheradressen im Allgemeinen als <tt>$0000 - $ffff</tt> dargestellt werden. Es gibt verschiedene Möglichkeiten, sich auf diese Speicheradressen zu beziehen, wie unten beschrieben.",
  "With all these examples you might find it helpful to use the memory monitor in the debugger to watch the memory change. The monitor takes a starting memory location and a number of bytes to display from that location. Both of these are hex values. For example, to display 16 bytes of memory from <tt>$c000</tt>, enter <tt>c000</tt> and <tt>10</tt> into <b>Start</b> and <b>Length</b>, respectively.": "Bei all diesen Beispielen kann es hilfreich sein, den Speicher-Monitor im Debugger zu verwenden, um die Änderungen im Speicher zu beobachten. Der Monitor benötigt eine Startadresse und die Anzahl der Bytes, die von dieser Position angezeigt werden sollen. Beide Werte sind Hexadezimalzahlen. Um zum Beispiel 16 Bytes Speicher ab <tt>$c000</tt> anzuzeigen, gib <tt>c000</tt> und <tt>10</tt> in die Felder <b>Start</b> bzw. <b>Länge</b> ein.",
  "Absolute: <tt>$c000</tt>": "Absolut: <tt>$c000</tt>",
  "With absolute addressing, the full memory location is used as the argument to the instruction. For example:": "Bei der absoluten Adressierung wird die vollständige Speicheradresse als Argument für die Anweisung verwendet. Zum Beispiel:",
  "Zero page: <tt>$c0</tt>": "Nullseite: <tt>$c0</tt>",
  "All instructions that support absolute addressing (with the exception of the jump instructions) also have the option to take a single-byte address. This type of addressing is called \"zero page\" - only the first page (the first 256 bytes) of memory is accessible. This is faster, as only one byte needs to be looked up, and takes up less space in the assembled code as well.": "Alle Anweisungen, die absolute Adressierung unterstützen (mit Ausnahme der Sprunganweisungen), haben auch die Möglichkeit, eine einbyte-Adresse zu verwenden. Diese Art der Adressierung wird \"Nullseite\" genannt - nur die erste Seite (die ersten 256 Bytes) des Speichers ist zugänglich. Dies ist schneller, da nur ein Byte nachgeschlagen werden muss, und nimmt auch weniger Platz im assemblierten Code ein.",
  "Zero page,X: <tt>$c0,X</tt>": "Nullseite,X: <tt>$c0,X</tt>",
  "This is where addressing gets interesting. In this mode, a zero page address is given, and then the value of the <tt>X</tt> register is added. Here is an example:": "Hier wird die Adressierung interessant. In diesem Modus wird eine Nullseiten-Adresse angegeben und dann der Wert des <tt>X</tt>-Registers hinzuaddiert. Hier ist ein Beispiel:",
  "If the result of the addition is larger than a single byte, the address wraps around. For example:": "Wenn das Ergebnis der Addition größer als ein einzelnes Byte ist, wird die Adresse umgebrochen. Zum Beispiel:",
  "Zero page,Y: <tt>$c0,Y</tt>": "Nullseite,Y: <tt>$c0,Y</tt>",
  "This is the equivalent of zero page,X, but can only be used with <tt>LDX</tt> and <tt>STX</tt>.": "Dies ist das Äquivalent zu Nullseite,X, kann aber nur mit <tt>LDX</tt> und <tt>STX</tt> verwendet werden.",
  "Absolute,X and absolute,Y: <tt>$c000,X</tt> and <tt>$c000,Y</tt>": "Absolut,X und absolut,Y: <tt>$c000,X</tt> und <tt>$c000,Y</tt>",
  "These are the absolute addressing versions of zero page,X and zero page,Y. For example:": "Dies sind die absoluten Adressierungsversionen von Nullseite,X und Nullseite,Y. Zum Beispiel:",
  "Unlike zero page,Y, absolute,Y can't be used with <tt>STX</tt> but can be used with <tt>LDA</tt> and <tt>STA</tt>.": "Im Gegensatz zu Nullseite,Y kann absolut,Y nicht mit <tt>STX</tt> verwendet werden, aber mit <tt>LDA</tt> und <tt>STA</tt>.",
  "Immediate: <tt>#$c0</tt>": "Unmittelbar: <tt>#$c0</tt>",
  "Immediate addressing doesn't strictly deal with memory addresses - this is the mode where actual values are used. For example, <tt>LDX #$01</tt> loads the value <tt>$01</tt> into the <tt>X</tt> register. This is very different to the zero page instruction <tt>LDX $01</tt> which loads the value at memory location <tt>$01</tt> into the <tt>X</tt> register.": "Die unmittelbare Adressierung beschäftigt sich nicht direkt mit Speicheradressen - dies ist der Modus, in dem tatsächliche Werte verwendet werden. Zum Beispiel lädt <tt>LDX #$01</tt> den Wert <tt>$01</tt> in das <tt>X</tt>-Register. Dies unterscheidet sich deutlich von der Nullseiten-Anweisung <tt>LDX $01</tt>, die den Wert an der Speicheradresse <tt>$01</tt> in das <tt>X</tt>-Register lädt.",
  "Relative: <tt>$c0</tt> (or label)": "Relativ: <tt>$c0</tt> (oder Label)",
  "Relative addressing is used for branching instructions. These instructions take a single byte, which is used as an offset from the following instruction.": "Relative Adressierung wird für Verzweigungsanweisungen verwendet. Diese Anweisungen nehmen ein einzelnes Byte, das als Offset von der folgenden Anweisung verwendet wird.",
  "Assemble the following code, then check the debugger to see the hexdump of the assembled code.": "Assembliere den folgenden Code und schaue dann im Debugger, um den Hexdump des assemblierten Codes zu sehen.",
  "The hex should look something like this:": "Der Hexadezimalcode sollte etwa so aussehen:",
  "<tt>a9</tt> and <tt>c9</tt> are the processor opcodes for immediate-addressed <tt>LDA</tt> and <tt>CMP</tt> respectively. <tt>01</tt> and <tt>02</tt> are the arguments to these instructions. <tt>d0</tt> is the opcode for <tt>BNE</tt>, and its argument is <tt>02</tt>. This means \"skip over the next two bytes\" (<tt>85 22</tt>, the assembled version of <tt>STA $22</tt>). Try editing the code so <tt>STA</tt> takes a two-byte absolute address rather than a single-byte zero page address (e.g. change <tt>STA $22</tt> to <tt>STA $2222</tt>). Reassemble the code and look at the hexdump again - the argument to <tt>BNE</tt> should now be <tt>03</tt>, because the instruction the processor is skipping past is now three bytes long.": "<tt>a9</tt> und <tt>c9</tt> sind die Prozessor-Opcodes für unmittelbar adressierte <tt>LDA</tt> und <tt>CMP</tt>. <tt>01</tt> und <tt>02</tt> sind die Argumente für diese Anweisungen. <tt>d0</tt> ist der Opcode für <tt>BNE</tt>, und sein Argument ist <tt>02</tt>. Dies bedeutet \"überspringe die nächsten zwei Bytes\" (<tt>85 22</tt>, die assemblierte Version von <tt>STA $22</tt>). Versuche den Code so zu ändern, dass <tt>STA</tt> eine zweibyte absolute Adresse anstelle einer einbyte Nullseiten-Adresse verwendet (z.B. ändere <tt>STA $22</tt> zu <tt>STA $2222</tt>). Assembliere den Code neu und schaue dir den Hexdump erneut an - das Argument für <tt>BNE</tt> sollte jetzt <tt>03</tt> sein, weil die Anweisung, die der Prozessor überspringt, jetzt drei Bytes lang ist.",
  "Implicit": "Implizit",
  "Some instructions don't deal with memory locations (e.g. <tt>INX</tt> - increment the <tt>X</tt> register). These are said to have implicit addressing - the argument is implied by the instruction.": "Einige Anweisungen arbeiten nicht mit Speicheradressen (z.B. <tt>INX</tt> - inkrementiere das <tt>X</tt>-Register). Diese haben eine implizite Adressierung - das Argument ergibt sich aus der Anweisung selbst.",
  "Indirect: <tt>($c000)</tt>": "Indirekt: <tt>($c000)</tt>",
  "Indirect addressing uses an absolute address to look up another address. The first address gives the least significant byte of the address, and the following byte gives the most significant byte. That can be hard to wrap your head around, so here's an example:": "Indirekte Adressierung verwendet eine absolute Adresse, um eine andere Adresse nachzuschlagen. Die erste Adresse liefert das niedrigstwertige Byte der Adresse, und das folgende Byte liefert das höchstwertige Byte. Das kann schwer zu verstehen sein, hier ist ein Beispiel:",
  "In this example, <tt>$f0</tt> contains the value <tt>$01</tt> and <tt>$f1</tt> contains the value <tt>$cc</tt>. The instruction <tt>JMP ($f0)</tt> causes the processor to look up the two bytes at <tt>$f0</tt> and <tt>$f1</tt> (<tt>$01</tt> and <tt>$cc</tt>) and put them together to form the address <tt>$cc01</tt>, which becomes the new program counter. Assemble and step through the program above to see what happens. I'll talk more about <tt>JMP</tt> in the section on <a href=\"#jumping\">Jumping</a>.": "In diesem Beispiel enthält <tt>$f0</tt> den Wert <tt>$01</tt> und <tt>$f1</tt> enthält den Wert <tt>$cc</tt>. Die Anweisung <tt>JMP ($f0)</tt> veranlasst den Prozessor, die zwei Bytes bei <tt>$f0</tt> und <tt>$f1</tt> (<tt>$01</tt> und <tt>$cc</tt>) nachzuschlagen und sie zur Adresse <tt>$cc01</tt> zusammenzufügen, die dann zum neuen Programmzähler wird. Assembliere und gehe das obige Programm schrittweise durch, um zu sehen, was passiert. Ich werde mehr über <tt>JMP</tt> im Abschnitt über <a href=\"#jumping\">Springen</a> sprechen.",
  "Indexed indirect: <tt>($c0,X)</tt>": "Indiziert indirekt: <tt>($c0,X)</tt>",
  "This one's kinda weird. It's like a cross between zero page,X and indirect. Basically, you take the zero page address, add the value of the <tt>X</tt> register to it, then use that to look up a two-byte address. For example:": "Diese ist etwas seltsam. Es ist wie eine Kreuzung zwischen Nullseite,X und indirekt. Im Grunde nimmst du die Nullseiten-Adresse, addierst den Wert des <tt>X</tt>-Registers dazu und verwendest das dann, um eine zweibyte-Adresse nachzuschlagen. Zum Beispiel:",
  "Memory locations <tt>$01</tt> and <tt>$02</tt> contain the values <tt>$05</tt> and <tt>$07</tt> respectively. Think of <tt>($00,X)</tt> as <tt>($00 + X)</tt>. In this case <tt>X</tt> is <tt>$01</tt>, so this simplifies to <tt>($01)</tt>. From here things proceed like standard indirect addressing - the two bytes at <tt>$01</tt> and <tt>$02</tt> (<tt>$05</tt> and <tt>$07</tt>) are looked up to form the address <tt>$0705</tt>. This is the address that the <tt>Y</tt> register was stored into in the previous instruction, so the <tt>A</tt> register gets the same value as <tt>Y</tt>, albeit through a much more circuitous route. You won't see this much.": "Die Speicheradressen <tt>$01</tt> und <tt>$02</tt> enthalten die Werte <tt>$05</tt> bzw. <tt>$07</tt>. Denke an <tt>($00,X)</tt> als <tt>($00 + X)</tt>. In diesem Fall ist <tt>X</tt> gleich <tt>$01</tt>, also vereinfacht sich das zu <tt>($01)</tt>. Von hier aus läuft es wie bei der standardmäßigen indirekten Adressierung - die zwei Bytes bei <tt>$01</tt> und <tt>$02</tt> (<tt>$05</tt> und <tt>$07</tt>) werden nachgeschlagen, um die Adresse <tt>$0705</tt> zu bilden. Dies ist die Adresse, in die das <tt>Y</tt>-Register in der vorherigen Anweisung gespeichert wurde, sodass das <tt>A</tt>-Register den gleichen Wert wie <tt>Y</tt> erhält, wenn auch auf einem viel umständlicheren Weg. Das wirst du nicht oft sehen.",
  "Indirect indexed: <tt>($c0),Y</tt>": "Indirekt indiziert: <tt>($c0),Y</tt>",
  "Indirect indexed is like indexed indirect but less insane. Instead of adding the <tt>X</tt> register to the address <i>before</i> dereferencing, the zero page address is dereferenced, and the <tt>Y</tt> register is added to the resulting address.": "Indirekt indiziert ist wie indiziert indirekt, aber weniger verrückt. Anstatt das <tt>X</tt>-Register <i>vor</i> dem Dereferenzieren zur Adresse zu addieren, wird die Nullseiten-Adresse dereferenziert und das <tt>Y</tt>-Register zur resultierenden Adresse addiert.",
  "In this case, <tt>($01)</tt> looks up the two bytes at <tt>$01</tt> and <tt>$02</tt>: <tt>$03</tt> and <tt>$07</tt>. These form the address <tt>$0703</tt>. The value of the <tt>Y</tt> register is added to this address to give the final address <tt>$0704</tt>.": "In diesem Fall schlägt <tt>($01)</tt> die zwei Bytes bei <tt>$01</tt> und <tt>$02</tt> nach: <tt>$03</tt> und <tt>$07</tt>. Diese bilden die Adresse <tt>$0703</tt>. Der Wert des <tt>Y</tt>-Registers wird zu dieser Adresse addiert, um die endgültige Adresse <tt>$0704</tt> zu erhalten.",
  "Exercise": "Übung",
  "Try to write code snippets that use each of the 6502 addressing modes. Remember, you can use the monitor in the debugger to watch a section of memory.": "Versuche Code-Beispiele zu schreiben, die jeden der 6502-Adressierungsmodi verwenden. Denk daran, dass du den Monitor im Debugger verwenden kannst, um einen Speicherbereich zu beobachten.",
  "The stack": "Der Stack",
  "The stack in a 6502 processor is just like any other stack - values are pushed onto it and popped (\"pulled\" in 6502 parlance) off it. The current depth of the stack is measured by the stack pointer, a special register. The stack lives in memory between <tt>$0100</tt> and <tt>$01ff</tt>. The stack pointer is initially <tt>$ff</tt>, which points to memory location <tt>$01ff</tt>. When a byte is pushed onto the stack, the stack pointer becomes <tt>$fe</tt>, or memory location <tt>$01fe</tt>, and so on.": "Der Stack in einem 6502-Prozessor ist wie jeder andere Stack - Werte werden darauf geschoben (gepusht) und davon genommen (\"gepullt\" in 6502-Sprache). Die aktuelle Tiefe des Stacks wird durch den Stack-Pointer gemessen, ein spezielles Register. Der Stack befindet sich im Speicher zwischen <tt>$0100</tt> und <tt>$01ff</tt>. Der Stack-Pointer ist anfangs <tt>$ff</tt>, was auf die Speicheradresse <tt>$01ff</tt> zeigt. Wenn ein Byte auf den Stack geschoben wird, wird der Stack-Pointer zu <tt>$fe</tt>, oder Speicheradresse <tt>$01fe</tt>, und so weiter.",
  "Two of the stack instructions are <tt>PHA</tt> and <tt>PLA</tt>, \"push accumulator\" and \"pull accumulator\". Below is an example of these two in action.": "Zwei der Stack-Anweisungen sind <tt>PHA</tt> und <tt>PLA</tt>, \"push accumulator\" und \"pull accumulator\". Unten ist ein Beispiel dieser beiden in Aktion.",
  "<tt>X</tt> holds the pixel colour, and <tt>Y</tt> holds the position of the current pixel. The first loop draws the current colour as a pixel (via the <tt>A</tt> register), pushes the colour to the stack, then increments the colour and position. The second loop pops the stack, draws the popped colour as a pixel, then increments the position. As should be expected, this creates a mirrored pattern.": "<tt>X</tt> enthält die Pixelfarbe und <tt>Y</tt> enthält die Position des aktuellen Pixels. Die erste Schleife zeichnet die aktuelle Farbe als Pixel (über das <tt>A</tt>-Register), schiebt die Farbe auf den Stack und erhöht dann die Farbe und Position. Die zweite Schleife nimmt die Farbe vom Stack, zeichnet die genommene Farbe als Pixel und erhöht dann die Position. Wie zu erwarten, erzeugt dies ein gespiegeltes Muster.",
  "Jumping": "Springen",
  "Jumping is like branching with two main differences. First, jumps are not conditionally executed, and second, they take a two-byte absolute address. For small programs, this second detail isn't very important, as you'll mostly be using labels, and the assembler works out the correct memory location from the label. For larger programs though, jumping is the only way to move from one section of the code to another.": "Springen ist wie Verzweigen mit zwei Hauptunterschieden. Erstens werden Sprünge nicht bedingt ausgeführt, und zweitens verwenden sie eine zweibyte absolute Adresse. Für kleine Programme ist dieses zweite Detail nicht sehr wichtig, da du hauptsächlich Labels verwendest und der Assembler die korrekte Speicheradresse aus dem Label ermittelt. Für größere Programme ist Springen jedoch der einzige Weg, um von einem Codeabschnitt zu einem anderen zu gelangen.",
  "JMP": "JMP",
  "<tt>JMP</tt> is an unconditional jump. Here's a really simple example to show it in action:": "<tt>JMP</tt> ist ein unbedingter Sprung. Hier ist ein sehr einfaches Beispiel, um es in Aktion zu zeigen:",
  "JSR/RTS": "JSR/RTS",
  "<tt>JSR</tt> and <tt>RTS</tt> (\"jump to subroutine\" and \"return from subroutine\") are a dynamic duo that you'll usually see used together. <tt>JSR</tt> is used to jump from the current location to another part of the code. <tt>RTS</tt> returns to the previous position. This is basically like calling a function and returning.": "<tt>JSR</tt> und <tt>RTS</tt> (\"jump to subroutine\" und \"return from subroutine\") sind ein dynamisches Duo, das du normalerweise zusammen verwendet siehst. <tt>JSR</tt> wird verwendet, um von der aktuellen Position zu einem anderen Teil des Codes zu springen. <tt>RTS</tt> kehrt zur vorherigen Position zurück. Dies ist im Grunde wie ein Funktionsaufruf und die Rückkehr daraus.",
  "The processor knows where to return to because <tt>JSR</tt> pushes the address minus one of the next instruction onto the stack before jumping to the given location. <tt>RTS</tt> pops this location, adds one to it, and jumps to that location. An example:": "Der Prozessor weiß, wohin er zurückkehren soll, weil <tt>JSR</tt> die Adresse der nächsten Anweisung minus eins auf den Stack schiebt, bevor er zur angegebenen Position springt. <tt>RTS</tt> nimmt diese Position vom Stack, addiert eins dazu und springt zu dieser Position. Ein Beispiel:",
  "The first instruction causes execution to jump to the <tt>init</tt> label. This sets <tt>X</tt>, then returns to the next instruction, <tt>JSR loop</tt>. This jumps to the <tt>loop</tt> label, which increments <tt>X</tt> until it is equal to <tt>$05</tt>. After that we return to the next instruction, <tt>JSR end</tt>, which jumps to the end of the file. This illustrates how <tt>JSR</tt> and <tt>RTS</tt> can be used together to create modular code.": "Die erste Anweisung veranlasst die Ausführung zum <tt>init</tt>-Label zu springen. Dies setzt <tt>X</tt> und kehrt dann zur nächsten Anweisung zurück, <tt>JSR loop</tt>. Dies springt zum <tt>loop</tt>-Label, das <tt>X</tt> erhöht, bis es gleich <tt>$05</tt> ist. Danach kehren wir zur nächsten Anweisung zurück, <tt>JSR end</tt>, die zum Ende der Datei springt. Dies zeigt, wie <tt>JSR</tt> und <tt>RTS</tt> zusammen verwendet werden können, um modularen Code zu erstellen.",
  "Creating a game": "Ein Spiel erstellen",
  "Now, let's put all this knowledge to good use, and make a game! We're going to be making a really simple version of the classic game 'Snake'.": "Jetzt lass uns all dieses Wissen gut nutzen und ein Spiel erstellen! Wir werden eine sehr einfache Version des klassischen Spiels 'Snake' erstellen.",
  "Even though this will be a simple version, the code will be substantially larger than all the previous examples. We will need to keep track of several memory locations together for the various aspects of the game. We can still do the necessary bookkeeping throughout the program ourselves, as before, but on a larger scale that quickly becomes tedious and can also lead to bugs that are difficult to spot. Instead we'll now let the assembler do some of the mundane work for us.": "Auch wenn dies eine einfache Version sein wird, wird der Code wesentlich umfangreicher sein als alle bisherigen Beispiele. Wir müssen mehrere Speicheradressen für die verschiedenen Aspekte des Spiels im Auge behalten. Wir können die notwendige Buchführung im Programm immer noch selbst durchführen, wie zuvor, aber in größerem Umfang wird das schnell mühsam und kann auch zu schwer zu findenden Fehlern führen. Stattdessen lassen wir jetzt den Assembler einen Teil der alltäglichen Arbeit für uns erledigen.",
  "In this assembler, we can define descriptive constants (or symbols) that represent numbers. The rest of the code can then simply use the constants instead of the literal number, which immediately makes it obvious what we're dealing with. You can use letters, digits and underscores in a name.": "In diesem Assembler können wir beschreibende Konstanten (oder Symbole) definieren, die Zahlen repräsentieren. Der restliche Code kann dann einfach die Konstanten anstelle der wörtlichen Zahl verwenden, was sofort deutlich macht, womit wir es zu tun haben. Du kannst Buchstaben, Ziffern und Unterstriche in einem Namen verwenden.",
  "Here's an example. Note that immediate operands are still prefixed with a <tt>#</tt>.": "Hier ist ein Beispiel. Beachte, dass unmittelbare Operanden immer noch mit einem <tt>#</tt> beginnen.",
  "The code block below contains the entire source code of the game. I'll explain how it works in the following sections.": "Der Code-Block unten enthält den gesamten Quellcode des Spiels. Ich werde in den folgenden Abschnitten erklären, wie es funktioniert.",
  "<a href=\"https://twitter.com/wkjagt\">Willem van der Jagt</a> made a <a href=\"https://gist.github.com/wkjagt/9043907\">fully annotated gist of this source code</a>, so follow along with that for more details.": "<a href=\"https://twitter.com/wkjagt\">Willem van der Jagt</a> hat einen <a href=\"https://gist.github.com/wkjagt/9043907\">vollständig kommentierten Gist dieses Quellcodes</a> erstellt, folge diesem für weitere Details.",
  "Overall structure": "Gesamtstruktur",
  "After the initial block of comments (lines starting with semicolons), the first two lines are:": "Nach dem anfänglichen Block von Kommentaren (Zeilen, die mit Semikolons beginnen), sind die ersten beiden Zeilen:",
  "<tt>init</tt> and <tt>loop</tt> are both subroutines. <tt>init</tt> initializes the game state, and <tt>loop</tt> is the main game loop.": "<tt>init</tt> und <tt>loop</tt> sind beide Unterprogramme. <tt>init</tt> initialisiert den Spielzustand, und <tt>loop</tt> ist die Hauptspielschleife.",
  "The <tt>loop</tt> subroutine itself just calls a number of subroutines sequentially, before looping back on itself:": "Das <tt>loop</tt>-Unterprogramm selbst ruft nur eine Reihe von Unterprogrammen nacheinander auf, bevor es zu sich selbst zurückkehrt:",
  "First, <tt>readkeys</tt> checks to see if one of the direction keys (W, A, S, D) was pressed, and if so, sets the direction of the snake accordingly. Then, <tt>checkCollision</tt> checks to see if the snake collided with itself or the apple. <tt>updateSnake</tt> updates the internal representation of the snake, based on its direction. Next, the apple and snake are drawn. Finally, <tt>spinWheels</tt> makes the processor do some busy work, to stop the game from running too quickly. Think of it like a sleep command. The game keeps running until the snake collides with the wall or itself.": "Zuerst überprüft <tt>readkeys</tt>, ob eine der Richtungstasten (W, A, S, D) gedrückt wurde, und setzt entsprechend die Richtung der Schlange. Dann überprüft <tt>checkCollision</tt>, ob die Schlange mit sich selbst oder dem Apfel kollidiert ist. <tt>updateSnake</tt> aktualisiert die interne Darstellung der Schlange basierend auf ihrer Richtung. Als nächstes werden der Apfel und die Schlange gezeichnet. Schließlich lässt <tt>spinWheels</tt> den Prozessor etwas Leerlaufarbeit machen, damit das Spiel nicht zu schnell läuft. Denk daran wie an einen Sleep-Befehl. Das Spiel läuft weiter, bis die Schlange mit der Wand oder sich selbst kollidiert.",
  "Zero page usage": "Verwendung der Nullseite",
  "The zero page of memory is used to store a number of game state variables, as noted in the comment block at the top of the game. Everything in <tt>$00</tt>, <tt>$01</tt> and <tt>$10</tt> upwards is a pair of bytes representing a two-byte memory location that will be looked up using indirect addressing. These memory locations will all be between <tt>$0200</tt> and <tt>$05ff</tt> - the section of memory corresponding to the game console. For example, if <tt>$00</tt> and <tt>$01</tt> contained the values <tt>$01</tt> and <tt>$02</tt>, they would be referring to the second pixel of the display ( <tt>$0201</tt> - remember, the least significant byte comes first in indirect addressing).": "Die Zero Page wird verwendet, um verschiedene Spielzustandsvariablen zu speichern, wie im Kommentarblock am Anfang des Spiels beschrieben. Die Bereiche <tt>$00</tt>, <tt>$01</tt> und ab <tt>$10</tt> aufwärts enthalten jeweils Bytepaare, die eine 2-Byte-Speicheradresse darstellen und über Indirect Addressing nachgeschlagen werden. Diese Speicheradressen liegen alle zwischen <tt>$0200</tt> und <tt>$05ff</tt> - dem Speicherbereich des Spielkonsolen-Displays. Wenn zum Beispiel <tt>$00</tt> und <tt>$01</tt> die Werte <tt>$01</tt> und <tt>$02</tt> enthalten, verweisen sie auf das zweite Pixel des Displays (<tt>$0201</tt> - beachte, dass bei Indirect Addressing das Least Significant Byte zuerst kommt).",
  "The first two bytes hold the location of the apple. This is updated every time the snake eats the apple. Byte <tt>$02</tt> contains the current direction. <tt>1</tt> means up, <tt>2</tt> right, <tt>4</tt> down, and <tt>8</tt> left. The reasoning behind these numbers will become clear later.": "Die ersten zwei Bytes enthalten die Position des Apfels. Diese wird jedes Mal aktualisiert, wenn die Schlange den Apfel frisst. Byte <tt>$02</tt> enthält die aktuelle Richtung. <tt>1</tt> bedeutet nach oben, <tt>2</tt> nach rechts, <tt>4</tt> nach unten und <tt>8</tt> nach links. Die Logik hinter diesen Zahlen wird später klar werden.",
  "Finally, byte <tt>$03</tt> contains the current length of the snake, in terms of bytes in memory (so a length of 4 means 2 pixels).": "Schließlich enthält Byte <tt>$03</tt> die aktuelle Länge der Schlange, gemessen in Bytes im Speicher (eine Länge von 4 bedeutet also 2 Pixel).",
  "Initialization": "Initialisierung",
  "The <tt>init</tt> subroutine defers to two subroutines, <tt>initSnake</tt> and <tt>generateApplePosition</tt>. <tt>initSnake</tt> sets the snake direction, length, and then loads the initial memory locations of the snake head and body. The byte pair at <tt>$10</tt> contains the screen location of the head, the pair at <tt>$12</tt> contains the location of the single body segment, and <tt>$14</tt> contains the location of the tail (the tail is the last segment of the body and is drawn in black to keep the snake moving). This happens in the following code:": "Die <tt>init</tt>-Subroutine ruft zwei weitere Subroutinen auf: <tt>initSnake</tt> und <tt>generateApplePosition</tt>. <tt>initSnake</tt> legt die Richtung und Länge der Schlange fest und lädt dann die initialen Speicherpositionen für Kopf und Körper. Das Bytepaar bei <tt>$10</tt> enthält die Bildschirmposition des Kopfes, das Paar bei <tt>$12</tt> die Position des Körpersegments und <tt>$14</tt> die Position des Schwanzes (der Schwanz ist das letzte Segment des Körpers und wird schwarz dargestellt, damit die Bewegung der Schlange sichtbar wird). Dies geschieht im folgenden Code:",
  "This loads the value <tt>$11</tt> into the memory location <tt>$10</tt>, the value <tt>$10</tt> into <tt>$12</tt>, and <tt>$0f</tt> into <tt>$14</tt>. It then loads the value <tt>$04</tt> into <tt>$11</tt>, <tt>$13</tt> and <tt>$15</tt>. This leads to memory like this:": "Dies lädt den Wert <tt>$11</tt> in die Speicheradresse <tt>$10</tt>, den Wert <tt>$10</tt> in <tt>$12</tt> und <tt>$0f</tt> in <tt>$14</tt>. Dann lädt es den Wert <tt>$04</tt> in <tt>$11</tt>, <tt>$13</tt> und <tt>$15</tt>. Dies führt zu Speicher wie diesem:",
  "which represents the indirectly-addressed memory locations <tt>$0411</tt>, <tt>$0410</tt> and <tt>$040f</tt> (three pixels in the middle of the display). I'm labouring this point, but it's important to fully grok how indirect addressing works.": "was die indirekt adressierten Speicheradressen <tt>$0411</tt>, <tt>$0410</tt> und <tt>$040f</tt> repräsentiert (drei Pixel in der Mitte des Displays). Ich betone diesen Punkt, aber es ist wichtig, vollständig zu verstehen, wie indirekte Adressierung funktioniert.",
  "The next subroutine, <tt>generateApplePosition</tt>, sets the apple location to a random position on the display. First, it loads a random byte into the accumulator (<tt>$fe</tt> is a random number generator in this simulator). This is stored into <tt>$00</tt>. Next, a different random byte is loaded into the accumulator, which is then <tt>AND</tt>-ed with the value <tt>$03</tt>. This part requires a bit of a detour.": "Das nächste Unterprogramm, <tt>generateApplePosition</tt>, setzt die Apfelposition auf eine zufällige Position auf dem Display. Zuerst lädt es ein zufälliges Byte in den Akkumulator (<tt>$fe</tt> ist ein Zufallszahlengenerator in diesem Simulator). Dies wird in <tt>$00</tt> gespeichert. Als nächstes wird ein anderes zufälliges Byte in den Akkumulator geladen, das dann mit dem Wert <tt>$03</tt> <tt>AND</tt>-verknüpft wird. Dieser Teil erfordert einen kleinen Umweg.",
  "The hex value <tt>$03</tt> is represented in binary as <tt>00000011</tt>. The <tt>AND</tt> opcode performs a bitwise AND of the argument with the accumulator. For example, if the accumulator contains the binary value <tt>10101010</tt>, then the result of <tt>AND</tt> with <tt>00000011</tt> will be <tt>00000010</tt>.": "Der Hexadezimalwert <tt>$03</tt> wird binär als <tt>00000011</tt> dargestellt. Der <tt>AND</tt>-Opcode führt eine bitweise UND-Verknüpfung des Arguments mit dem Akkumulator durch. Wenn zum Beispiel der Akkumulator den binären Wert <tt>10101010</tt> enthält, dann wird das Ergebnis von <tt>AND</tt> mit <tt>00000011</tt> <tt>00000010</tt> sein.",
  "The effect of this is to mask out the least significant two bits of the accumulator, setting the others to zero. This converts a number in the range of 0–255 to a number in the range of 0–3.": "Die Wirkung davon ist, die zwei niedrigstwertigen Bits des Akkumulators zu maskieren und die anderen auf Null zu setzen. Dies konvertiert eine Zahl im Bereich von 0-255 in eine Zahl im Bereich von 0-3.",
  "After this, the value <tt>2</tt> is added to the accumulator, to create a final random number in the range 2–5.": "Danach wird der Wert <tt>2</tt> zum Akkumulator addiert, um eine endgültige Zufallszahl im Bereich 2-5 zu erzeugen.",
  "The result of this subroutine is to load a random byte into <tt>$00</tt>, and a random number between 2 and 5 into <tt>$01</tt>. Because the least significant byte comes first with indirect addressing, this translates into a memory address between <tt>$0200</tt> and <tt>$05ff</tt>: the exact range used to draw the display.": "Das Ergebnis dieses Unterprogramms ist, ein zufälliges Byte in <tt>$00</tt> und eine Zufallszahl zwischen 2 und 5 in <tt>$01</tt> zu laden. Da das niedrigstwertige Byte bei indirekter Adressierung zuerst kommt, übersetzt sich dies in eine Speicheradresse zwischen <tt>$0200</tt> und <tt>$05ff</tt>: genau der Bereich, der zum Zeichnen des Displays verwendet wird.",
  "The game loop": "Die Spielschleife",
  "Nearly all games have at their heart a game loop. All game loops have the same basic form: accept user input, update the game state, and render the game state. This loop is no different.": "Fast alle Spiele haben in ihrem Kern eine Spielschleife. Alle Spielschleifen haben die gleiche Grundform: Benutzereingaben annehmen, den Spielzustand aktualisieren und den Spielzustand darstellen. Diese Schleife ist da keine Ausnahme.",
  "Reading the input": "Die Eingabe lesen",
  "The first subroutine, <tt>readKeys</tt>, takes the job of accepting user input. The memory location <tt>$ff</tt> holds the ascii code of the most recent key press in this simulator. The value is loaded into the accumulator, then compared to <tt>$77</tt> (the hex code for W), <tt>$64</tt> (D), <tt>$73</tt> (S) and <tt>$61</tt> (A). If any of these comparisons are successful, the program branches to the appropriate section.": "Das erste Unterprogramm, <tt>readKeys</tt>, übernimmt die Aufgabe, Benutzereingaben anzunehmen. Die Speicheradresse <tt>$ff</tt> enthält den ASCII-Code des letzten Tastendrucks in diesem Simulator. Der Wert wird in den Akkumulator geladen und dann mit <tt>$77</tt> (dem Hexcode für W), <tt>$64</tt> (D), <tt>$73</tt> (S) und <tt>$61</tt> (A) verglichen. Wenn einer dieser Vergleiche erfolgreich ist, verzweigt das Programm zum entsprechenden Abschnitt.",
  "Additional button inputs are also available: button A (Enter/Return key, ASCII code <tt>$0D</tt>) and button B (Space key, ASCII code <tt>$20</tt>). These can be used to add more interaction to your games. For directional controls, both WASD keys and arrow keys can be used interchangeably.": "Zusätzliche Tasteneingaben sind ebenfalls verfügbar: Taste A (Eingabe/Return-Taste, ASCII-Code <tt>$0D</tt>) und Taste B (Leertaste, ASCII-Code <tt>$20</tt>). Diese können genutzt werden, um mehr Interaktion zu deinen Spielen hinzuzufügen. Für die Richtungssteuerung können sowohl WASD-Tasten als auch Pfeiltasten austauschbar verwendet werden.",
  "Each section (<tt>upKey</tt>, <tt>rightKey</tt>, etc.) first checks to see if the current direction is the opposite of the new direction. This requires another little detour.": "Jeder Abschnitt (<tt>upKey</tt>, <tt>rightKey</tt>, usw.) überprüft zuerst, ob die aktuelle Richtung die entgegengesetzte der neuen Richtung ist. Dies erfordert einen weiteren kleinen Umweg.",
  "As stated before, the four directions are represented internally by the numbers 1, 2, 4 and 8. Each of these numbers is a power of 2, thus they are represented by a binary number with a single <tt>1</tt>:": "Wie bereits erwähnt, werden die vier Richtungen intern durch die Zahlen 1, 2, 4 und 8 dargestellt. Jede dieser Zahlen ist eine Zweierpotenz, daher werden sie durch eine Binärzahl mit einer einzigen <tt>1</tt> dargestellt:",
  "The <tt>BIT</tt> opcode is similar to <tt>AND</tt>, but the calculation is only used to set the zero flag - the actual result is discarded. The zero flag is set only if the result of AND-ing the accumulator with argument is zero. When we're looking at powers of two, the zero flag will only be set if the two numbers are not the same. For example, <tt>0001 AND 0001</tt> is not zero, but <tt>0001 AND 0010</tt> is zero.": "Der <tt>BIT</tt>-Opcode ist ähnlich wie <tt>AND</tt>, aber die Berechnung wird nur verwendet, um das Zero-Flag zu setzen - das eigentliche Ergebnis wird verworfen. Das Zero-Flag wird nur gesetzt, wenn das Ergebnis der UND-Verknüpfung des Akkumulators mit dem Argument Null ist. Wenn wir Zweierpotenzen betrachten, wird das Zero-Flag nur gesetzt, wenn die beiden Zahlen nicht gleich sind. Zum Beispiel ist <tt>0001 AND 0001</tt> nicht Null, aber <tt>0001 AND 0010</tt> ist Null.",
  "So, looking at <tt>upKey</tt>, if the current direction is down (4), the bit test will be zero. <tt>BNE</tt> means \"branch if the zero flag is clear\", so in this case we'll branch to <tt>illegalMove</tt>, which just returns from the subroutine. Otherwise, the new direction (1 in this case) is stored in the appropriate memory location.": "Wenn wir also <tt>upKey</tt> betrachten und die aktuelle Richtung nach unten ist (4), wird der Bit-Test Null sein. <tt>BNE</tt> bedeutet \"verzweige, wenn das Zero-Flag nicht gesetzt ist\", also werden wir in diesem Fall zu <tt>illegalMove</tt> verzweigen, was einfach aus dem Unterprogramm zurückkehrt. Andernfalls wird die neue Richtung (in diesem Fall 1) in der entsprechenden Speicheradresse gespeichert.",
  "Updating the game state": "Den Spielzustand aktualisieren",
  "The next subroutine, <tt>checkCollision</tt>, defers to <tt>checkAppleCollision</tt> and <tt>checkSnakeCollision</tt>. <tt>checkAppleCollision</tt> just checks to see if the two bytes holding the location of the apple match the two bytes holding the location of the head. If they do, the length is increased and a new apple position is generated.": "Das nächste Unterprogramm, <tt>checkCollision</tt>, delegiert an <tt>checkAppleCollision</tt> und <tt>checkSnakeCollision</tt>. <tt>checkAppleCollision</tt> überprüft nur, ob die zwei Bytes, die die Position des Apfels enthalten, mit den zwei Bytes übereinstimmen, die die Position des Kopfes enthalten. Wenn sie übereinstimmen, wird die Länge erhöht und eine neue Apfelposition generiert.",
  "<tt>checkSnakeCollision</tt> loops through the snake's body segments, checking each byte pair against the head pair. If there is a match, then game over.": "<tt>checkSnakeCollision</tt> durchläuft die Körpersegmente der Schlange und vergleicht jedes Bytepaar mit dem Kopfpaar. Wenn es eine Übereinstimmung gibt, dann ist das Spiel vorbei.",
  "After collision detection, we update the snake's location. This is done at a high level like so: First, move each byte pair of the body up one position in memory. Second, update the head according to the current direction. Finally, if the head is out of bounds, handle it as a collision. I'll illustrate this with some ascii art. Each pair of brackets contains an x,y coordinate rather than a pair of bytes for simplicity.": "Nach der Kollisionserkennung aktualisieren wir die Position der Schlange. Dies wird auf hoher Ebene so gemacht: Zuerst wird jedes Bytepaar des Körpers um eine Position im Speicher nach oben verschoben. Zweitens wird der Kopf entsprechend der aktuellen Richtung aktualisiert. Schließlich wird, wenn der Kopf außerhalb der Grenzen ist, dies als Kollision behandelt. Ich werde dies mit ASCII-Kunst veranschaulichen. Jedes Klammerpaar enthält der Einfachheit halber eine x,y-Koordinate anstelle eines Bytepaars.",
  "At a low level, this subroutine is slightly more complex. First, the length is loaded into the <tt>X</tt> register, which is then decremented. The snippet below shows the starting memory for the snake.": "Auf niedriger Ebene ist dieses Unterprogramm etwas komplexer. Zuerst wird die Länge in das <tt>X</tt>-Register geladen, das dann dekrementiert wird. Der untenstehende Ausschnitt zeigt den Anfangsspeicher für die Schlange.",
  "The length is initialized to <tt>4</tt>, so <tt>X</tt> starts off as <tt>3</tt>. <tt>LDA $10,x</tt> loads the value of <tt>$13</tt> into <tt>A</tt>, then <tt>STA $12,x</tt> stores this value into <tt>$15</tt>. <tt>X</tt> is decremented, and we loop. Now <tt>X</tt> is <tt>2</tt>, so we load <tt>$12</tt> and store it into <tt>$14</tt>. This loops while <tt>X</tt> is positive (<tt>BPL</tt> means \"branch if positive\").": "Die Länge wird auf <tt>4</tt> initialisiert, also beginnt <tt>X</tt> bei <tt>3</tt>. <tt>LDA $10,x</tt> lädt den Wert von <tt>$13</tt> in <tt>A</tt>, dann speichert <tt>STA $12,x</tt> diesen Wert in <tt>$15</tt>. <tt>X</tt> wird dekrementiert und wir durchlaufen die Schleife. Jetzt ist <tt>X</tt> <tt>2</tt>, also laden wir <tt>$12</tt> und speichern es in <tt>$14</tt>. Dies läuft in einer Schleife, solange <tt>X</tt> positiv ist (<tt>BPL</tt> bedeutet \"verzweige wenn positiv\").",
  "Once the values have been shifted down the snake, we have to work out what to do with the head. The direction is first loaded into <tt>A</tt>. <tt>LSR</tt> means \"logical shift right\", or \"shift all the bits one position to the right\". The least significant bit is shifted into the carry flag, so if the accumulator is <tt>1</tt>, after <tt>LSR</tt> it is <tt>0</tt>, with the carry flag set.": "Sobald die Werte die Schlange hinunter verschoben wurden, müssen wir herausfinden, was mit dem Kopf zu tun ist. Die Richtung wird zuerst in <tt>A</tt> geladen. <tt>LSR</tt> bedeutet \"logische Verschiebung nach rechts\" oder \"verschiebe alle Bits um eine Position nach rechts\". Das niedrigstwertige Bit wird in das Carry-Flag verschoben, also wenn der Akkumulator <tt>1</tt> ist, ist er nach <tt>LSR</tt> <tt>0</tt>, wobei das Carry-Flag gesetzt ist.",
  "To test whether the direction is <tt>1</tt>, <tt>2</tt>, <tt>4</tt> or <tt>8</tt>, the code continually shifts right until the carry is set. One <tt>LSR</tt> means \"up\", two means \"right\", and so on.": "Um zu testen, ob die Richtung <tt>1</tt>, <tt>2</tt>, <tt>4</tt> oder <tt>8</tt> ist, verschiebt der Code kontinuierlich nach rechts, bis das Carry gesetzt ist. Ein <tt>LSR</tt> bedeutet \"nach oben\", zwei bedeutet \"nach rechts\" und so weiter.",
  "The next bit updates the head of the snake depending on the direction. This is probably the most complicated part of the code, and it's all reliant on how memory locations map to the screen, so let's look at that in more detail.": "Der nächste Teil aktualisiert den Kopf der Schlange abhängig von der Richtung. Dies ist wahrscheinlich der komplizierteste Teil des Codes, und es hängt alles davon ab, wie Speicheradressen auf den Bildschirm abgebildet werden, also lass uns das genauer betrachten.",
  "You can think of the screen as four horizontal strips of 32 × 8 pixels. These strips map to <tt>$0200-$02ff</tt>, <tt>$0300-$03ff</tt>, <tt>$0400-$04ff</tt> and <tt>$0500-$05ff</tt>. The first rows of pixels are <tt>$0200-$021f</tt>, <tt>$0220-$023f</tt>, <tt>$0240-$025f</tt>, etc.": "Du kannst dir den Bildschirm als vier horizontale Streifen von 32 × 8 Pixeln vorstellen. Diese Streifen werden auf <tt>$0200-$02ff</tt>, <tt>$0300-$03ff</tt>, <tt>$0400-$04ff</tt> und <tt>$0500-$05ff</tt> abgebildet. Die ersten Pixelreihen sind <tt>$0200-$021f</tt>, <tt>$0220-$023f</tt>, <tt>$0240-$025f</tt>, usw.",
  "As long as you're moving within one of these horizontal strips, things are simple. For example, to move right, just increment the least significant byte (e.g. <tt>$0200</tt> becomes <tt>$0201</tt>). To go down, add <tt>$20</tt> (e.g. <tt>$0200</tt> becomes <tt>$0220</tt>). Left and up are the reverse.": "Solange du dich innerhalb eines dieser horizontalen Streifen bewegst, sind die Dinge einfach. Um zum Beispiel nach rechts zu gehen, erhöhe einfach das niedrigstwertige Byte (z.B. wird aus <tt>$0200</tt> dann <tt>$0201</tt>). Um nach unten zu gehen, addiere <tt>$20</tt> (z.B. wird aus <tt>$0200</tt> dann <tt>$0220</tt>). Links und oben sind die Umkehrung davon.",
  "Going between sections is more complicated, as we have to take into account the most significant byte as well. For example, going down from <tt>$02e1</tt> should lead to <tt>$0301</tt>. Luckily, this is fairly easy to accomplish. Adding <tt>$20</tt> to <tt>$e1</tt> results in <tt>$01</tt> and sets the carry bit. If the carry bit was set, we know we also need to increment the most significant byte.": "Der Übergang zwischen den Abschnitten ist komplizierter, da wir auch das höchstwertige Byte berücksichtigen müssen. Zum Beispiel sollte das Heruntergehen von <tt>$02e1</tt> zu <tt>$0301</tt> führen. Glücklicherweise ist dies ziemlich einfach zu erreichen. Die Addition von <tt>$20</tt> zu <tt>$e1</tt> ergibt <tt>$01</tt> und setzt das Carry-Bit. Wenn das Carry-Bit gesetzt wurde, wissen wir, dass wir auch das höchstwertige Byte erhöhen müssen.",
  "After a move in each direction, we also need to check to see if the head would become out of bounds. This is handled differently for each direction. For left and right, we can check to see if the head has effectively \"wrapped around\". Going right from <tt>$021f</tt> by incrementing the least significant byte would lead to <tt>$0220</tt>, but this is actually jumping from the last pixel of the first row to the first pixel of the second row. So, every time we move right, we need to check if the new least significant byte is a multiple of <tt>$20</tt>. This is done using a bit check against the mask <tt>$1f</tt>. Hopefully the illustration below will show you how masking out the lowest 5 bits reveals whether a number is a multiple of <tt>$20</tt> or not.": "Nach einer Bewegung in jede Richtung müssen wir auch überprüfen, ob der Kopf außerhalb der Grenzen geraten würde. Dies wird für jede Richtung unterschiedlich gehandhabt. Für links und rechts können wir überprüfen, ob der Kopf effektiv \"umgebrochen\" ist. Wenn man von <tt>$021f</tt> nach rechts geht, indem man das niedrigstwertige Byte erhöht, würde dies zu <tt>$0220</tt> führen, aber das bedeutet eigentlich einen Sprung vom letzten Pixel der ersten Zeile zum ersten Pixel der zweiten Zeile. Also müssen wir jedes Mal, wenn wir nach rechts gehen, überprüfen, ob das neue niedrigstwertige Byte ein Vielfaches von <tt>$20</tt> ist. Dies geschieht durch eine Bit-Prüfung gegen die Maske <tt>$1f</tt>. Die Illustration unten wird hoffentlich zeigen, wie das Maskieren der niedrigsten 5 Bits offenbart, ob eine Zahl ein Vielfaches von <tt>$20</tt> ist oder nicht.",
  "I won't explain in depth how each of the directions work, but the above explanation should give you enough to work it out with a bit of study.": "Ich werde nicht im Detail erklären, wie jede der Richtungen funktioniert, aber die obige Erklärung sollte dir genug geben, um es mit etwas Studium selbst herauszufinden.",
  "Rendering the game": "Das Spiel darstellen",
  "Because the game state is stored in terms of pixel locations, rendering the game is very straightforward. The first subroutine, <tt>drawApple</tt>, is extremely simple. It sets <tt>Y</tt> to zero, loads a random colour into the accumulator, then stores this value into <tt>($00),y</tt>. <tt>$00</tt> is where the location of the apple is stored, so <tt>($00),y</tt> dereferences to this memory location. Read the \"Indirect indexed\" section in <a href=\"#addressing\">Addressing modes</a> for more details.": "Da der Spielzustand in Form von Pixelpositionen gespeichert wird, ist die Darstellung des Spiels sehr einfach. Das erste Unterprogramm, <tt>drawApple</tt>, ist extrem einfach. Es setzt <tt>Y</tt> auf Null, lädt eine zufällige Farbe in den Akkumulator und speichert diesen Wert dann in <tt>($00),y</tt>. <tt>$00</tt> ist der Ort, an dem die Position des Apfels gespeichert ist, also dereferenziert <tt>($00),y</tt> zu dieser Speicheradresse. Lies den Abschnitt \"Indirekt indiziert\" in <a href=\"#addressing\">Adressierungsmodi</a> für weitere Details.",
  "Next comes <tt>drawSnake</tt>. This is pretty simple too - we first undraw the tail and then draw the head. <tt>X</tt> is set to the length of the snake, so we can index to the right pixel, and we set <tt>A</tt> to zero then perform the write using the indexed indirect addressing mode. Then we reload <tt>X</tt> to index to the head, set <tt>A</tt> to one and store it at <tt>($10,x)</tt>. <tt>$10</tt> stores the two-byte location of the head, so this draws a white pixel at the current head position. As only the head and the tail of the snake move, this is enough to keep the snake moving.": "Als nächstes kommt <tt>drawSnake</tt>. Dies ist auch ziemlich einfach - wir löschen zuerst den Schwanz und zeichnen dann den Kopf. <tt>X</tt> wird auf die Länge der Schlange gesetzt, damit wir zum richtigen Pixel indexieren können, und wir setzen <tt>A</tt> auf Null und führen dann das Schreiben mit dem indizierten indirekten Adressierungsmodus durch. Dann laden wir <tt>X</tt> neu, um zum Kopf zu indexieren, setzen <tt>A</tt> auf eins und speichern es in <tt>($10,x)</tt>. <tt>$10</tt> speichert die zweibyte-Position des Kopfes, also zeichnet dies einen weißen Pixel an der aktuellen Kopfposition. Da sich nur der Kopf und der Schwanz der Schlange bewegen, reicht dies aus, um die Schlange in Bewegung zu halten.",
  "The last subroutine, <tt>spinWheels</tt>, is just there because the game would run too fast otherwise. All <tt>spinWheels</tt> does is count <tt>X</tt> down from zero until it hits zero again. The first <tt>dex</tt> wraps, making <tt>X</tt> <tt>#$ff</tt>.": "Das letzte Unterprogramm, <tt>spinWheels</tt>, ist nur da, weil das Spiel sonst zu schnell laufen würde. Alles, was <tt>spinWheels</tt> tut, ist <tt>X</tt> von Null herunterzuzählen, bis es wieder Null erreicht. Das erste <tt>dex</tt> überläuft, wodurch <tt>X</tt> zu <tt>#$ff</tt> wird.",
  "app.name": "Lerne 6502 Assembler"
}