#!/usr/bin/env -S gjs -m
import GLib from "gi://GLib?version=2.0";
import { programInvocationName, exit } from "system";
import GObject from "gi://GObject?version=2.0";
import Gio from "gi://Gio?version=2.0";
import Gdk from "gi://Gdk?version=4.0";
import Gtk from "gi://Gtk?version=4.0";
import Adw from "gi://Adw?version=1";
import GtkSource from "gi://GtkSource?version=5";
const APPLICATION_ID = "eu.jumplink.Easy6502";
const RESOURCES_PATH = "/" + APPLICATION_ID.replaceAll(".", "/");
const VERSION = "0.0.1";
const PREFIX = "/home/jumplink/Projekte/easy6502/packages/app-gnome";
const LIBDIR = "/home/jumplink/Projekte/easy6502/packages/app-gnome/lib";
const DATADIR = "/home/jumplink/Projekte/easy6502/packages/app-gnome/data";
const rootDir = Gio.File.new_for_uri(
  import.meta.url
).resolve_relative_path("../..");
const findIdsInXml = (prefix, xmlString) => {
  const regex = new RegExp(`id="${prefix}(\\d+)"`, "g");
  const result = [];
  let match;
  while ((match = regex.exec(xmlString)) !== null) {
    result.push(`${prefix}${match[1]}`);
  }
  return result;
};
const Template$d = '<?xml version="1.0" encoding="UTF-8"?><interface><requires lib="gtk" version="4.0"></requires><template class="Tutorial" parent="AdwBin"><property name="vexpand">true</property><property name="vexpand-set">true</property><child><object class="GtkBox"><property name="orientation">1</property><property name="vexpand">true</property><property name="vexpand-set">true</property><child><object class="GtkLabel"><property name="label" translatable="true">Tutorial &lt;sub&gt;by &lt;a href=&quot;https://www.skilldrick.co.uk/&quot;&gt;Nick Morgan&lt;/a&gt;, licensed under CC BY 4.0&lt;/sub&gt;</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-1"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Introduction</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-2"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">In this tiny tutorial I&apos;m going to show you how to get started writing 6502 assembly language. The 6502 processor was massive in the seventies and eighties, powering famous computers like the &lt;a href=&quot;http://en.wikipedia.org/wiki/BBC_Micro&quot;&gt;BBC Micro&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Atari_2600&quot;&gt;Atari 2600&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Commodore_64&quot;&gt;Commodore 64&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Apple_II&quot;&gt;Apple II&lt;/a&gt;, and the &lt;a href=&quot;http://en.wikipedia.org/wiki/Nintendo_Entertainment_System&quot;&gt;Nintendo Entertainment System&lt;/a&gt;. Bender in Futurama &lt;a href=&quot;http://www.transbyte.org/SID/SID-files/Bender_6502.jpg&quot;&gt;has a 6502 processor for a brain&lt;/a&gt;. &lt;a href=&quot;http://www.pagetable.com/docs/terminator/00-37-23.jpg&quot;&gt;Even the Terminator was programmed in 6502&lt;/a&gt;.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">So, why would you want to learn 6502? It&apos;s a dead language isn&apos;t it? Well, so&apos;s Latin. And they still teach that. &lt;a href=&quot;http://en.wikipedia.org/wiki/Q.E.D.&quot;&gt;Q.E.D.&lt;/a&gt;</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">(Actually, I&apos;ve been reliably informed that 6502 processors are still being produced by &lt;a href=&quot;http://www.westerndesigncenter.com/wdc/w65c02s-chip.cfm&quot;&gt;Western Design Center&lt;/a&gt; and &lt;a href=&quot;http://www.mouser.co.uk/Search/Refine.aspx?Keyword=65C02&quot;&gt;sold to hobbyists&lt;/a&gt;, so clearly 6502 isn&apos;t a dead language! Who knew?)</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Seriously though, I think it&apos;s valuable to have an understanding of assembly language. Assembly language is the lowest level of abstraction in computers - the point at which the code is still readable. Assembly language translates directly to the bytes that are executed by your computer&apos;s processor. If you understand how it works, you&apos;ve basically become a computer &lt;a href=&quot;http://skilldrick.co.uk/2011/04/magic-in-software-development/&quot;&gt;magician&lt;/a&gt;.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Then why 6502? Why not a useful assembly language, like &lt;a href=&quot;http://en.wikipedia.org/wiki/X86&quot;&gt;x86&lt;/a&gt;? Well, I don&apos;t think learning x86 is useful. I don&apos;t think you&apos;ll ever have to write assembly language in your day job - this is purely an academic exercise, something to expand your mind and your thinking. 6502 was originally written in a different age, a time when the majority of developers were writing assembly directly, rather than in these new-fangled high-level programming languages. So, it was designed to be written by humans. More modern assembly languages are meant to written by compilers, so let&apos;s leave it to them. Plus, 6502 is fun. Nobody ever called x86 fun.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Our first program</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-2"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">So, let&apos;s dive in! That thing below is a little &lt;a href=&quot;https://github.com/skilldrick/6502js&quot;&gt;JavaScript 6502 assembler and simulator&lt;/a&gt; that I adapted for this interactive tutorial. Click the &lt;b&gt;Copy to editor&lt;/b&gt; button to copy the code to the code editor and assemble and run the snippet of assembly language.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="ExecutableSourceView" id="executableSourceView0"><property name="code">LDA #$01\nSTA $0200\nLDA #$05\nSTA $0201\nLDA #$08\nSTA $0202</property><property name="language">6502-assembler</property><property name="line-numbers">true</property><property name="fit-content-height">true</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">The black game console screen now should show three coloured &quot;pixels&quot; at the top left.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">So, what&apos;s this program actually doing? Let&apos;s step through it with the debugger. Hit &lt;b&gt;Reset&lt;/b&gt;, then check the &lt;b&gt;Debugger&lt;/b&gt; checkbox to start the debugger. Click &lt;b&gt;Step&lt;/b&gt; once. If you were watching carefully, you&apos;ll have noticed that &lt;tt&gt;A=&lt;/tt&gt; changed from &lt;tt&gt;$00&lt;/tt&gt; to &lt;tt&gt;$01&lt;/tt&gt;, and &lt;tt&gt;PC=&lt;/tt&gt; changed from &lt;tt&gt;$0600&lt;/tt&gt; to &lt;tt&gt;$0602&lt;/tt&gt;.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Any numbers prefixed with &lt;tt&gt;$&lt;/tt&gt; in 6502 assembly language (and by extension, in this book) are in hexadecimal (hex) format. If you&apos;re not familiar with hex numbers, I recommend you read &lt;a href=&quot;http://en.wikipedia.org/wiki/Hexadecimal&quot;&gt;the Wikipedia article&lt;/a&gt;. Anything prefixed with &lt;tt&gt;#&lt;/tt&gt; is a literal number value. Any other number refers to a memory location.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Equipped with that knowledge, you should be able to see that the instruction &lt;tt&gt;LDA #$01&lt;/tt&gt; loads the hex value &lt;tt&gt;$01&lt;/tt&gt; into register &lt;tt&gt;A&lt;/tt&gt;. I&apos;ll go into more detail on registers in the next section.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Press &lt;b&gt;Step&lt;/b&gt; again to execute the second instruction. The top-left pixel of the simulator display should now be white. This simulator uses the memory locations &lt;tt&gt;$0200&lt;/tt&gt; to &lt;tt&gt;$05ff&lt;/tt&gt; to draw pixels on its display. The values &lt;tt&gt;$00&lt;/tt&gt; to &lt;tt&gt;$0f&lt;/tt&gt; represent 16 different colours (&lt;tt&gt;$00&lt;/tt&gt; is black and &lt;tt&gt;$01&lt;/tt&gt; is white), so storing the value &lt;tt&gt;$01&lt;/tt&gt; at memory location &lt;tt&gt;$0200&lt;/tt&gt; draws a white pixel at the top left corner. This is simpler than how an actual computer would output video, but it&apos;ll do for now.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">So, the instruction &lt;tt&gt;STA $0200&lt;/tt&gt; stores the value of the &lt;tt&gt;A&lt;/tt&gt; register to memory location &lt;tt&gt;$0200&lt;/tt&gt;. Click &lt;b&gt;Step&lt;/b&gt; four more times to execute the rest of the instructions, keeping an eye on the &lt;tt&gt;A&lt;/tt&gt; register as it changes.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Exercises</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-3"></class></style></object></child>\n<child><object class="GtkBox"><property name="orientation">1</property><property name="margin-start">24</property><child><object class="GtkBox"><property name="orientation">0</property><child><object class="GtkLabel"><property name="use-markup">true</property><property name="wrap">true</property><property name="xalign">0</property><property name="valign">1</property><property name="label">1. </property></object></child><child><object class="GtkLabel"><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="xalign">0</property><property name="halign">0</property><property name="label">Try changing the colour of the three pixels.</property></object></child></object></child><child><object class="GtkBox"><property name="orientation">0</property><child><object class="GtkLabel"><property name="use-markup">true</property><property name="wrap">true</property><property name="xalign">0</property><property name="valign">1</property><property name="label">2. </property></object></child><child><object class="GtkLabel"><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="xalign">0</property><property name="halign">0</property><property name="label">Change one of the pixels to draw at the bottom-right corner (memory location &lt;tt&gt;$05ff&lt;/tt&gt;).</property></object></child></object></child><child><object class="GtkBox"><property name="orientation">0</property><child><object class="GtkLabel"><property name="use-markup">true</property><property name="wrap">true</property><property name="xalign">0</property><property name="valign">1</property><property name="label">3. </property></object></child><child><object class="GtkLabel"><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="xalign">0</property><property name="halign">0</property><property name="label">Add more instructions to draw extra pixels.</property></object></child></object></child></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Registers and flags</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-2"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">We&apos;ve already had a little look at the processor status section (the bit with &lt;tt&gt;A&lt;/tt&gt;, &lt;tt&gt;PC&lt;/tt&gt; etc.), but what does it all mean?</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">The first line shows the &lt;tt&gt;A&lt;/tt&gt;, &lt;tt&gt;X&lt;/tt&gt; and &lt;tt&gt;Y&lt;/tt&gt; registers (&lt;tt&gt;A&lt;/tt&gt; is often called the &quot;accumulator&quot;). Each register holds a single byte. Most operations work on the contents of these registers.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">&lt;tt&gt;SP&lt;/tt&gt; is the stack pointer. I won&apos;t get into the stack yet, but basically this register is decremented every time a byte is pushed onto the stack, and incremented when a byte is popped off the stack.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">&lt;tt&gt;PC&lt;/tt&gt; is the program counter - it&apos;s how the processor knows at what point in the program it currently is. It&apos;s like the current line number of an executing script. In the JavaScript simulator the code is assembled starting at memory location &lt;tt&gt;$0600&lt;/tt&gt;, so &lt;tt&gt;PC&lt;/tt&gt; always starts there.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">The last section shows the processor flags. Each flag is one bit, so all seven flags live in a single byte. The flags are set by the processor to give information about the previous instruction. More on that later. &lt;a href=&quot;https://web.archive.org/web/20210626024532/http://www.obelisk.me.uk/6502/registers.html&quot;&gt;Read more about the registers and flags here&lt;/a&gt;.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Instructions</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-2"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Instructions in assembly language are like a small set of predefined functions. All instructions take zero or one arguments. Here&apos;s some annotated source code to introduce a few different instructions:</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="ExecutableSourceView" id="executableSourceView1"><property name="code">LDA #$c0  ;Load the hex value $c0 into the A register\nTAX       ;Transfer the value in the A register to X\nINX       ;Increment the value in the X register\nADC #$c4  ;Add the hex value $c4 to the A register\nBRK       ;Break - we&apos;re done</property><property name="language">6502-assembler</property><property name="line-numbers">true</property><property name="fit-content-height">true</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Assemble the code, then turn on the debugger and step through the code, watching the &lt;tt&gt;A&lt;/tt&gt; and &lt;tt&gt;X&lt;/tt&gt; registers. Something slightly odd happens on the line &lt;tt&gt;ADC #$c4&lt;/tt&gt;. You might expect that adding &lt;tt&gt;$c4&lt;/tt&gt; to &lt;tt&gt;$c0&lt;/tt&gt; would give &lt;tt&gt;$184&lt;/tt&gt;, but this processor gives the result as &lt;tt&gt;$84&lt;/tt&gt;. What&apos;s up with that?</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">The problem is, &lt;tt&gt;$184&lt;/tt&gt; is too big to fit in a single byte (the max is &lt;tt&gt;$FF&lt;/tt&gt;), and the registers can only hold a single byte. It&apos;s OK though; the processor isn&apos;t actually dumb. If you were looking carefully enough, you&apos;ll have noticed that the carry flag was set to &lt;tt&gt;1&lt;/tt&gt; after this operation. So that&apos;s how you know.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">In the simulator below &lt;b&gt;type&lt;/b&gt; (don&apos;t paste) the following code:</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="ExecutableSourceView" id="executableSourceView2"><property name="code">LDA #$80\nSTA $01\nADC $01</property><property name="language">6502-assembler</property><property name="readonly">true</property><property name="unselectable">true</property><property name="line-numbers">true</property><property name="fit-content-height">true</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">An important thing to notice here is the distinction between &lt;tt&gt;ADC #$01&lt;/tt&gt; and &lt;tt&gt;ADC $01&lt;/tt&gt;. The first one adds the value &lt;tt&gt;$01&lt;/tt&gt; to the &lt;tt&gt;A&lt;/tt&gt; register, but the second adds the value stored at memory location &lt;tt&gt;$01&lt;/tt&gt; to the &lt;tt&gt;A&lt;/tt&gt; register.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Assemble, check the &lt;b&gt;Monitor&lt;/b&gt; checkbox, then step through these three instructions. The monitor shows a section of memory, and can be helpful to visualise the execution of programs. &lt;tt&gt;STA $01&lt;/tt&gt; stores the value of the &lt;tt&gt;A&lt;/tt&gt; register at memory location &lt;tt&gt;$01&lt;/tt&gt;, and &lt;tt&gt;ADC $01&lt;/tt&gt; adds the value stored at the memory location &lt;tt&gt;$01&lt;/tt&gt; to the &lt;tt&gt;A&lt;/tt&gt; register. &lt;tt&gt;$80 + $80&lt;/tt&gt; should equal &lt;tt&gt;$100&lt;/tt&gt;, but because this is bigger than a byte, the &lt;tt&gt;A&lt;/tt&gt; register is set to &lt;tt&gt;$00&lt;/tt&gt; and the carry flag is set. As well as this though, the zero flag is set. The zero flag is set by all instructions where the result is zero.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">A full list of the 6502 instruction set is &lt;a href=&quot;http://www.6502.org/tutorials/6502opcodes.html&quot;&gt;available here&lt;/a&gt; and &lt;a href=&quot;http://www.obelisk.me.uk/6502/reference.html&quot;&gt;here&lt;/a&gt; (I usually refer to both pages as they have their strengths and weaknesses). These pages detail the arguments to each instruction, which registers they use, and which flags they set. They are your bible.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Exercises</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-3"></class></style></object></child>\n<child><object class="GtkBox"><property name="orientation">1</property><property name="margin-start">24</property><child><object class="GtkBox"><property name="orientation">0</property><child><object class="GtkLabel"><property name="use-markup">true</property><property name="wrap">true</property><property name="xalign">0</property><property name="valign">1</property><property name="label">1. </property></object></child><child><object class="GtkLabel"><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="xalign">0</property><property name="halign">0</property><property name="label">You&apos;ve seen &lt;tt&gt;TAX&lt;/tt&gt;. You can probably guess what &lt;tt&gt;TAY&lt;/tt&gt;, &lt;tt&gt;TXA&lt;/tt&gt; and &lt;tt&gt;TYA&lt;/tt&gt; do, but write some code to test your assumptions.</property></object></child></object></child><child><object class="GtkBox"><property name="orientation">0</property><child><object class="GtkLabel"><property name="use-markup">true</property><property name="wrap">true</property><property name="xalign">0</property><property name="valign">1</property><property name="label">2. </property></object></child><child><object class="GtkLabel"><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="xalign">0</property><property name="halign">0</property><property name="label">Rewrite the first example in this section to use the &lt;tt&gt;Y&lt;/tt&gt; register instead of the &lt;tt&gt;X&lt;/tt&gt; register.</property></object></child></object></child><child><object class="GtkBox"><property name="orientation">0</property><child><object class="GtkLabel"><property name="use-markup">true</property><property name="wrap">true</property><property name="xalign">0</property><property name="valign">1</property><property name="label">3. </property></object></child><child><object class="GtkLabel"><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="xalign">0</property><property name="halign">0</property><property name="label">The opposite of &lt;tt&gt;ADC&lt;/tt&gt; is &lt;tt&gt;SBC&lt;/tt&gt; (subtract with carry). Write a program that uses this instruction.</property></object></child></object></child></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Branching</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-2"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">So far we&apos;re only able to write basic programs without any branching logic. Let&apos;s change that.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">6502 assembly language has a bunch of branching instructions, all of which branch based on whether certain flags are set or not. In this example we&apos;ll be looking at &lt;tt&gt;BNE&lt;/tt&gt;: &quot;Branch on not equal&quot;.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="ExecutableSourceView" id="executableSourceView3"><property name="code">LDX #$08\ndecrement:\n  DEX\n  STX $0200\n  CPX #$03\n  BNE decrement\n  STX $0201\n  BRK</property><property name="language">6502-assembler</property><property name="line-numbers">true</property><property name="fit-content-height">true</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">First we load the value &lt;tt&gt;$08&lt;/tt&gt; into the &lt;tt&gt;X&lt;/tt&gt; register. The next line is a label. Labels just mark certain points in a program so we can return to them later. After the label we decrement &lt;tt&gt;X&lt;/tt&gt;, store it to &lt;tt&gt;$0200&lt;/tt&gt; (the top-left pixel), and then compare it to the value &lt;tt&gt;$03&lt;/tt&gt;. &lt;a href=&quot;http://www.obelisk.me.uk/6502/reference.html#CPX&quot;&gt;&lt;tt&gt;CPX&lt;/tt&gt;&lt;/a&gt; compares the value in the &lt;tt&gt;X&lt;/tt&gt; register with another value. If the two values are equal, the &lt;tt&gt;Z&lt;/tt&gt; flag is set to &lt;tt&gt;1&lt;/tt&gt;, otherwise it is set to &lt;tt&gt;0&lt;/tt&gt;.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">The next line, &lt;tt&gt;BNE decrement&lt;/tt&gt;, will shift execution to the decrement label if the &lt;tt&gt;Z&lt;/tt&gt; flag is set to &lt;tt&gt;0&lt;/tt&gt; (meaning that the two values in the &lt;tt&gt;CPX&lt;/tt&gt; comparison were not equal), otherwise it does nothing and we store &lt;tt&gt;X&lt;/tt&gt; to &lt;tt&gt;$0201&lt;/tt&gt;, then finish the program.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">In assembly language, you&apos;ll usually use labels with branch instructions. When assembled though, this label is converted to a single-byte relative offset (a number of bytes to go backwards or forwards from the next instruction) so branch instructions can only go forward and back around 256 bytes. This means they can only be used to move around local code. For moving further you&apos;ll need to use the jumping instructions.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Exercises</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-3"></class></style></object></child>\n<child><object class="GtkBox"><property name="orientation">1</property><property name="margin-start">24</property><child><object class="GtkBox"><property name="orientation">0</property><child><object class="GtkLabel"><property name="use-markup">true</property><property name="wrap">true</property><property name="xalign">0</property><property name="valign">1</property><property name="label">1. </property></object></child><child><object class="GtkLabel"><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="xalign">0</property><property name="halign">0</property><property name="label">The opposite of &lt;tt&gt;BNE&lt;/tt&gt; is &lt;tt&gt;BEQ&lt;/tt&gt;. Try writing a program that uses &lt;tt&gt;BEQ&lt;/tt&gt;.</property></object></child></object></child><child><object class="GtkBox"><property name="orientation">0</property><child><object class="GtkLabel"><property name="use-markup">true</property><property name="wrap">true</property><property name="xalign">0</property><property name="valign">1</property><property name="label">2. </property></object></child><child><object class="GtkLabel"><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="xalign">0</property><property name="halign">0</property><property name="label">&lt;tt&gt;BCC&lt;/tt&gt; and &lt;tt&gt;BCS&lt;/tt&gt; (&quot;branch on carry clear&quot; and &quot;branch on carry set&quot;) are used to branch on the carry flag. Write a program that uses one of these two.</property></object></child></object></child></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Addressing modes</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-2"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">The 6502 uses a 16-bit address bus, meaning that there are 65536 bytes of memory available to the processor. Remember that a byte is represented by two hex characters, so the memory locations are generally represented as &lt;tt&gt;$0000 - $ffff&lt;/tt&gt;. There are various ways to refer to these memory locations, as detailed below.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">With all these examples you might find it helpful to use the memory monitor to watch the memory change. The monitor takes a starting memory location and a number of bytes to display from that location. Both of these are hex values. For example, to display 16 bytes of memory from &lt;tt&gt;$c000&lt;/tt&gt;, enter &lt;tt&gt;c000&lt;/tt&gt; and &lt;tt&gt;10&lt;/tt&gt; into &lt;b&gt;Start&lt;/b&gt; and &lt;b&gt;Length&lt;/b&gt;, respectively.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Absolute: &lt;tt&gt;$c000&lt;/tt&gt;</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-3"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">With absolute addressing, the full memory location is used as the argument to the instruction. For example:</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">STA $c000 ;Store the value in the accumulator at memory location $c000</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Zero page: &lt;tt&gt;$c0&lt;/tt&gt;</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-3"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">All instructions that support absolute addressing (with the exception of the jump instructions) also have the option to take a single-byte address. This type of addressing is called &quot;zero page&quot; - only the first page (the first 256 bytes) of memory is accessible. This is faster, as only one byte needs to be looked up, and takes up less space in the assembled code as well.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Zero page,X: &lt;tt&gt;$c0,X&lt;/tt&gt;</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-3"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">This is where addressing gets interesting. In this mode, a zero page address is given, and then the value of the &lt;tt&gt;X&lt;/tt&gt; register is added. Here is an example:</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="ExecutableSourceView" id="executableSourceView4"><property name="code">LDX #$01   ;X is $01\nLDA #$aa   ;A is $aa\nSTA $a0,X ;Store the value of A at memory location $a1\nINX        ;Increment X\nSTA $a0,X ;Store the value of A at memory location $a2</property><property name="language">6502-assembler</property><property name="readonly">true</property><property name="line-numbers">true</property><property name="fit-content-height">true</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">If the result of the addition is larger than a single byte, the address wraps around. For example:</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="ExecutableSourceView" id="executableSourceView5"><property name="code">LDX #$05\nSTA $ff,X ;Store the value of A at memory location $04</property><property name="language">6502-assembler</property><property name="readonly">true</property><property name="line-numbers">true</property><property name="fit-content-height">true</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Zero page,Y: &lt;tt&gt;$c0,Y&lt;/tt&gt;</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-3"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">This is the equivalent of zero page,X, but can only be used with &lt;tt&gt;LDX&lt;/tt&gt; and &lt;tt&gt;STX&lt;/tt&gt;.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Absolute,X and absolute,Y: &lt;tt&gt;$c000,X&lt;/tt&gt; and &lt;tt&gt;$c000,Y&lt;/tt&gt;</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-3"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">These are the absolute addressing versions of zero page,X and zero page,Y. For example:</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="ExecutableSourceView" id="executableSourceView6"><property name="code">LDX #$01\nSTA $0200,X ;Store the value of A at memory location $0201</property><property name="language">6502-assembler</property><property name="readonly">true</property><property name="line-numbers">true</property><property name="fit-content-height">true</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Unlike zero page,Y, absolute,Y can&apos;t be used with &lt;tt&gt;STX&lt;/tt&gt; but can be used with &lt;tt&gt;LDA&lt;/tt&gt; and &lt;tt&gt;STA&lt;/tt&gt;.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Immediate: &lt;tt&gt;#$c0&lt;/tt&gt;</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-3"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Immediate addressing doesn&apos;t strictly deal with memory addresses - this is the mode where actual values are used. For example, &lt;tt&gt;LDX #$01&lt;/tt&gt; loads the value &lt;tt&gt;$01&lt;/tt&gt; into the &lt;tt&gt;X&lt;/tt&gt; register. This is very different to the zero page instruction &lt;tt&gt;LDX $01&lt;/tt&gt; which loads the value at memory location &lt;tt&gt;$01&lt;/tt&gt; into the &lt;tt&gt;X&lt;/tt&gt; register.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Relative: &lt;tt&gt;$c0&lt;/tt&gt; (or label)</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-3"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Relative addressing is used for branching instructions. These instructions take a single byte, which is used as an offset from the following instruction.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Assemble the following code, then click the &lt;b&gt;Hexdump&lt;/b&gt; button to see the assembled code.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="ExecutableSourceView" id="executableSourceView7"><property name="code">LDA #$01\nCMP #$02\nBNE notequal\nSTA $22\nnotequal:\n  BRK</property><property name="language">6502-assembler</property><property name="line-numbers">true</property><property name="fit-content-height">true</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">The hex should look something like this:</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="ExecutableSourceView" id="executableSourceView8"><property name="code">a9 01 c9 02 d0 02 85 22 00</property><property name="language">hex</property><property name="readonly">true</property><property name="line-numbers">true</property><property name="fit-content-height">true</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">&lt;tt&gt;a9&lt;/tt&gt; and &lt;tt&gt;c9&lt;/tt&gt; are the processor opcodes for immediate-addressed &lt;tt&gt;LDA&lt;/tt&gt; and &lt;tt&gt;CMP&lt;/tt&gt; respectively. &lt;tt&gt;01&lt;/tt&gt; and &lt;tt&gt;02&lt;/tt&gt; are the arguments to these instructions. &lt;tt&gt;d0&lt;/tt&gt; is the opcode for &lt;tt&gt;BNE&lt;/tt&gt;, and its argument is &lt;tt&gt;02&lt;/tt&gt;. This means &quot;skip over the next two bytes&quot; (&lt;tt&gt;85 22&lt;/tt&gt;, the assembled version of &lt;tt&gt;STA $22&lt;/tt&gt;). Try editing the code so &lt;tt&gt;STA&lt;/tt&gt; takes a two-byte absolute address rather than a single-byte zero page address (e.g. change &lt;tt&gt;STA $22&lt;/tt&gt; to &lt;tt&gt;STA $2222&lt;/tt&gt;). Reassemble the code and look at the hexdump again - the argument to &lt;tt&gt;BNE&lt;/tt&gt; should now be &lt;tt&gt;03&lt;/tt&gt;, because the instruction the processor is skipping past is now three bytes long.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Implicit</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-3"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Some instructions don&apos;t deal with memory locations (e.g. &lt;tt&gt;INX&lt;/tt&gt; - increment the &lt;tt&gt;X&lt;/tt&gt; register). These are said to have implicit addressing - the argument is implied by the instruction.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Indirect: &lt;tt&gt;($c000)&lt;/tt&gt;</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-3"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Indirect addressing uses an absolute address to look up another address. The first address gives the least significant byte of the address, and the following byte gives the most significant byte. That can be hard to wrap your head around, so here&apos;s an example:</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="ExecutableSourceView" id="executableSourceView9"><property name="code">LDA #$01\nSTA $f0\nLDA #$cc\nSTA $f1\nJMP ($00f0) ;dereferences to $cc01</property><property name="language">6502-assembler</property><property name="line-numbers">true</property><property name="fit-content-height">true</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">In this example, &lt;tt&gt;$f0&lt;/tt&gt; contains the value &lt;tt&gt;$01&lt;/tt&gt; and &lt;tt&gt;$f1&lt;/tt&gt; contains the value &lt;tt&gt;$cc&lt;/tt&gt;. The instruction &lt;tt&gt;JMP ($f0)&lt;/tt&gt; causes the processor to look up the two bytes at &lt;tt&gt;$f0&lt;/tt&gt; and &lt;tt&gt;$f1&lt;/tt&gt; (&lt;tt&gt;$01&lt;/tt&gt; and &lt;tt&gt;$cc&lt;/tt&gt;) and put them together to form the address &lt;tt&gt;$cc01&lt;/tt&gt;, which becomes the new program counter. Assemble and step through the program above to see what happens. I&apos;ll talk more about &lt;tt&gt;JMP&lt;/tt&gt; in the section on &lt;a href=&quot;#jumping&quot;&gt;Jumping&lt;/a&gt;.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Indexed indirect: &lt;tt&gt;($c0,X)&lt;/tt&gt;</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-3"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">This one&apos;s kinda weird. It&apos;s like a cross between zero page,X and indirect. Basically, you take the zero page address, add the value of the &lt;tt&gt;X&lt;/tt&gt; register to it, then use that to look up a two-byte address. For example:</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="ExecutableSourceView" id="executableSourceView10"><property name="code">LDX #$01\nLDA #$05\nSTA $01\nLDA #$07\nSTA $02\nLDY #$0a\nSTY $0705\nLDA ($00,X)</property><property name="language">6502-assembler</property><property name="line-numbers">true</property><property name="fit-content-height">true</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Memory locations &lt;tt&gt;$01&lt;/tt&gt; and &lt;tt&gt;$02&lt;/tt&gt; contain the values &lt;tt&gt;$05&lt;/tt&gt; and &lt;tt&gt;$07&lt;/tt&gt; respectively. Think of &lt;tt&gt;($00,X)&lt;/tt&gt; as &lt;tt&gt;($00 + X)&lt;/tt&gt;. In this case &lt;tt&gt;X&lt;/tt&gt; is &lt;tt&gt;$01&lt;/tt&gt;, so this simplifies to &lt;tt&gt;($01)&lt;/tt&gt;. From here things proceed like standard indirect addressing - the two bytes at &lt;tt&gt;$01&lt;/tt&gt; and &lt;tt&gt;$02&lt;/tt&gt; (&lt;tt&gt;$05&lt;/tt&gt; and &lt;tt&gt;$07&lt;/tt&gt;) are looked up to form the address &lt;tt&gt;$0705&lt;/tt&gt;. This is the address that the &lt;tt&gt;Y&lt;/tt&gt; register was stored into in the previous instruction, so the &lt;tt&gt;A&lt;/tt&gt; register gets the same value as &lt;tt&gt;Y&lt;/tt&gt;, albeit through a much more circuitous route. You won&apos;t see this much.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Indirect indexed: &lt;tt&gt;($c0),Y&lt;/tt&gt;</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-3"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Indirect indexed is like indexed indirect but less insane. Instead of adding the &lt;tt&gt;X&lt;/tt&gt; register to the address before dereferencing, the zero page address is dereferenced, and the &lt;tt&gt;Y&lt;/tt&gt; register is added to the resulting address.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="ExecutableSourceView" id="executableSourceView11"><property name="code">LDY #$01\nLDA #$03\nSTA $01\nLDA #$07\nSTA $02\nLDX #$0a\nSTX $0704\nLDA ($01),Y</property><property name="language">6502-assembler</property><property name="line-numbers">true</property><property name="fit-content-height">true</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">In this case, &lt;tt&gt;($01)&lt;/tt&gt; looks up the two bytes at &lt;tt&gt;$01&lt;/tt&gt; and &lt;tt&gt;$02&lt;/tt&gt;: &lt;tt&gt;$03&lt;/tt&gt; and &lt;tt&gt;$07&lt;/tt&gt;. These form the address &lt;tt&gt;$0703&lt;/tt&gt;. The value of the &lt;tt&gt;Y&lt;/tt&gt; register is added to this address to give the final address &lt;tt&gt;$0704&lt;/tt&gt;.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Exercise</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-3"></class></style></object></child>\n<child><object class="GtkBox"><property name="orientation">1</property><property name="margin-start">24</property><child><object class="GtkBox"><property name="orientation">0</property><child><object class="GtkLabel"><property name="use-markup">true</property><property name="wrap">true</property><property name="xalign">0</property><property name="valign">1</property><property name="label">1. </property></object></child><child><object class="GtkLabel"><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="xalign">0</property><property name="halign">0</property><property name="label">Try to write code snippets that use each of the 6502 addressing modes. Remember, you can use the monitor to watch a section of memory.</property></object></child></object></child></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">The stack</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-2"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">The stack in a 6502 processor is just like any other stack - values are pushed onto it and popped (&quot;pulled&quot; in 6502 parlance) off it. The current depth of the stack is measured by the stack pointer, a special register. The stack lives in memory between &lt;tt&gt;$0100&lt;/tt&gt; and &lt;tt&gt;$01ff&lt;/tt&gt;. The stack pointer is initially &lt;tt&gt;$ff&lt;/tt&gt;, which points to memory location &lt;tt&gt;$01ff&lt;/tt&gt;. When a byte is pushed onto the stack, the stack pointer becomes &lt;tt&gt;$fe&lt;/tt&gt;, or memory location &lt;tt&gt;$01fe&lt;/tt&gt;, and so on.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Two of the stack instructions are &lt;tt&gt;PHA&lt;/tt&gt; and &lt;tt&gt;PLA&lt;/tt&gt;, &quot;push accumulator&quot; and &quot;pull accumulator&quot;. Below is an example of these two in action.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="ExecutableSourceView" id="executableSourceView12"><property name="code">LDX #$00\nLDY #$00\nfirstloop:\n  TXA\n  STA $0200,Y\n  PHA\n  INX\n  INY\n  CPY #$10\n  BNE firstloop ;loop until Y is $10\nsecondloop:\n  PLA\n  STA $0200,Y\n  INY\n  CPY #$20      ;loop until Y is $20\n  BNE secondloop</property><property name="language">6502-assembler</property><property name="line-numbers">true</property><property name="fit-content-height">true</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">&lt;tt&gt;X&lt;/tt&gt; holds the pixel colour, and &lt;tt&gt;Y&lt;/tt&gt; holds the position of the current pixel. The first loop draws the current colour as a pixel (via the &lt;tt&gt;A&lt;/tt&gt; register), pushes the colour to the stack, then increments the colour and position. The second loop pops the stack, draws the popped colour as a pixel, then increments the position. As should be expected, this creates a mirrored pattern.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Jumping</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-2"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Jumping is like branching with two main differences. First, jumps are not conditionally executed, and second, they take a two-byte absolute address. For small programs, this second detail isn&apos;t very important, as you&apos;ll mostly be using labels, and the assembler works out the correct memory location from the label. For larger programs though, jumping is the only way to move from one section of the code to another.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">JMP</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-3"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">&lt;tt&gt;JMP&lt;/tt&gt; is an unconditional jump. Here&apos;s a really simple example to show it in action:</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="ExecutableSourceView" id="executableSourceView13"><property name="code">LDA #$03\nJMP there\nBRK\nBRK\nBRK\nthere:\n  STA $0200</property><property name="language">6502-assembler</property><property name="line-numbers">true</property><property name="fit-content-height">true</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">JSR/RTS</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-3"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">&lt;tt&gt;JSR&lt;/tt&gt; and &lt;tt&gt;RTS&lt;/tt&gt; (&quot;jump to subroutine&quot; and &quot;return from subroutine&quot;) are a dynamic duo that you&apos;ll usually see used together. &lt;tt&gt;JSR&lt;/tt&gt; is used to jump from the current location to another part of the code. &lt;tt&gt;RTS&lt;/tt&gt; returns to the previous position. This is basically like calling a function and returning.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">The processor knows where to return to because &lt;tt&gt;JSR&lt;/tt&gt; pushes the address minus one of the next instruction onto the stack before jumping to the given location. &lt;tt&gt;RTS&lt;/tt&gt; pops this location, adds one to it, and jumps to that location. An example:</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="ExecutableSourceView" id="executableSourceView14"><property name="code">JSR init\nJSR loop\nJSR end\n\ninit:\n  LDX #$00\n  RTS\n\nloop:\n  INX\n  CPX #$05\n  BNE loop\n  RTS\n\nend:\n  BRK</property><property name="language">6502-assembler</property><property name="line-numbers">true</property><property name="fit-content-height">true</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">The first instruction causes execution to jump to the &lt;tt&gt;init&lt;/tt&gt; label. This sets &lt;tt&gt;X&lt;/tt&gt;, then returns to the next instruction, &lt;tt&gt;JSR loop&lt;/tt&gt;. This jumps to the &lt;tt&gt;loop&lt;/tt&gt; label, which increments &lt;tt&gt;X&lt;/tt&gt; until it is equal to &lt;tt&gt;$05&lt;/tt&gt;. After that we return to the next instruction, &lt;tt&gt;JSR end&lt;/tt&gt;, which jumps to the end of the file. This illustrates how &lt;tt&gt;JSR&lt;/tt&gt; and &lt;tt&gt;RTS&lt;/tt&gt; can be used together to create modular code.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Creating a game</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-2"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Now, let&apos;s put all this knowledge to good use, and make a game! We&apos;re going to be making a really simple version of the classic game &apos;Snake&apos;.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Even though this will be a simple version, the code will be substantially larger than all the previous examples. We will need to keep track of several memory locations together for the various aspects of the game. We can still do the necessary bookkeeping throughout the program ourselves, as before, but on a larger scale that quickly becomes tedious and can also lead to bugs that are difficult to spot. Instead we&apos;ll now let the assembler do some of the mundane work for us.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">In this assembler, we can define descriptive constants (or symbols) that represent numbers. The rest of the code can then simply use the constants instead of the literal number, which immediately makes it obvious what we&apos;re dealing with. You can use letters, digits and underscores in a name.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Here&apos;s an example. Note that immediate operands are still prefixed with a &lt;tt&gt;#&lt;/tt&gt;.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="ExecutableSourceView" id="executableSourceView15"><property name="code">  define  sysRandom  $fe ; an address\n  define  a_dozen    $0c ; a constant\n \n  LDA sysRandom  ; equivalent to &quot;LDA $fe&quot;\n\n  LDX #a_dozen   ; equivalent to &quot;LDX #$0c&quot;</property><property name="language">6502-assembler</property><property name="line-numbers">true</property><property name="fit-content-height">true</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">The simulator widget below contains the entire source code of the game. I&apos;ll explain how it works in the following sections.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">&lt;a href=&quot;https://twitter.com/wkjagt&quot;&gt;Willem van der Jagt&lt;/a&gt; made a &lt;a href=&quot;https://gist.github.com/wkjagt/9043907&quot;&gt;fully annotated gist of this source code&lt;/a&gt;, so follow along with that for more details.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="ExecutableSourceView" id="executableSourceView16"><property name="code">;  ___           _        __ ___  __ ___\n; / __|_ _  __ _| |_____ / /| __|/  \\_  )\n; \\__ \\ &apos; \\/ _` | / / -_) _ \\__ \\ () / /\n; |___/_||_\\__,_|_\\_\\___\\___/___/\\__/___|\n\n; Change direction: W A S D\n\ndefine appleL         $00 ; screen location of apple, low byte\ndefine appleH         $01 ; screen location of apple, high byte\ndefine snakeHeadL     $10 ; screen location of snake head, low byte\ndefine snakeHeadH     $11 ; screen location of snake head, high byte\ndefine snakeBodyStart $12 ; start of snake body byte pairs\ndefine snakeDirection $02 ; direction (possible values are below)\ndefine snakeLength    $03 ; snake length, in bytes\n\n; Directions (each using a separate bit)\ndefine movingUp      1\ndefine movingRight   2\ndefine movingDown    4\ndefine movingLeft    8\n\n; ASCII values of keys controlling the snake\ndefine ASCII_w      $77\ndefine ASCII_a      $61\ndefine ASCII_s      $73\ndefine ASCII_d      $64\n\n; System variables\ndefine sysRandom    $fe\ndefine sysLastKey   $ff\n\n\n  jsr init\n  jsr loop\n\ninit:\n  jsr initSnake\n  jsr generateApplePosition\n  rts\n\n\ninitSnake:\n  lda #movingRight  ;start direction\n  sta snakeDirection\n\n  lda #4  ;start length (2 segments)\n  sta snakeLength\n  \n  lda #$11\n  sta snakeHeadL\n  \n  lda #$10\n  sta snakeBodyStart\n  \n  lda #$0f\n  sta $14 ; body segment 1\n  \n  lda #$04\n  sta snakeHeadH\n  sta $13 ; body segment 1\n  sta $15 ; body segment 2\n  rts\n\n\ngenerateApplePosition:\n  ;load a new random byte into $00\n  lda sysRandom\n  sta appleL\n\n  ;load a new random number from 2 to 5 into $01\n  lda sysRandom\n  and #$03 ;mask out lowest 2 bits\n  clc\n  adc #2\n  sta appleH\n\n  rts\n\n\nloop:\n  jsr readKeys\n  jsr checkCollision\n  jsr updateSnake\n  jsr drawApple\n  jsr drawSnake\n  jsr spinWheels\n  jmp loop\n\n\nreadKeys:\n  lda sysLastKey\n  cmp #ASCII_w\n  beq upKey\n  cmp #ASCII_d\n  beq rightKey\n  cmp #ASCII_s\n  beq downKey\n  cmp #ASCII_a\n  beq leftKey\n  rts\nupKey:\n  lda #movingDown\n  bit snakeDirection\n  bne illegalMove\n\n  lda #movingUp\n  sta snakeDirection\n  rts\nrightKey:\n  lda #movingLeft\n  bit snakeDirection\n  bne illegalMove\n\n  lda #movingRight\n  sta snakeDirection\n  rts\ndownKey:\n  lda #movingUp\n  bit snakeDirection\n  bne illegalMove\n\n  lda #movingDown\n  sta snakeDirection\n  rts\nleftKey:\n  lda #movingRight\n  bit snakeDirection\n  bne illegalMove\n\n  lda #movingLeft\n  sta snakeDirection\n  rts\nillegalMove:\n  rts\n\n\ncheckCollision:\n  jsr checkAppleCollision\n  jsr checkSnakeCollision\n  rts\n\n\ncheckAppleCollision:\n  lda appleL\n  cmp snakeHeadL\n  bne doneCheckingAppleCollision\n  lda appleH\n  cmp snakeHeadH\n  bne doneCheckingAppleCollision\n\n  ;eat apple\n  inc snakeLength\n  inc snakeLength ;increase length\n  jsr generateApplePosition\ndoneCheckingAppleCollision:\n  rts\n\n\ncheckSnakeCollision:\n  ldx #2 ;start with second segment\nsnakeCollisionLoop:\n  lda snakeHeadL,x\n  cmp snakeHeadL\n  bne continueCollisionLoop\n\nmaybeCollided:\n  lda snakeHeadH,x\n  cmp snakeHeadH\n  beq didCollide\n\ncontinueCollisionLoop:\n  inx\n  inx\n  cpx snakeLength          ;got to last section with no collision\n  beq didntCollide\n  jmp snakeCollisionLoop\n\ndidCollide:\n  jmp gameOver\ndidntCollide:\n  rts\n\n\nupdateSnake:\n  ldx snakeLength\n  dex\n  txa\nupdateloop:\n  lda snakeHeadL,x\n  sta snakeBodyStart,x\n  dex\n  bpl updateloop\n\n  lda snakeDirection\n  lsr\n  bcs up\n  lsr\n  bcs right\n  lsr\n  bcs down\n  lsr\n  bcs left\nup:\n  lda snakeHeadL\n  sec\n  sbc #$20\n  sta snakeHeadL\n  bcc upup\n  rts\nupup:\n  dec snakeHeadH\n  lda #$1\n  cmp snakeHeadH\n  beq collision\n  rts\nright:\n  inc snakeHeadL\n  lda #$1f\n  bit snakeHeadL\n  beq collision\n  rts\ndown:\n  lda snakeHeadL\n  clc\n  adc #$20\n  sta snakeHeadL\n  bcs downdown\n  rts\ndowndown:\n  inc snakeHeadH\n  lda #$6\n  cmp snakeHeadH\n  beq collision\n  rts\nleft:\n  dec snakeHeadL\n  lda snakeHeadL\n  and #$1f\n  cmp #$1f\n  beq collision\n  rts\ncollision:\n  jmp gameOver\n\n\ndrawApple:\n  ldy #0\n  lda sysRandom\n  sta (appleL),y\n  rts\n\n\ndrawSnake:\n  ldx snakeLength\n  lda #0\n  sta (snakeHeadL,x) ; erase end of tail\n\n  ldx #0\n  lda #1\n  sta (snakeHeadL,x) ; paint head\n  rts\n\n\nspinWheels:\n  ldx #0\nspinloop:\n  nop\n  nop\n  dex\n  bne spinloop\n  rts\n\n\ngameOver:</property><property name="language">6502-assembler</property><property name="line-numbers">true</property><property name="height">600</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Overall structure</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-3"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">After the initial block of comments (lines starting with semicolons), the first two lines are:</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="ExecutableSourceView" id="executableSourceView17"><property name="code">jsr init\njsr loop</property><property name="language">6502-assembler</property><property name="readonly">true</property><property name="line-numbers">true</property><property name="fit-content-height">true</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">&lt;tt&gt;init&lt;/tt&gt; and &lt;tt&gt;loop&lt;/tt&gt; are both subroutines. &lt;tt&gt;init&lt;/tt&gt; initializes the game state, and &lt;tt&gt;loop&lt;/tt&gt; is the main game loop.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">The &lt;tt&gt;loop&lt;/tt&gt; subroutine itself just calls a number of subroutines sequentially, before looping back on itself:</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="ExecutableSourceView" id="executableSourceView18"><property name="code">loop:\n  jsr readkeys\n  jsr checkCollision\n  jsr updateSnake\n  jsr drawApple\n  jsr drawSnake\n  jsr spinwheels\n  jmp loop</property><property name="language">6502-assembler</property><property name="readonly">true</property><property name="line-numbers">true</property><property name="fit-content-height">true</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">First, &lt;tt&gt;readkeys&lt;/tt&gt; checks to see if one of the direction keys (W, A, S, D) was pressed, and if so, sets the direction of the snake accordingly. Then, &lt;tt&gt;checkCollision&lt;/tt&gt; checks to see if the snake collided with itself or the apple. &lt;tt&gt;updateSnake&lt;/tt&gt; updates the internal representation of the snake, based on its direction. Next, the apple and snake are drawn. Finally, &lt;tt&gt;spinWheels&lt;/tt&gt; makes the processor do some busy work, to stop the game from running too quickly. Think of it like a sleep command. The game keeps running until the snake collides with the wall or itself.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Zero page usage</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-3"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">The zero page of memory is used to store a number of game state variables, as noted in the comment block at the top of the game. Everything in &lt;tt&gt;$00&lt;/tt&gt;, &lt;tt&gt;$01&lt;/tt&gt; and &lt;tt&gt;$10&lt;/tt&gt; upwards is a pair of bytes representing a two-byte memory location that will be looked up using indirect addressing. These memory locations will all be between &lt;tt&gt;$0200&lt;/tt&gt; and &lt;tt&gt;$05ff&lt;/tt&gt; - the section of memory corresponding to the simulator display. For example, if &lt;tt&gt;$00&lt;/tt&gt; and &lt;tt&gt;$01&lt;/tt&gt; contained the values &lt;tt&gt;$01&lt;/tt&gt; and &lt;tt&gt;$02&lt;/tt&gt;, they would be referring to the second pixel of the display ( &lt;tt&gt;$0201&lt;/tt&gt; - remember, the least significant byte comes first in indirect addressing).</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">The first two bytes hold the location of the apple. This is updated every time the snake eats the apple. Byte &lt;tt&gt;$02&lt;/tt&gt; contains the current direction. &lt;tt&gt;1&lt;/tt&gt; means up, &lt;tt&gt;2&lt;/tt&gt; right, &lt;tt&gt;4&lt;/tt&gt; down, and &lt;tt&gt;8&lt;/tt&gt; left. The reasoning behind these numbers will become clear later.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Finally, byte &lt;tt&gt;$03&lt;/tt&gt; contains the current length of the snake, in terms of bytes in memory (so a length of 4 means 2 pixels).</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Initialization</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-3"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">The &lt;tt&gt;init&lt;/tt&gt; subroutine defers to two subroutines, &lt;tt&gt;initSnake&lt;/tt&gt; and &lt;tt&gt;generateApplePosition&lt;/tt&gt;. &lt;tt&gt;initSnake&lt;/tt&gt; sets the snake direction, length, and then loads the initial memory locations of the snake head and body. The byte pair at &lt;tt&gt;$10&lt;/tt&gt; contains the screen location of the head, the pair at &lt;tt&gt;$12&lt;/tt&gt; contains the location of the single body segment, and &lt;tt&gt;$14&lt;/tt&gt; contains the location of the tail (the tail is the last segment of the body and is drawn in black to keep the snake moving). This happens in the following code:</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="ExecutableSourceView" id="executableSourceView19"><property name="code">lda #$11\nsta $10\nlda #$10\nsta $12\nlda #$0f\nsta $14\nlda #$04\nsta $11\nsta $13\nsta $15</property><property name="language">6502-assembler</property><property name="readonly">true</property><property name="line-numbers">true</property><property name="fit-content-height">true</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">This loads the value &lt;tt&gt;$11&lt;/tt&gt; into the memory location &lt;tt&gt;$10&lt;/tt&gt;, the value &lt;tt&gt;$10&lt;/tt&gt; into &lt;tt&gt;$12&lt;/tt&gt;, and &lt;tt&gt;$0f&lt;/tt&gt; into &lt;tt&gt;$14&lt;/tt&gt;. It then loads the value &lt;tt&gt;$04&lt;/tt&gt; into &lt;tt&gt;$11&lt;/tt&gt;, &lt;tt&gt;$13&lt;/tt&gt; and &lt;tt&gt;$15&lt;/tt&gt;. This leads to memory like this:</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="ExecutableSourceView" id="executableSourceView20"><property name="code">0010: 11 04 10 04 0f 04</property><property name="language">hex</property><property name="readonly">true</property><property name="line-numbers">true</property><property name="fit-content-height">true</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">which represents the indirectly-addressed memory locations &lt;tt&gt;$0411&lt;/tt&gt;, &lt;tt&gt;$0410&lt;/tt&gt; and &lt;tt&gt;$040f&lt;/tt&gt; (three pixels in the middle of the display). I&apos;m labouring this point, but it&apos;s important to fully grok how indirect addressing works.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">The next subroutine, &lt;tt&gt;generateApplePosition&lt;/tt&gt;, sets the apple location to a random position on the display. First, it loads a random byte into the accumulator (&lt;tt&gt;$fe&lt;/tt&gt; is a random number generator in this simulator). This is stored into &lt;tt&gt;$00&lt;/tt&gt;. Next, a different random byte is loaded into the accumulator, which is then &lt;tt&gt;AND&lt;/tt&gt;-ed with the value &lt;tt&gt;$03&lt;/tt&gt;. This part requires a bit of a detour.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">The hex value &lt;tt&gt;$03&lt;/tt&gt; is represented in binary as &lt;tt&gt;00000011&lt;/tt&gt;. The &lt;tt&gt;AND&lt;/tt&gt; opcode performs a bitwise AND of the argument with the accumulator. For example, if the accumulator contains the binary value &lt;tt&gt;10101010&lt;/tt&gt;, then the result of &lt;tt&gt;AND&lt;/tt&gt; with &lt;tt&gt;00000011&lt;/tt&gt; will be &lt;tt&gt;00000010&lt;/tt&gt;.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">The effect of this is to mask out the least significant two bits of the accumulator, setting the others to zero. This converts a number in the range of 0255 to a number in the range of 03.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">After this, the value &lt;tt&gt;2&lt;/tt&gt; is added to the accumulator, to create a final random number in the range 25.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">The result of this subroutine is to load a random byte into &lt;tt&gt;$00&lt;/tt&gt;, and a random number between 2 and 5 into &lt;tt&gt;$01&lt;/tt&gt;. Because the least significant byte comes first with indirect addressing, this translates into a memory address between &lt;tt&gt;$0200&lt;/tt&gt; and &lt;tt&gt;$05ff&lt;/tt&gt;: the exact range used to draw the display.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">The game loop</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-3"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Nearly all games have at their heart a game loop. All game loops have the same basic form: accept user input, update the game state, and render the game state. This loop is no different.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Reading the input</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-4"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">The first subroutine, &lt;tt&gt;readKeys&lt;/tt&gt;, takes the job of accepting user input. The memory location &lt;tt&gt;$ff&lt;/tt&gt; holds the ascii code of the most recent key press in this simulator. The value is loaded into the accumulator, then compared to &lt;tt&gt;$77&lt;/tt&gt; (the hex code for W), &lt;tt&gt;$64&lt;/tt&gt; (D), &lt;tt&gt;$73&lt;/tt&gt; (S) and &lt;tt&gt;$61&lt;/tt&gt; (A). If any of these comparisons are successful, the program branches to the appropriate section. Each section (&lt;tt&gt;upKey&lt;/tt&gt;, &lt;tt&gt;rightKey&lt;/tt&gt;, etc.) first checks to see if the current direction is the opposite of the new direction. This requires another little detour.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">As stated before, the four directions are represented internally by the numbers 1, 2, 4 and 8. Each of these numbers is a power of 2, thus they are represented by a binary number with a single &lt;tt&gt;1&lt;/tt&gt;:</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="ExecutableSourceView" id="executableSourceView21"><property name="code">1 =&gt; 0001 (up)\n2 =&gt; 0010 (right)\n4 =&gt; 0100 (down)\n8 =&gt; 1000 (left)</property><property name="readonly">true</property><property name="line-numbers">true</property><property name="no-line-numbers">true</property><property name="fit-content-height">true</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">The &lt;tt&gt;BIT&lt;/tt&gt; opcode is similar to &lt;tt&gt;AND&lt;/tt&gt;, but the calculation is only used to set the zero flag - the actual result is discarded. The zero flag is set only if the result of AND-ing the accumulator with argument is zero. When we&apos;re looking at powers of two, the zero flag will only be set if the two numbers are not the same. For example, &lt;tt&gt;0001 AND 0001&lt;/tt&gt; is not zero, but &lt;tt&gt;0001 AND 0010&lt;/tt&gt; is zero.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">So, looking at &lt;tt&gt;upKey&lt;/tt&gt;, if the current direction is down (4), the bit test will be zero. &lt;tt&gt;BNE&lt;/tt&gt; means &quot;branch if the zero flag is clear&quot;, so in this case we&apos;ll branch to &lt;tt&gt;illegalMove&lt;/tt&gt;, which just returns from the subroutine. Otherwise, the new direction (1 in this case) is stored in the appropriate memory location.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Updating the game state</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-4"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">The next subroutine, &lt;tt&gt;checkCollision&lt;/tt&gt;, defers to &lt;tt&gt;checkAppleCollision&lt;/tt&gt; and &lt;tt&gt;checkSnakeCollision&lt;/tt&gt;. &lt;tt&gt;checkAppleCollision&lt;/tt&gt; just checks to see if the two bytes holding the location of the apple match the two bytes holding the location of the head. If they do, the length is increased and a new apple position is generated.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">&lt;tt&gt;checkSnakeCollision&lt;/tt&gt; loops through the snake&apos;s body segments, checking each byte pair against the head pair. If there is a match, then game over.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">After collision detection, we update the snake&apos;s location. This is done at a high level like so: First, move each byte pair of the body up one position in memory. Second, update the head according to the current direction. Finally, if the head is out of bounds, handle it as a collision. I&apos;ll illustrate this with some ascii art. Each pair of brackets contains an x,y coordinate rather than a pair of bytes for simplicity.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="ExecutableSourceView" id="executableSourceView22"><property name="code">  0    1    2    3    4\nHead                 Tail\n\n[1,5][1,4][1,3][1,2][2,2]    Starting position\n\n[1,5][1,4][1,3][1,2][1,2]    Value of (3) is copied into (4)\n\n[1,5][1,4][1,3][1,3][1,2]    Value of (2) is copied into (3)\n\n[1,5][1,4][1,4][1,3][1,2]    Value of (1) is copied into (2)\n\n[1,5][1,5][1,4][1,3][1,2]    Value of (0) is copied into (1)\n\n[0,5][1,5][1,4][1,3][1,2]    Value of (0) is updated based on direction</property><property name="readonly">true</property><property name="line-numbers">true</property><property name="no-line-numbers">true</property><property name="fit-content-height">true</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">At a low level, this subroutine is slightly more complex. First, the length is loaded into the &lt;tt&gt;X&lt;/tt&gt; register, which is then decremented. The snippet below shows the starting memory for the snake.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="ExecutableSourceView" id="executableSourceView23"><property name="code">Memory location: $10 $11 $12 $13 $14 $15\n\nValue:           $11 $04 $10 $04 $0f $04</property><property name="readonly">true</property><property name="line-numbers">true</property><property name="no-line-numbers">true</property><property name="fit-content-height">true</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">The length is initialized to &lt;tt&gt;4&lt;/tt&gt;, so &lt;tt&gt;X&lt;/tt&gt; starts off as &lt;tt&gt;3&lt;/tt&gt;. &lt;tt&gt;LDA $10,x&lt;/tt&gt; loads the value of &lt;tt&gt;$13&lt;/tt&gt; into &lt;tt&gt;A&lt;/tt&gt;, then &lt;tt&gt;STA $12,x&lt;/tt&gt; stores this value into &lt;tt&gt;$15&lt;/tt&gt;. &lt;tt&gt;X&lt;/tt&gt; is decremented, and we loop. Now &lt;tt&gt;X&lt;/tt&gt; is &lt;tt&gt;2&lt;/tt&gt;, so we load &lt;tt&gt;$12&lt;/tt&gt; and store it into &lt;tt&gt;$14&lt;/tt&gt;. This loops while &lt;tt&gt;X&lt;/tt&gt; is positive (&lt;tt&gt;BPL&lt;/tt&gt; means &quot;branch if positive&quot;).</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Once the values have been shifted down the snake, we have to work out what to do with the head. The direction is first loaded into &lt;tt&gt;A&lt;/tt&gt;. &lt;tt&gt;LSR&lt;/tt&gt; means &quot;logical shift right&quot;, or &quot;shift all the bits one position to the right&quot;. The least significant bit is shifted into the carry flag, so if the accumulator is &lt;tt&gt;1&lt;/tt&gt;, after &lt;tt&gt;LSR&lt;/tt&gt; it is &lt;tt&gt;0&lt;/tt&gt;, with the carry flag set.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">To test whether the direction is &lt;tt&gt;1&lt;/tt&gt;, &lt;tt&gt;2&lt;/tt&gt;, &lt;tt&gt;4&lt;/tt&gt; or &lt;tt&gt;8&lt;/tt&gt;, the code continually shifts right until the carry is set. One &lt;tt&gt;LSR&lt;/tt&gt; means &quot;up&quot;, two means &quot;right&quot;, and so on.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">The next bit updates the head of the snake depending on the direction. This is probably the most complicated part of the code, and it&apos;s all reliant on how memory locations map to the screen, so let&apos;s look at that in more detail.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">You can think of the screen as four horizontal strips of 32  8 pixels. These strips map to &lt;tt&gt;$0200-$02ff&lt;/tt&gt;, &lt;tt&gt;$0300-$03ff&lt;/tt&gt;, &lt;tt&gt;$0400-$04ff&lt;/tt&gt; and &lt;tt&gt;$0500-$05ff&lt;/tt&gt;. The first rows of pixels are &lt;tt&gt;$0200-$021f&lt;/tt&gt;, &lt;tt&gt;$0220-$023f&lt;/tt&gt;, &lt;tt&gt;$0240-$025f&lt;/tt&gt;, etc.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">As long as you&apos;re moving within one of these horizontal strips, things are simple. For example, to move right, just increment the least significant byte (e.g. &lt;tt&gt;$0200&lt;/tt&gt; becomes &lt;tt&gt;$0201&lt;/tt&gt;). To go down, add &lt;tt&gt;$20&lt;/tt&gt; (e.g. &lt;tt&gt;$0200&lt;/tt&gt; becomes &lt;tt&gt;$0220&lt;/tt&gt;). Left and up are the reverse.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Going between sections is more complicated, as we have to take into account the most significant byte as well. For example, going down from &lt;tt&gt;$02e1&lt;/tt&gt; should lead to &lt;tt&gt;$0301&lt;/tt&gt;. Luckily, this is fairly easy to accomplish. Adding &lt;tt&gt;$20&lt;/tt&gt; to &lt;tt&gt;$e1&lt;/tt&gt; results in &lt;tt&gt;$01&lt;/tt&gt; and sets the carry bit. If the carry bit was set, we know we also need to increment the most significant byte.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">After a move in each direction, we also need to check to see if the head would become out of bounds. This is handled differently for each direction. For left and right, we can check to see if the head has effectively &quot;wrapped around&quot;. Going right from &lt;tt&gt;$021f&lt;/tt&gt; by incrementing the least significant byte would lead to &lt;tt&gt;$0220&lt;/tt&gt;, but this is actually jumping from the last pixel of the first row to the first pixel of the second row. So, every time we move right, we need to check if the new least significant byte is a multiple of &lt;tt&gt;$20&lt;/tt&gt;. This is done using a bit check against the mask &lt;tt&gt;$1f&lt;/tt&gt;. Hopefully the illustration below will show you how masking out the lowest 5 bits reveals whether a number is a multiple of &lt;tt&gt;$20&lt;/tt&gt; or not.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="ExecutableSourceView" id="executableSourceView24"><property name="code">$20: 0010 0000\n$40: 0100 0000\n$60: 0110 0000\n\n$1f: 0001 1111</property><property name="readonly">true</property><property name="line-numbers">true</property><property name="no-line-numbers">true</property><property name="fit-content-height">true</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">I won&apos;t explain in depth how each of the directions work, but the above explanation should give you enough to work it out with a bit of study.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Rendering the game</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property><style><class name="title-4"></class></style></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Because the game state is stored in terms of pixel locations, rendering the game is very straightforward. The first subroutine, &lt;tt&gt;drawApple&lt;/tt&gt;, is extremely simple. It sets &lt;tt&gt;Y&lt;/tt&gt; to zero, loads a random colour into the accumulator, then stores this value into &lt;tt&gt;($00),y&lt;/tt&gt;. &lt;tt&gt;$00&lt;/tt&gt; is where the location of the apple is stored, so &lt;tt&gt;($00),y&lt;/tt&gt; dereferences to this memory location. Read the &quot;Indirect indexed&quot; section in &lt;a href=&quot;#addressing&quot;&gt;Addressing modes&lt;/a&gt; for more details.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">Next comes &lt;tt&gt;drawSnake&lt;/tt&gt;. This is pretty simple too - we first undraw the tail and then draw the head. &lt;tt&gt;X&lt;/tt&gt; is set to the length of the snake, so we can index to the right pixel, and we set &lt;tt&gt;A&lt;/tt&gt; to zero then perform the write using the indexed indirect addressing mode. Then we reload &lt;tt&gt;X&lt;/tt&gt; to index to the head, set &lt;tt&gt;A&lt;/tt&gt; to one and store it at &lt;tt&gt;($10,x)&lt;/tt&gt;. &lt;tt&gt;$10&lt;/tt&gt; stores the two-byte location of the head, so this draws a white pixel at the current head position. As only the head and the tail of the snake move, this is enough to keep the snake moving.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child>\n<child><object class="GtkLabel"><property name="label" translatable="true">The last subroutine, &lt;tt&gt;spinWheels&lt;/tt&gt;, is just there because the game would run too fast otherwise. All &lt;tt&gt;spinWheels&lt;/tt&gt; does is count &lt;tt&gt;X&lt;/tt&gt; down from zero until it hits zero again. The first &lt;tt&gt;dex&lt;/tt&gt; wraps, making &lt;tt&gt;X&lt;/tt&gt; &lt;tt&gt;#$ff&lt;/tt&gt;.</property><property name="use-markup">true</property><property name="wrap">true</property><property name="hexpand-set">true</property><property name="hexpand">true</property><property name="halign">0</property><property name="xalign">0</property><property name="margin-top">12</property><property name="margin-bottom">12</property></object></child></object></child></template></interface>';
const Template$c = '<?xml version="1.0" encoding="UTF-8"?>\n<!--\nDO NOT EDIT!\nThis file was @generated by blueprint-compiler. Instead, edit the\ncorresponding .blp file and regenerate this file with blueprint-compiler.\n-->\n<interface>\n  <requires lib="gtk" version="4.0"/>\n  <template class="SourceView" parent="AdwBin">\n    <child>\n      <object class="GtkScrolledWindow" id="scrolledWindow">\n        <property name="hexpand">true</property>\n        <property name="vexpand">true</property>\n        <property name="has-frame">false</property>\n        <child>\n          <object class="GtkSourceView" id="sourceView">\n            <property name="hexpand">true</property>\n            <property name="vexpand">true</property>\n            <property name="auto-indent">true</property>\n            <property name="indent-width">4</property>\n            <property name="show-line-numbers">true</property>\n            <property name="monospace">true</property>\n            <property name="left-margin">12</property>\n            <property name="right-margin">12</property>\n            <property name="top-margin">12</property>\n            <property name="bottom-margin">12</property>\n          </object>\n        </child>\n      </object>\n    </child>\n  </template>\n</interface>';
class GutterRendererAddress extends GtkSource.GutterRendererText {
  static {
    GObject.registerClass({
      GTypeName: "GutterRendererAddress"
    }, this);
  }
  constructor(params = {}) {
    super(params);
  }
  vfunc_query_data(gutter, line) {
    const address = line * 16;
    const formattedAddress = address.toString(16).padStart(4, "0").toUpperCase();
    this.text = formattedAddress;
  }
}
GtkSource.init();
class SourceView extends Adw.Bin {
  static {
    GObject.registerClass({
      GTypeName: "SourceView",
      Template: Template$c,
      InternalChildren: ["sourceView", "scrolledWindow"],
      Signals: {
        "changed": {
          param_types: []
        }
      },
      Properties: {
        code: GObject.ParamSpec.string("code", "Code", "The source code of the source view", GObject.ParamFlags.READWRITE, ""),
        language: GObject.ParamSpec.string("language", "Language", "The language of the source view", GObject.ParamFlags.READWRITE, ""),
        readonly: GObject.ParamSpec.boolean("readonly", "Readonly", "Whether the source view is readonly", GObject.ParamFlags.READWRITE, false),
        editable: GObject.ParamSpec.boolean("editable", "Editable", "Whether the source view is editable", GObject.ParamFlags.READWRITE, true),
        selectable: GObject.ParamSpec.boolean("selectable", "Focusable", "Whether the source view is selectable", GObject.ParamFlags.READWRITE, true),
        unselectable: GObject.ParamSpec.boolean("unselectable", "Unselectable", "Whether the source view is unselectable", GObject.ParamFlags.READWRITE, false),
        lineNumbers: GObject.ParamSpec.boolean("line-numbers", "Line Numbers", "Whether the source view has line numbers", GObject.ParamFlags.READWRITE, true),
        noLineNumbers: GObject.ParamSpec.boolean("no-line-numbers", "No Line Numbers", "Whether the source view has no line numbers", GObject.ParamFlags.READWRITE, false),
        hexpand: GObject.ParamSpec.boolean("hexpand", "Hexpand", "Whether the source view is hexpand", GObject.ParamFlags.READWRITE, true),
        vexpand: GObject.ParamSpec.boolean("vexpand", "Vexpand", "Whether the source view is vexpand", GObject.ParamFlags.READWRITE, true),
        fitContentHeight: GObject.ParamSpec.boolean("fit-content-height", "Fit Content Height", "Whether the source view should fit the content height", GObject.ParamFlags.READWRITE, false),
        fitContentWidth: GObject.ParamSpec.boolean("fit-content-width", "Fit Content Width", "Whether the source view should fit the content width", GObject.ParamFlags.READWRITE, false),
        height: GObject.ParamSpec.uint("height", "Height", "The height of the source view", GObject.ParamFlags.READWRITE, 0, GLib.MAXUINT32, 0)
      }
    }, this);
  }
  /** The source code of the source view */
  set code(value) {
    this.buffer.text = value;
    this.emitChanged();
  }
  /** The source code of the source view */
  get code() {
    return this.buffer.text;
  }
  /** The buffer of the source view */
  get buffer() {
    return this._sourceView.buffer;
  }
  /**
   * Set the readonly property of the source view
   * 
   * @param value - Whether the source view is readonly
   */
  set readonly(value) {
    this.editable = !value;
  }
  /**
   * Get the readonly property of the source view
   * 
   * @returns Whether the source view is readonly
   */
  get readonly() {
    return !this.editable;
  }
  /**
   * Set the editable property of the source view
   * 
   * @param value - Whether the source view is editable
   */
  set editable(value) {
    this._sourceView.set_editable(value);
  }
  /**
   * Get the editable property of the source view
   * 
   * @returns Whether the source view is editable
   */
  get editable() {
    return this._sourceView.editable;
  }
  /**
   * Set the language of the source view
   * 
   * @param language - The language of the source view, e.g. '6502-assembler'
   */
  set language(language) {
    if (language === "") {
      this.buffer.set_language(null);
      return;
    }
    const languageManager = GtkSource.LanguageManager.get_default();
    const assemblyLanguage = languageManager.get_language(language);
    if (!assemblyLanguage) {
      throw new Error(`Language "${language}" not found`);
    }
    this.buffer.set_language(assemblyLanguage);
    if (language === "hex") {
      this.setupHexLanguage();
    } else {
      this.disconnectHexLanguage();
    }
  }
  /**
   * Get the language of the source view
   * 
   * @returns The language of the source view, e.g. '6502-assembler'
   */
  get language() {
    return this.buffer.language?.id ?? "";
  }
  /**
   * Set the selectable property of the source view
   * 
   * @param value - Whether the source view is selectable
   */
  set selectable(value) {
    if (this._selectable === value) {
      return;
    }
    if (typeof value !== "boolean") {
      console.warn("selectable must be a boolean, got " + typeof value);
      return;
    }
    this._selectable = value;
    this.selectableChanged();
  }
  /**
   * Get the selectable property of the source view
   * 
   * @returns Whether the source view is selectable
   */
  get selectable() {
    return this._selectable;
  }
  /**
   * Set the unselectable property of the source view
   * 
   * @param value - Whether the source view is unselectable
   */
  set unselectable(value) {
    this.selectable = !value;
  }
  /**
   * Get the unselectable property of the source view
   * 
   * @returns Whether the source view is unselectable
   */
  get unselectable() {
    return !this.selectable;
  }
  /**
   * Set the line numbers property of the source view
   * 
   * @param value - Whether the source view has line numbers
   */
  set lineNumbers(value) {
    this._sourceView.show_line_numbers = value;
  }
  /**
   * Get the line numbers property of the source view
   * 
   * @returns Whether the source view has line numbers
   */
  get lineNumbers() {
    return this._sourceView.show_line_numbers;
  }
  /**
   * Set the no line numbers property of the source view
   * 
   * @param value - Whether the source view has no line numbers
   */
  set noLineNumbers(value) {
    this.lineNumbers = !value;
  }
  /**
   * Get the no line numbers property of the source view
   * 
   * @returns Whether the source view has no line numbers
   */
  get noLineNumbers() {
    return !this.lineNumbers;
  }
  /**
   * Set the fitContentHeight property of the source view.
   * This property is used to fit the content height of the source view and to disable vertical scrolling.
   * 
   * @param value - Whether the source view should fit the content height
   */
  set fitContentHeight(value) {
    const [hPolicy] = this._scrolledWindow.get_policy();
    if (value) {
      this._scrolledWindow.set_policy(hPolicy || Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.NEVER);
    } else {
      this._scrolledWindow.set_policy(hPolicy || Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC);
    }
  }
  /**
   * Set the fitContentWidth property of the source view.
   * This property is used to fit the content width of the source view and to disable horizontal scrolling.
   * 
   * @param value - Whether the source view should fit the content width
   */
  set fitContentWidth(value) {
    const [, vPolicy] = this._scrolledWindow.get_policy();
    if (value) {
      this._scrolledWindow.set_policy(Gtk.PolicyType.NEVER, vPolicy || Gtk.PolicyType.AUTOMATIC);
    } else {
      this._scrolledWindow.set_policy(Gtk.PolicyType.AUTOMATIC, vPolicy || Gtk.PolicyType.AUTOMATIC);
    }
  }
  set height(value) {
    if (value > 0) {
      this._scrolledWindow.height_request = value;
    } else {
      this._scrolledWindow.height_request = -1;
    }
  }
  get height() {
    return this._scrolledWindow.height_request;
  }
  _selectable = true;
  _selectableSignalIds = [];
  /** The style scheme manager */
  schemeManager = GtkSource.StyleSchemeManager.get_default();
  /** The style manager */
  styleManager = Adw.StyleManager.get_default();
  /** The gutter for the left side */
  leftGutter;
  /** The renderer for custom line numbers, used for the hex monitor to display the address instead of line numbers */
  renderer;
  copyClipboardSignalId;
  constructor(params) {
    super(params);
    this.setupScrolledWindow();
    this.language = "6502-assembler";
    this.setupSignalListeners();
    this.updateStyle();
    this.leftGutter = this._sourceView.get_gutter(Gtk.TextWindowType.LEFT);
    this.code = "LDA #$01\nSTA $0200\nLDA #$05\nSTA $0201\nLDA #$08\nSTA $0202";
  }
  setupScrolledWindow() {
    this._scrolledWindow.set_vadjustment(this._sourceView.vadjustment);
    this._scrolledWindow.set_hadjustment(this._sourceView.hadjustment);
  }
  /**
   * Setup signal listeners
   * 
   * @emits changed - Emitted when the buffer's text changes
   */
  setupSignalListeners() {
    this.buffer.connect("end-user-action", this.emitChanged.bind(this));
    this.buffer.connect("undo", this.emitChanged.bind(this));
    this.buffer.connect("redo", this.emitChanged.bind(this));
    this.buffer.connect_after("cursor-moved", this.onCursorMoved.bind(this));
    this.styleManager.connect("notify::dark", this.updateStyle.bind(this));
  }
  onCursorMoved(buffer) {
    this.leftGutter.queue_draw();
    this.renderer?.queue_draw();
  }
  setupHexLanguage() {
    this.setupHexAddressLineNumbers();
    this.copyClipboardSignalId = this._sourceView.connect_after("copy-clipboard", this.onCopyHexClipboard.bind(this));
    this._sourceView.highlight_current_line = true;
  }
  disconnectHexLanguage() {
    if (this.copyClipboardSignalId) {
      this._sourceView.disconnect(this.copyClipboardSignalId);
    }
    if (this.renderer) {
      this.leftGutter.remove(this.renderer);
    }
    this._sourceView.highlight_current_line = false;
  }
  setupHexAddressLineNumbers() {
    this._sourceView.show_line_numbers = false;
    this.renderer = new GutterRendererAddress({
      margin_start: 12,
      margin_end: 12,
      width_request: 36,
      focus_on_click: true,
      focusable: true
    });
    this.leftGutter.insert(this.renderer, 0);
  }
  /**
   * Copy the selected text to the "strg+c" clipboard without spaces
   * @returns 
   */
  onCopyHexClipboard() {
    const buffer = this._sourceView.buffer;
    const [hasSelection, start, end] = buffer.get_selection_bounds();
    if (hasSelection) {
      const text = buffer.get_text(start, end, false);
      const cleanedText = text.replace(/\s/g, "");
      const display = this.get_display();
      if (!display) {
        console.error("No display found");
        return false;
      }
      const clipboard = display.get_clipboard();
      const value = new GObject.Value();
      value.init(GObject.TYPE_STRING);
      value.set_string(cleanedText);
      const contentProvider = Gdk.ContentProvider.new_for_value(value);
      const success = clipboard.set_content(contentProvider);
      console.log(`Copy to clipboard: ${success ? "success" : "failed"}`);
      return true;
    }
    return false;
  }
  selectableChanged() {
    this._selectableSignalIds.forEach((id) => this.disconnect(id));
    this._selectableSignalIds = [];
    this._sourceView.cursor_visible = this._selectable;
    if (this._selectable) {
      return;
    }
    this._selectableSignalIds.push(this._sourceView.connect("extend-selection", (sourceView, granularity, location, start, end) => {
      GObject.signal_stop_emission_by_name(this._sourceView, "extend-selection");
    }));
    this._selectableSignalIds.push(this.buffer.connect("mark-set", (buffer, location, mark) => {
      if (mark.name === "insert" || mark.name === "selection_bound") {
        const offset = location.get_offset();
        if (offset !== 0) {
          location.set_offset(0);
          this.buffer.move_mark(mark, location);
          GObject.signal_stop_emission_by_name(this.buffer, "mark-set");
        }
      }
    }));
  }
  emitChanged() {
    this.emit("changed");
  }
  /**
   * Update the style of the source view.
   * Used internally to update the style of the source view when the theme changes.
   */
  updateStyle() {
    const scheme = this.schemeManager.get_scheme(
      this.styleManager.dark ? "Adwaita-dark" : "Adwaita"
    );
    this.buffer.set_style_scheme(scheme);
  }
}
const Template$b = '<?xml version="1.0" encoding="UTF-8"?>\n<!--\nDO NOT EDIT!\nThis file was @generated by blueprint-compiler. Instead, edit the\ncorresponding .blp file and regenerate this file with blueprint-compiler.\n-->\n<interface>\n  <requires lib="gtk" version="4.0"/>\n  <template class="ExecutableSourceView" parent="AdwBin">\n    <child>\n      <object class="GtkBox">\n        <property name="orientation">1</property>\n        <child>\n          <object class="SourceView" id="sourceView"></object>\n        </child>\n        <child>\n          <object class="GtkActionBar" id="actionBar">\n            <property name="revealed">true</property>\n            <property name="valign">2</property>\n            <child type="start">\n              <object class="AdwSplitButton" id="runButton">\n                <property name="halign">3</property>\n                <property name="icon-name">media-playback-start-symbolic</property>\n                <style>\n                  <class name="suggested-action"/>\n                </style>\n                <property name="action-name">executable-source-view.copy-assemble-and-run</property>\n                <property name="menu-model">buttonRunMenu</property>\n              </object>\n            </child>\n          </object>\n        </child>\n      </object>\n    </child>\n  </template>\n  <menu id="buttonRunMenu">\n    <section>\n      <item>\n        <attribute name="label">Copy, Assemble and Run</attribute>\n        <attribute name="action">executable-source-view.copy-assemble-and-run</attribute>\n      </item>\n      <item>\n        <attribute name="label">Copy and Assemble</attribute>\n        <attribute name="action">executable-source-view.copy-assemble</attribute>\n      </item>\n      <item>\n        <attribute name="label">Copy</attribute>\n        <attribute name="action">executable-source-view.copy</attribute>\n      </item>\n    </section>\n  </menu>\n</interface>';
GObject.type_ensure(SourceView.$gtype);
class ExecutableSourceView extends Adw.Bin {
  static {
    GObject.registerClass({
      GTypeName: "ExecutableSourceView",
      Template: Template$b,
      InternalChildren: ["sourceView", "actionBar", "runButton"],
      Signals: {
        "changed": {
          param_types: []
        },
        "copy-assemble-and-run": {
          param_types: [GObject.TYPE_STRING]
        },
        "copy-assemble": {
          param_types: [GObject.TYPE_STRING]
        },
        "copy": {
          param_types: [GObject.TYPE_STRING]
        }
      },
      Properties: {
        code: GObject.ParamSpec.string("code", "Code", "The source code of the editor", GObject.ParamFlags.READWRITE, ""),
        language: GObject.ParamSpec.string("language", "Language", "The language of the source view", GObject.ParamFlags.READWRITE, ""),
        readonly: GObject.ParamSpec.boolean("readonly", "Readonly", "Whether the source view is readonly", GObject.ParamFlags.READWRITE, false),
        editable: GObject.ParamSpec.boolean("editable", "Editable", "Whether the source view is editable", GObject.ParamFlags.READWRITE, true),
        selectable: GObject.ParamSpec.boolean("selectable", "Focusable", "Whether the source view is selectable", GObject.ParamFlags.READWRITE, true),
        unselectable: GObject.ParamSpec.boolean("unselectable", "Unselectable", "Whether the source view is unselectable", GObject.ParamFlags.READWRITE, false),
        lineNumbers: GObject.ParamSpec.boolean("line-numbers", "Line Numbers", "Whether the source view has line numbers", GObject.ParamFlags.READWRITE, true),
        noLineNumbers: GObject.ParamSpec.boolean("no-line-numbers", "No Line Numbers", "Whether the source view has no line numbers", GObject.ParamFlags.READWRITE, false),
        hexpand: GObject.ParamSpec.boolean("hexpand", "Hexpand", "Whether the source view is hexpand", GObject.ParamFlags.READWRITE, true),
        vexpand: GObject.ParamSpec.boolean("vexpand", "Vexpand", "Whether the source view is vexpand", GObject.ParamFlags.READWRITE, true),
        fitContentHeight: GObject.ParamSpec.boolean("fit-content-height", "Fit Content Height", "Whether the source view should fit the content height", GObject.ParamFlags.READWRITE, false),
        fitContentWidth: GObject.ParamSpec.boolean("fit-content-width", "Fit Content Width", "Whether the source view should fit the content width", GObject.ParamFlags.READWRITE, false),
        height: GObject.ParamSpec.uint("height", "Height", "The height of the source view", GObject.ParamFlags.READWRITE, 0, GLib.MAXUINT32, 0)
      }
    }, this);
  }
  set code(value) {
    this._sourceView.code = value;
  }
  get code() {
    return this._sourceView.code;
  }
  /**
   * Set the readonly property of the source view
   * 
   * @param value - Whether the source view is readonly
   */
  set readonly(value) {
    this._sourceView.editable = !value;
    this._actionBar.visible = !value;
  }
  /**
   * Get the readonly property of the source view
   * 
   * @returns Whether the source view is readonly
   */
  get readonly() {
    return !this.editable;
  }
  /**
   * Set the editable property of the source view
   * 
   * @param value - Whether the source view is editable
   */
  set editable(value) {
    this._sourceView.editable = value;
  }
  /**
   * Get the editable property of the source view
   * 
   * @returns Whether the source view is editable
   */
  get editable() {
    return this._sourceView.editable;
  }
  /**
   * Set the language of the source view
   * 
   * @param language - The language of the source view, e.g. '6502-assembler'
   */
  set language(language) {
    this._sourceView.language = language;
  }
  /**
   * Get the language of the source view
   * 
   * @returns The language of the source view, e.g. '6502-assembler'
   */
  get language() {
    return this._sourceView.language ?? "";
  }
  /**
   * Set the selectable property of the source view
   * 
   * @param value - Whether the source view is selectable
   */
  set selectable(value) {
    this._sourceView.selectable = value;
  }
  /**
   * Get the selectable property of the source view
   * 
   * @returns Whether the source view is selectable
   */
  get selectable() {
    return this._sourceView.selectable;
  }
  /**
   * Set the unselectable property of the source view
   * 
   * @param value - Whether the source view is unselectable
   */
  set unselectable(value) {
    this.selectable = !value;
  }
  /**
   * Get the unselectable property of the source view
   * 
   * @returns Whether the source view is unselectable
   */
  get unselectable() {
    return !this.selectable;
  }
  /**
   * Set the line numbers property of the source view
   * 
   * @param value - Whether the source view has line numbers
   */
  set lineNumbers(value) {
    this._sourceView.lineNumbers = value;
  }
  /**
   * Get the line numbers property of the source view
   * 
   * @returns Whether the source view has line numbers
   */
  get lineNumbers() {
    return this._sourceView.lineNumbers;
  }
  /**
   * Set the no line numbers property of the source view
   * 
   * @param value - Whether the source view has no line numbers
   */
  set noLineNumbers(value) {
    this.lineNumbers = !value;
  }
  /**
   * Get the no line numbers property of the source view
   * 
   * @returns Whether the source view has no line numbers
   */
  get noLineNumbers() {
    return !this.lineNumbers;
  }
  /**
   * Set the fitContentHeight property of the source view.
   * This property is used to fit the content height of the source view and to disable vertical scrolling.
   * 
   * @param value - Whether the source view should fit the content height
   */
  set fitContentHeight(value) {
    this._sourceView.fitContentHeight = value;
  }
  /**
   * Set the fitContentWidth property of the source view.
   * This property is used to fit the content width of the source view and to disable horizontal scrolling.
   * 
   * @param value - Whether the source view should fit the content width
   */
  set fitContentWidth(value) {
    this._sourceView.fitContentWidth = value;
  }
  set height(value) {
    this._sourceView.height = value;
  }
  get height() {
    return this._sourceView.height;
  }
  _actionGroup;
  constructor(params) {
    super(params);
    this._actionGroup = new Gio.SimpleActionGroup();
    this.insert_action_group("executable-source-view", this._actionGroup);
    this._setupActions();
  }
  _setupActions() {
    const copyAssembleAndRunAction = new Gio.SimpleAction({ name: "copy-assemble-and-run" });
    copyAssembleAndRunAction.connect("activate", this._onCopyAssembleAndRun.bind(this));
    this._actionGroup.add_action(copyAssembleAndRunAction);
    const copyAndAssembleAction = new Gio.SimpleAction({ name: "copy-assemble" });
    copyAndAssembleAction.connect("activate", this._onCopyAndAssemble.bind(this));
    this._actionGroup.add_action(copyAndAssembleAction);
    const copyAction = new Gio.SimpleAction({ name: "copy" });
    copyAction.connect("activate", this._onCopy.bind(this));
    this._actionGroup.add_action(copyAction);
  }
  _onCopyAssembleAndRun() {
    this.emit("copy-assemble-and-run", this.code);
  }
  _onCopyAndAssemble() {
    this.emit("copy-assemble", this.code);
  }
  _onCopy() {
    this.emit("copy", this.code);
  }
}
GObject.type_ensure(ExecutableSourceView.$gtype);
const executableSourceViewIds = findIdsInXml("executableSourceView", Template$d);
class Tutorial extends Adw.Bin {
  static {
    GObject.registerClass({
      GTypeName: "Tutorial",
      Template: Template$d,
      InternalChildren: [...executableSourceViewIds],
      Signals: {
        "copy-assemble-and-run": {
          param_types: [GObject.TYPE_STRING]
        },
        "copy-assemble": {
          param_types: [GObject.TYPE_STRING]
        },
        "copy": {
          param_types: [GObject.TYPE_STRING]
        }
      }
    }, this);
  }
  constructor(params) {
    super(params);
    this.setupCodeBlocks();
  }
  setupCodeBlocks() {
    for (const id of executableSourceViewIds) {
      const executableSourceView = this.getExecutableSourceView(id);
      executableSourceView.connect("copy-assemble-and-run", (sourceView, code) => {
        this.emit("copy-assemble-and-run", code);
      });
      executableSourceView.connect("copy-assemble", (sourceView, code) => {
        this.emit("copy-assemble", code);
      });
      executableSourceView.connect("copy", (sourceView, code) => {
        this.emit("copy", code);
      });
    }
  }
  getExecutableSourceView(id) {
    const propertyName = `_${id}`;
    if (propertyName in this) {
      return this[propertyName];
    }
    throw new Error(`ExecutableSourceView with id ${id} not found`);
  }
}
const Template$a = '<?xml version="1.0" encoding="UTF-8"?>\n<!--\nDO NOT EDIT!\nThis file was @generated by blueprint-compiler. Instead, edit the\ncorresponding .blp file and regenerate this file with blueprint-compiler.\n-->\n<interface>\n  <requires lib="gtk" version="4.0"/>\n  <template class="Learn" parent="AdwBin">\n    <child>\n      <object class="GtkScrolledWindow" id="scrolledWindow">\n        <property name="height-request">200</property>\n        <property name="vexpand">true</property>\n        <property name="has-frame">false</property>\n        <child>\n          <object class="AdwStatusPage" id="statusPage">\n            <property name="title" translatable="true">Learn</property>\n            <property name="description" translatable="true">Learn how to program the 6502 microprocessor.</property>\n            <property name="icon-name">school-symbolic</property>\n            <child>\n              <object class="AdwClamp">\n                <property name="maximum-size">600</property>\n                <property name="margin-top">12</property>\n                <property name="margin-bottom">12</property>\n                <property name="margin-start">12</property>\n                <property name="margin-end">12</property>\n                <property name="child">\n                  <object class="Tutorial" id="tutorial"></object>\n                </property>\n              </object>\n            </child>\n          </object>\n        </child>\n      </object>\n    </child>\n  </template>\n</interface>';
GObject.type_ensure(Tutorial.$gtype);
class Learn extends Adw.Bin {
  static {
    GObject.registerClass({
      GTypeName: "Learn",
      Template: Template$a,
      InternalChildren: ["scrolledWindow", "statusPage", "tutorial"],
      Signals: {
        "copy-assemble-and-run": {
          param_types: [GObject.TYPE_STRING]
        },
        "copy-assemble": {
          param_types: [GObject.TYPE_STRING]
        },
        "copy": {
          param_types: [GObject.TYPE_STRING]
        }
      }
    }, this);
  }
  constructor(params) {
    super(params);
    this.setupTutorialSignalListeners();
  }
  setupTutorialSignalListeners() {
    this._tutorial.connect("copy-assemble-and-run", (tutorial, code) => {
      this.emit("copy-assemble-and-run", code);
    });
    this._tutorial.connect("copy-assemble", (tutorial, code) => {
      this.emit("copy-assemble", code);
    });
    this._tutorial.connect("copy", (tutorial, code) => {
      this.emit("copy", code);
    });
  }
}
const Template$9 = '<?xml version="1.0" encoding="UTF-8"?>\n<!--\nDO NOT EDIT!\nThis file was @generated by blueprint-compiler. Instead, edit the\ncorresponding .blp file and regenerate this file with blueprint-compiler.\n-->\n<interface>\n  <requires lib="gtk" version="4.0"/>\n  <template class="Editor" parent="AdwBin">\n    <child>\n      <object class="SourceView" id="sourceView">\n        <property name="hexpand">true</property>\n        <property name="vexpand">true</property>\n      </object>\n    </child>\n  </template>\n</interface>';
GObject.type_ensure(SourceView.$gtype);
class Editor extends Adw.Bin {
  static {
    GObject.registerClass({
      GTypeName: "Editor",
      Template: Template$9,
      InternalChildren: ["sourceView"],
      Signals: {
        "changed": {
          param_types: []
        }
      },
      Properties: {
        code: GObject.ParamSpec.string("code", "Code", "The source code of the editor", GObject.ParamFlags.READWRITE, "")
      }
    }, this);
  }
  set code(value) {
    this._sourceView.code = value;
    this.onUpdate();
  }
  get code() {
    return this._sourceView.code;
  }
  constructor(params) {
    super(params);
  }
  onUpdate() {
    this.emit("changed");
  }
}
var DebuggerState;
(function(DebuggerState2) {
  DebuggerState2[DebuggerState2["INITIAL"] = 0] = "INITIAL";
  DebuggerState2[DebuggerState2["ACTIVE"] = 1] = "ACTIVE";
  DebuggerState2[DebuggerState2["PAUSED"] = 2] = "PAUSED";
  DebuggerState2[DebuggerState2["RESET"] = 3] = "RESET";
})(DebuggerState || (DebuggerState = {}));
class EventDispatcher {
  listeners = {};
  /** Register a listener for a specific event */
  on(event, callback) {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event].push(callback);
  }
  /** Remove a listener for a specific event */
  off(event, callback) {
    if (!this.listeners[event]) {
      return;
    }
    this.listeners[event] = this.listeners[event].filter((listener) => listener !== callback);
  }
  /** Dispatch an event to all registered listeners */
  dispatch(event, data) {
    if (!this.listeners[event]) {
      return;
    }
    this.listeners[event].forEach((listener) => listener(data));
    this.listeners[event] = this.listeners[event].filter((listener) => !listener.once);
  }
  /** Register a listener that will be removed after its first invocation */
  once(event, callback) {
    const onceWrapper = (data) => {
      callback(data);
      onceWrapper.once = true;
    };
    this.on(event, onceWrapper);
  }
}
function addr2hex(addr) {
  return num2hex(addr >> 8 & 255) + num2hex(addr & 255);
}
function num2hex(nr) {
  const str = "0123456789abcdef";
  const hi = (nr & 240) >> 4;
  const lo = nr & 15;
  return str.substring(hi, hi + 1) + str.substring(lo, lo + 1);
}
const throttle = (func, delay) => {
  let lastCall = 0;
  let timeoutId = null;
  return (...args) => {
    const now = Date.now();
    if (now - lastCall >= delay) {
      if (timeoutId !== null) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }
      lastCall = now;
      func(...args);
    } else if (timeoutId === null) {
      timeoutId = setTimeout(() => {
        lastCall = Date.now();
        func(...args);
        timeoutId = null;
      }, delay - (now - lastCall));
    }
  };
};
class Assembler {
  memory;
  labels;
  currentPC;
  codeLen;
  codeAssembledOK = false;
  wasOutOfRangeBranch = false;
  opcodes = [
    /* Name, Imm,  ZP,   ZPX,  ZPY,  ABS, ABSX, ABSY,  IND, INDX, INDY, SNGL, BRA */
    ["ADC", 105, 101, 117, null, 109, 125, 121, null, 97, 113, null, null],
    ["AND", 41, 37, 53, null, 45, 61, 57, null, 33, 49, null, null],
    ["ASL", null, 6, 22, null, 14, 30, null, null, null, null, 10, null],
    ["BIT", null, 36, null, null, 44, null, null, null, null, null, null, null],
    ["BPL", null, null, null, null, null, null, null, null, null, null, null, 16],
    ["BMI", null, null, null, null, null, null, null, null, null, null, null, 48],
    ["BVC", null, null, null, null, null, null, null, null, null, null, null, 80],
    ["BVS", null, null, null, null, null, null, null, null, null, null, null, 112],
    ["BCC", null, null, null, null, null, null, null, null, null, null, null, 144],
    ["BCS", null, null, null, null, null, null, null, null, null, null, null, 176],
    ["BNE", null, null, null, null, null, null, null, null, null, null, null, 208],
    ["BEQ", null, null, null, null, null, null, null, null, null, null, null, 240],
    ["BRK", null, null, null, null, null, null, null, null, null, null, 0, null],
    ["CMP", 201, 197, 213, null, 205, 221, 217, null, 193, 209, null, null],
    ["CPX", 224, 228, null, null, 236, null, null, null, null, null, null, null],
    ["CPY", 192, 196, null, null, 204, null, null, null, null, null, null, null],
    ["DEC", null, 198, 214, null, 206, 222, null, null, null, null, null, null],
    ["EOR", 73, 69, 85, null, 77, 93, 89, null, 65, 81, null, null],
    ["CLC", null, null, null, null, null, null, null, null, null, null, 24, null],
    ["SEC", null, null, null, null, null, null, null, null, null, null, 56, null],
    ["CLI", null, null, null, null, null, null, null, null, null, null, 88, null],
    ["SEI", null, null, null, null, null, null, null, null, null, null, 120, null],
    ["CLV", null, null, null, null, null, null, null, null, null, null, 184, null],
    ["CLD", null, null, null, null, null, null, null, null, null, null, 216, null],
    ["SED", null, null, null, null, null, null, null, null, null, null, 248, null],
    ["INC", null, 230, 246, null, 238, 254, null, null, null, null, null, null],
    ["JMP", null, null, null, null, 76, null, null, 108, null, null, null, null],
    ["JSR", null, null, null, null, 32, null, null, null, null, null, null, null],
    ["LDA", 169, 165, 181, null, 173, 189, 185, null, 161, 177, null, null],
    ["LDX", 162, 166, null, 182, 174, null, 190, null, null, null, null, null],
    ["LDY", 160, 164, 180, null, 172, 188, null, null, null, null, null, null],
    ["LSR", null, 70, 86, null, 78, 94, null, null, null, null, 74, null],
    ["NOP", null, null, null, null, null, null, null, null, null, null, 234, null],
    ["ORA", 9, 5, 21, null, 13, 29, 25, null, 1, 17, null, null],
    ["TAX", null, null, null, null, null, null, null, null, null, null, 170, null],
    ["TXA", null, null, null, null, null, null, null, null, null, null, 138, null],
    ["DEX", null, null, null, null, null, null, null, null, null, null, 202, null],
    ["INX", null, null, null, null, null, null, null, null, null, null, 232, null],
    ["TAY", null, null, null, null, null, null, null, null, null, null, 168, null],
    ["TYA", null, null, null, null, null, null, null, null, null, null, 152, null],
    ["DEY", null, null, null, null, null, null, null, null, null, null, 136, null],
    ["INY", null, null, null, null, null, null, null, null, null, null, 200, null],
    ["ROR", null, 102, 118, null, 110, 126, null, null, null, null, 106, null],
    ["ROL", null, 38, 54, null, 46, 62, null, null, null, null, 42, null],
    ["RTI", null, null, null, null, null, null, null, null, null, null, 64, null],
    ["RTS", null, null, null, null, null, null, null, null, null, null, 96, null],
    ["SBC", 233, 229, 245, null, 237, 253, 249, null, 225, 241, null, null],
    ["STA", null, 133, 149, null, 141, 157, 153, null, 129, 145, null, null],
    ["TXS", null, null, null, null, null, null, null, null, null, null, 154, null],
    ["TSX", null, null, null, null, null, null, null, null, null, null, 186, null],
    ["PHA", null, null, null, null, null, null, null, null, null, null, 72, null],
    ["PLA", null, null, null, null, null, null, null, null, null, null, 104, null],
    ["PHP", null, null, null, null, null, null, null, null, null, null, 8, null],
    ["PLP", null, null, null, null, null, null, null, null, null, null, 40, null],
    ["STX", null, 134, null, 150, 142, null, null, null, null, null, null, null],
    ["STY", null, 132, 148, null, 140, null, null, null, null, null, null, null],
    ["WDM", 66, 66, null, null, null, null, null, null, null, null, null, null],
    ["---", null, null, null, null, null, null, null, null, null, null, null, null]
  ];
  // TODO: Create separate disassembler object?
  addressingModes = [
    null,
    "Imm",
    "ZP",
    "ZPX",
    "ZPY",
    "ABS",
    "ABSX",
    "ABSY",
    "IND",
    "INDX",
    "INDY",
    "SNGL",
    "BRA"
  ];
  instructionLength = {
    Imm: 2,
    ZP: 2,
    ZPX: 2,
    ZPY: 2,
    ABS: 3,
    ABSX: 3,
    ABSY: 3,
    IND: 3,
    INDX: 2,
    INDY: 2,
    SNGL: 1,
    BRA: 2
  };
  events = new EventDispatcher();
  constructor(memory, labels) {
    this.memory = memory;
    this.labels = labels;
  }
  on(event, listener) {
    this.events.on(event, listener);
  }
  off(event, listener) {
    this.events.off(event, listener);
  }
  once(event, listener) {
    this.events.once(event, listener);
  }
  /**
   * Assembles a single line of code.
   * @param input - The line of code to assemble.
   * @param lineno - The line number (for error reporting).
   * @param symbols - The symbols table.
   * @returns True if assembly was successful, false otherwise.
   */
  assembleLine(input, lineno, symbols) {
    let command, param, addr;
    if (input.match(/^\w+:/)) {
      input.replace(/(^\w+):.*$/, "$1");
      if (input.match(/^\w+:[\s]*\w+.*$/)) {
        input = input.replace(/^\w+:[\s]*(.*)$/, "$1");
        command = input.replace(/^(\w+).*$/, "$1");
      } else {
        command = "";
      }
    } else {
      command = input.replace(/^(\w+).*$/, "$1");
    }
    if (command === "") {
      return true;
    }
    command = command.toUpperCase();
    if (input.match(/^\*\s*=\s*\$?[0-9a-f]*$/)) {
      param = input.replace(/^\s*\*\s*=\s*/, "");
      if (param[0] === "$") {
        param = param.replace(/^\$/, "");
        addr = parseInt(param, 16);
      } else {
        addr = parseInt(param, 10);
      }
      if (addr < 0 || addr > 65535) {
        this.dispatchAssembleFailure("Unable to relocate code outside 64k memory");
        return false;
      }
      this.currentPC = addr;
      return true;
    }
    if (input.match(/^\w+\s+.*?$/)) {
      param = input.replace(/^\w+\s+(.*?)/, "$1");
    } else if (input.match(/^\w+$/)) {
      param = "";
    } else {
      return false;
    }
    param = param.replace(/[ ]/g, "");
    if (command === "DCB") {
      return this.DCB(param);
    }
    for (let o = 0; o < this.opcodes.length; o++) {
      if (this.opcodes[o][0] === command) {
        if (this.checkSingle(param, this.opcodes[o][11])) {
          return true;
        }
        if (this.checkImmediate(param, this.opcodes[o][1], symbols)) {
          return true;
        }
        if (this.checkZeroPage(param, this.opcodes[o][2], symbols)) {
          return true;
        }
        if (this.checkZeroPageX(param, this.opcodes[o][3], symbols)) {
          return true;
        }
        if (this.checkZeroPageY(param, this.opcodes[o][4], symbols)) {
          return true;
        }
        if (this.checkAbsoluteX(param, this.opcodes[o][6], symbols)) {
          return true;
        }
        if (this.checkAbsoluteY(param, this.opcodes[o][7], symbols)) {
          return true;
        }
        if (this.checkIndirect(param, this.opcodes[o][8], symbols)) {
          return true;
        }
        if (this.checkIndirectX(param, this.opcodes[o][9], symbols)) {
          return true;
        }
        if (this.checkIndirectY(param, this.opcodes[o][10], symbols)) {
          return true;
        }
        if (this.checkAbsolute(param, this.opcodes[o][5], symbols)) {
          return true;
        }
        if (this.checkBranch(param, this.opcodes[o][12])) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Assembles the code into memory.
   * @returns True if assembly was successful, false otherwise.
   */
  assembleCode(code) {
    const BOOTSTRAP_ADDRESS = 1536;
    this.wasOutOfRangeBranch = false;
    this.currentPC = BOOTSTRAP_ADDRESS;
    code += "\n";
    const lines = code.split("\n");
    this.codeAssembledOK = true;
    const symbols = this.preprocess(lines);
    this.currentPC = BOOTSTRAP_ADDRESS;
    if (!this.labels.indexLines(lines, symbols, this)) {
      return false;
    }
    this.labels.displayMessage();
    this.currentPC = BOOTSTRAP_ADDRESS;
    this.dispatchInfo("Assembling code ...");
    this.codeLen = 0;
    let i = 0;
    for (i = 0; i < lines.length; i++) {
      if (!this.assembleLine(lines[i], i, symbols)) {
        this.codeAssembledOK = false;
        break;
      }
    }
    const lastLine = lines[i];
    let message = "";
    if (this.codeLen === 0) {
      this.codeAssembledOK = false;
      message = "No code to run.";
    }
    if (!this.codeAssembledOK) {
      if (lastLine) {
        const str = lines[i].replace("<", "&lt;").replace(">", "&gt;");
        if (!this.wasOutOfRangeBranch) {
          message = "**Syntax error line " + (i + 1) + ": " + str + "**";
        } else {
          message = "**Out of range branch on line " + (i + 1) + " (branches are limited to -128 to +127): " + str + "**";
        }
      }
      this.dispatchAssembleFailure(message);
      return false;
    }
    message = "Code assembled successfully, " + this.codeLen + " bytes.";
    this.dispatchAssembleSuccess(message);
    return true;
  }
  /**
   * Generates a hexdump of the assembled code.
   */
  hexdump() {
    this.dispatchHexdump(this.memory.format({ start: 1536, length: this.codeLen, includeAddress: true, includeSpaces: true, includeNewline: true }));
  }
  /**
   * Disassembles the assembled code.
   */
  disassemble() {
    const startAddress = 1536;
    let currentAddress = startAddress;
    const endAddress = startAddress + this.codeLen;
    const instructions = [];
    let length;
    let inst;
    let byte;
    let modeAndCode;
    while (currentAddress < endAddress) {
      inst = this.createInstruction(currentAddress);
      byte = this.memory.get(currentAddress);
      inst.addByte(byte);
      modeAndCode = this.getModeAndCode(byte);
      length = this.instructionLength[modeAndCode.mode];
      inst.setModeAndCode(modeAndCode);
      for (let i = 1; i < length; i++) {
        currentAddress++;
        byte = this.memory.get(currentAddress);
        inst.addByte(byte);
        inst.addArg(byte);
      }
      instructions.push(inst);
      currentAddress++;
    }
    let html = "Address  Hexdump   Disassembly\n";
    html += "-------------------------------\n";
    html += instructions.join("\n");
    this.dispatchDisassembly(html);
  }
  /**
   * Gets the current program counter.
   * @returns The current program counter value.
   */
  getCurrentPC() {
    return this.currentPC;
  }
  dispatchAssembleSuccess(message) {
    this.events.dispatch("assemble-success", { assembler: this, message });
  }
  dispatchAssembleFailure(message) {
    this.events.dispatch("assemble-failure", { assembler: this, message });
  }
  dispatchHexdump(message) {
    this.events.dispatch("hexdump", { assembler: this, message });
  }
  dispatchDisassembly(message) {
    this.events.dispatch("disassembly", { assembler: this, message });
  }
  dispatchInfo(message) {
    this.events.dispatch("assemble-info", { assembler: this, message });
  }
  /**
   * Sanitize input: remove comments and trim leading/trailing whitespace
   */
  sanitize(line) {
    const no_comments = line.replace(/^(.*?);.*/, "$1");
    return no_comments.replace(/^\s+/, "").replace(/\s+$/, "");
  }
  /**
   * Preprocess the assembly code.
   * @param lines - The lines of code to preprocess.
   * @returns A Symbols object containing defined symbols.
   */
  preprocess(lines) {
    this.dispatchInfo("Preprocessing ...");
    const table = {};
    const PREFIX2 = "__";
    function lookup(key) {
      if (table.hasOwnProperty(PREFIX2 + key))
        return table[PREFIX2 + key];
      else
        return void 0;
    }
    function add(key, value) {
      const valueAlreadyExists = table.hasOwnProperty(PREFIX2 + key);
      if (!valueAlreadyExists) {
        table[PREFIX2 + key] = value;
      }
    }
    for (let i = 0; i < lines.length; i++) {
      lines[i] = this.sanitize(lines[i]);
      const match_data = lines[i].match(/^define\s+(\w+)\s+(\S+)/);
      if (match_data) {
        add(match_data[1], this.sanitize(match_data[2]));
        lines[i] = "";
      }
    }
    return {
      lookup
    };
  }
  /**
   * DCB (Define Constant Byte) method
   *
   * This method allows direct definition of data bytes in the assembler code.
   * It processes a comma-separated list of values and writes them to memory.
   *
   * @param param - A string containing comma-separated values
   * @returns true if all values were successfully processed, false otherwise
   *
   * Supported formats:
   * - Hexadecimal: prefixed with "$" (e.g., $FF)
   * - Binary: prefixed with "%" (e.g., %10101010)
   * - Decimal: no prefix, just numbers (e.g., 42)
   *
   * Usage example in 6502 assembly:
   * DCB $FF, $00, %10101010, 42
   *
   * This would write four bytes to memory: 255 (0xFF), 0, 170 (0xAA), and 42.
   */
  DCB(param) {
    let values;
    let number;
    let str;
    let ch;
    values = param.split(",");
    if (values.length === 0) {
      return false;
    }
    for (let v = 0; v < values.length; v++) {
      str = values[v];
      if (str) {
        ch = str.substring(0, 1);
        if (ch === "$") {
          number = parseInt(str.replace(/^\$/, ""), 16);
          this.pushByte(number);
        } else if (ch === "%") {
          number = parseInt(str.replace(/^%/, ""), 2);
          this.pushByte(number);
        } else if (ch >= "0" && ch <= "9") {
          number = parseInt(str, 10);
          this.pushByte(number);
        } else {
          return false;
        }
      }
    }
    return true;
  }
  /**
   * Try to parse the given parameter as a byte operand.
   * Returns the (positive) value if successful, otherwise -1
   */
  tryParseByteOperand(param, symbols) {
    if (param.match(/^\w+$/)) {
      const lookupVal = symbols.lookup(param);
      if (lookupVal) {
        param = lookupVal;
      }
    }
    let value;
    let match_data;
    match_data = param.match(/^([0-9]{1,3})$/);
    if (match_data) {
      value = parseInt(match_data[1], 10);
    }
    match_data = param.match(/^\$([0-9a-f]{1,2})$/i);
    if (match_data) {
      value = parseInt(match_data[1], 16);
    }
    match_data = param.match(/^%([0-1]{1,8})$/);
    if (match_data) {
      value = parseInt(match_data[1], 2);
    }
    if (value === void 0) {
      return -1;
    }
    if (value >= 0 && value <= 255) {
      return value;
    } else {
      return -1;
    }
  }
  /**
   * Try to parse the given parameter as a word operand.
   * Returns the (positive) value if successful, otherwise -1
   */
  tryParseWordOperand(param, symbols) {
    if (param.match(/^\w+$/)) {
      const lookupVal = symbols.lookup(param);
      if (lookupVal) {
        param = lookupVal;
      }
    }
    let value;
    const match_data = param.match(/^\$([0-9a-f]{3,4})$/i);
    if (match_data) {
      value = parseInt(match_data[1], 16);
    } else {
      const match_data2 = param.match(/^([0-9]{1,5})$/i);
      if (match_data2) {
        value = parseInt(match_data2[1], 10);
      }
    }
    if (value === void 0) {
      return -1;
    }
    if (value >= 0 && value <= 65535) {
      return value;
    } else {
      return -1;
    }
  }
  /**
   * Common branch function for all branches (BCC, BCS, BEQ, BNE..)
   */
  checkBranch(param, opcode) {
    let addr;
    if (opcode === null) {
      return false;
    }
    addr = -1;
    if (param.match(/\w+/)) {
      addr = this.labels.getPC(param);
    }
    if (addr === -1) {
      this.pushWord(0);
      return false;
    }
    this.pushByte(opcode);
    const distance = addr - this.currentPC - 1;
    if (distance < -128 || distance > 127) {
      this.wasOutOfRangeBranch = true;
      return false;
    }
    this.pushByte(distance);
    return true;
  }
  /**
   * Check if param is immediate and push value
   */
  checkImmediate(param, opcode, symbols) {
    let label;
    let hilo;
    let addr;
    if (opcode === null) {
      return false;
    }
    const match_data = param.match(/^#([\w\$%]+)$/i);
    if (match_data) {
      const operand = this.tryParseByteOperand(match_data[1], symbols);
      if (operand >= 0) {
        this.pushByte(opcode);
        this.pushByte(operand);
        return true;
      }
    }
    if (param.match(/^#[<>]\w+$/)) {
      label = param.replace(/^#[<>](\w+)$/, "$1");
      hilo = param.replace(/^#([<>]).*$/, "$1");
      this.pushByte(opcode);
      if (this.labels.find(label)) {
        addr = this.labels.getPC(label);
        switch (hilo) {
          case ">":
            this.pushByte(addr >> 8 & 255);
            return true;
          case "<":
            this.pushByte(addr & 255);
            return true;
          default:
            return false;
        }
      } else {
        this.pushByte(0);
        return true;
      }
    }
    return false;
  }
  /**
   * Check if param is indirect and push value
   */
  checkIndirect(param, opcode, symbols) {
    if (opcode === null) {
      return false;
    }
    const match_data = param.match(/^\(([\w\$]+)\)$/i);
    if (match_data) {
      const operand = this.tryParseWordOperand(match_data[1], symbols);
      if (operand >= 0) {
        this.pushByte(opcode);
        this.pushWord(operand);
        return true;
      }
    }
    return false;
  }
  /**
   * Check if param is indirect X and push value
   */
  checkIndirectX(param, opcode, symbols) {
    if (opcode === null) {
      return false;
    }
    const match_data = param.match(/^\(([\w\$]+),X\)$/i);
    if (match_data) {
      const operand = this.tryParseByteOperand(match_data[1], symbols);
      if (operand >= 0) {
        this.pushByte(opcode);
        this.pushByte(operand);
        return true;
      }
    }
    return false;
  }
  /**
   * Check if param is indirect Y and push value
   */
  checkIndirectY(param, opcode, symbols) {
    if (opcode === null) {
      return false;
    }
    const match_data = param.match(/^\(([\w\$]+)\),Y$/i);
    if (match_data) {
      const operand = this.tryParseByteOperand(match_data[1], symbols);
      if (operand >= 0) {
        this.pushByte(opcode);
        this.pushByte(operand);
        return true;
      }
    }
    return false;
  }
  /**
   * Check single-byte opcodes
   */
  checkSingle(param, opcode) {
    if (opcode === null) {
      return false;
    }
    if (param !== "" && param !== "A") {
      return false;
    }
    this.pushByte(opcode);
    return true;
  }
  /**
   * Check if param is ZP and push value
   */
  checkZeroPage(param, opcode, symbols) {
    if (opcode === null) {
      return false;
    }
    const operand = this.tryParseByteOperand(param, symbols);
    if (operand >= 0) {
      this.pushByte(opcode);
      this.pushByte(operand);
      return true;
    }
    return false;
  }
  /**
   * Check if param is ABSX and push value
   */
  checkAbsoluteX(param, opcode, symbols) {
    let addr;
    if (opcode === null) {
      return false;
    }
    const match_data = param.match(/^([\w\$]+),X$/i);
    if (match_data) {
      const operand = this.tryParseWordOperand(match_data[1], symbols);
      if (operand >= 0) {
        this.pushByte(opcode);
        this.pushWord(operand);
        return true;
      }
    }
    if (param.match(/^\w+,X$/i)) {
      param = param.replace(/,X$/i, "");
      this.pushByte(opcode);
      if (this.labels.find(param)) {
        addr = this.labels.getPC(param);
        if (addr < 0 || addr > 65535) {
          return false;
        }
        this.pushWord(addr);
        return true;
      } else {
        this.pushWord(65535);
        return true;
      }
    }
    return false;
  }
  /**
   * Check if param is ABSY and push value
   */
  checkAbsoluteY(param, opcode, symbols) {
    let addr;
    if (opcode === null) {
      return false;
    }
    const match_data = param.match(/^([\w\$]+),Y$/i);
    if (match_data) {
      const operand = this.tryParseWordOperand(match_data[1], symbols);
      if (operand >= 0) {
        this.pushByte(opcode);
        this.pushWord(operand);
        return true;
      }
    }
    if (param.match(/^\w+,Y$/i)) {
      param = param.replace(/,Y$/i, "");
      this.pushByte(opcode);
      if (this.labels.find(param)) {
        addr = this.labels.getPC(param);
        if (addr < 0 || addr > 65535) {
          return false;
        }
        this.pushWord(addr);
        return true;
      } else {
        this.pushWord(65535);
        return true;
      }
    }
    return false;
  }
  /**
   * Check if param is ZPX and push value
   */
  checkZeroPageX(param, opcode, symbols) {
    if (opcode === null) {
      return false;
    }
    const match_data = param.match(/^([\w\$]+),X$/i);
    if (match_data) {
      const operand = this.tryParseByteOperand(match_data[1], symbols);
      if (operand >= 0) {
        this.pushByte(opcode);
        this.pushByte(operand);
        return true;
      }
    }
    return false;
  }
  /**
   * Check if param is ZPY and push value
   */
  checkZeroPageY(param, opcode, symbols) {
    if (opcode === null) {
      return false;
    }
    const match_data = param.match(/^([\w\$]+),Y$/i);
    if (match_data) {
      const operand = this.tryParseByteOperand(match_data[1], symbols);
      if (operand >= 0) {
        this.pushByte(opcode);
        this.pushByte(operand);
        return true;
      }
    }
    return false;
  }
  /**
   * Check if param is ABS and push value
   */
  checkAbsolute(param, opcode, symbols) {
    let addr;
    if (opcode === null) {
      return false;
    }
    const match_data = param.match(/^([\w\$]+)$/i);
    if (match_data) {
      const operand = this.tryParseWordOperand(match_data[1], symbols);
      if (operand >= 0) {
        this.pushByte(opcode);
        this.pushWord(operand);
        return true;
      }
    }
    if (param.match(/^\w+$/)) {
      this.pushByte(opcode);
      if (this.labels.find(param)) {
        addr = this.labels.getPC(param);
        if (addr < 0 || addr > 65535) {
          return false;
        }
        this.pushWord(addr);
        return true;
      } else {
        this.pushWord(65535);
        return true;
      }
    }
    return false;
  }
  /**
   * Push a byte to memory
   */
  pushByte(value) {
    this.memory.set(this.currentPC, value & 255);
    this.currentPC++;
    this.codeLen++;
  }
  /**
   * Push a word to memory in little-endian order
   */
  pushWord(value) {
    this.pushByte(value & 255);
    this.pushByte(value >> 8 & 255);
  }
  getModeAndCode(byte) {
    let index;
    const line = this.opcodes.filter(function(line2) {
      const possibleIndex = line2.indexOf(byte);
      if (possibleIndex > -1) {
        index = possibleIndex;
        return true;
      }
    })[0];
    if (!line) {
      return {
        opCode: "???",
        mode: "SNGL"
      };
    } else {
      if (index === void 0) {
        throw new Error("Index is undefined");
      }
      return {
        opCode: line[0],
        mode: this.addressingModes[index]
      };
    }
  }
  createInstruction(address) {
    const bytes = [];
    let opCode;
    const args = [];
    let mode;
    function isAccumulatorInstruction() {
      const accumulatorBytes = [10, 74, 42, 106];
      if (accumulatorBytes.indexOf(bytes[0]) > -1) {
        return true;
      }
    }
    function isBranchInstruction() {
      return opCode.match(/^B/) && !(opCode == "BIT" || opCode == "BRK");
    }
    function formatArguments(args2) {
      let argsString = args2.map(num2hex).reverse().join("");
      if (isBranchInstruction()) {
        let destination = address + 2;
        if (args2[0] > 127) {
          destination -= 256 - args2[0];
        } else {
          destination += args2[0];
        }
        argsString = addr2hex(destination);
      }
      if (argsString) {
        argsString = "$" + argsString;
      }
      if (mode == "Imm") {
        argsString = "#" + argsString;
      }
      if (mode.match(/X$/)) {
        argsString += ",X";
      }
      if (mode.match(/^IND/)) {
        argsString = "(" + argsString + ")";
      }
      if (mode.match(/Y$/)) {
        argsString += ",Y";
      }
      if (isAccumulatorInstruction()) {
        argsString = "A";
      }
      return argsString;
    }
    return {
      addByte: function(byte) {
        bytes.push(byte);
      },
      setModeAndCode: function(modeAndCode) {
        opCode = modeAndCode.opCode;
        mode = modeAndCode.mode;
      },
      addArg: function(arg) {
        args.push(arg);
      },
      toString: function() {
        const bytesString = bytes.map(num2hex).join(" ");
        const padding = Array(11 - bytesString.length).join(" ");
        return "$" + addr2hex(address) + "    " + bytesString + padding + opCode + " " + formatArguments(args);
      }
    };
  }
}
class Labels {
  labelIndex = [];
  events = new EventDispatcher();
  /**
   * Creates a new Labels instance.
   */
  constructor() {
  }
  on(event, listener) {
    this.events.on(event, listener);
  }
  off(event, listener) {
    this.events.off(event, listener);
  }
  once(event, listener) {
    this.events.once(event, listener);
  }
  /**
   * Checks if a label exists.
   * @param name - Label name to find.
   * @returns True if label exists, false otherwise.
   */
  find(name) {
    return this.labelIndex.some((label) => label.split("|")[0] === name);
  }
  /**
   * Associates a label with an address.
   * @param name - Label name.
   * @param addr - Address to associate with the label.
   * @returns True if label was found and updated, false otherwise.
   */
  setPC(name, addr) {
    const index = this.labelIndex.findIndex((label) => label.split("|")[0] === name);
    if (index !== -1) {
      this.labelIndex[index] = `${name}|${addr}`;
      return true;
    }
    return false;
  }
  /**
   * Gets the address associated with a label.
   * @param name - Label name.
   * @returns The address associated with the label, or -1 if not found.
   */
  getPC(name) {
    const label = this.labelIndex.find((label2) => label2.split("|")[0] === name);
    return label ? Number(label.split("|")[1]) : -1;
  }
  /**
   * Displays a message about the number of labels found.
   */
  displayMessage() {
    const count = this.labelIndex.length;
    const plural = count !== 1 ? "s" : "";
    this.dispatchInfo(`Found ${count} label${plural}.`);
  }
  /**
   * Resets the label index.
   */
  reset() {
    this.labelIndex = [];
  }
  /**
   * Indexes labels from assembly code lines.
   * @param lines - Array of assembly code lines.
   * @param symbols - Symbols object for lookup.
   * @param assembler - Assembler instance.
   * @returns True if indexing was successful, false otherwise.
   */
  indexLines(lines, symbols, assembler) {
    this.dispatchInfo("Indexing labels...");
    for (let i = 0; i < lines.length; i++) {
      if (!this.indexLine(lines[i], symbols, assembler)) {
        this.dispatchFailure(`**Label already defined at line ${i + 1}:** ${lines[i]}`);
        return false;
      }
    }
    return true;
  }
  dispatchInfo(message) {
    this.events.dispatch("labels-info", { labels: this, message });
  }
  dispatchFailure(message) {
    this.events.dispatch("labels-failure", { labels: this, message });
  }
  /**
   * Extracts label from a line and calculates its position in memory.
   * @param input - Single line of assembly code.
   * @param symbols - Symbols object for lookup.
   * @param assembler - Assembler instance.
   * @returns False if label already exists, true otherwise.
   */
  indexLine(input, symbols, assembler) {
    const currentPC = assembler.getCurrentPC();
    assembler.assembleLine(input, 0, symbols);
    if (input.match(/^\w+:/)) {
      const label = input.replace(/(^\w+):.*$/, "$1");
      if (symbols.lookup(label)) {
        this.dispatchFailure(`**Label ${label} is already used as a symbol; please rename one of them**`);
        return false;
      }
      return this.push(`${label}|${currentPC}`);
    }
    return true;
  }
  /**
   * Adds a label to the index.
   * @param name - Label name and address separated by '|'.
   * @returns False if label already exists, true otherwise.
   */
  push(name) {
    if (this.find(name.split("|")[0])) {
      return false;
    }
    this.labelIndex.push(`${name}|`);
    return true;
  }
}
class Memory {
  memArray;
  events = new EventDispatcher();
  /**
   * Creates a new Memory instance.
   */
  constructor() {
    this.memArray = new Array(1536);
    this.storeKeypress = this.storeKeypress.bind(this);
  }
  on(event, listener) {
    this.events.on(event, listener);
  }
  off(event, listener) {
    this.events.off(event, listener);
  }
  once(event, listener) {
    this.events.once(event, listener);
  }
  /**
   * Sets a value at a specific memory address.
   * @param addr - The memory address.
   * @param val - The value to set.
   */
  set(addr, val) {
    this.memArray[addr] = val;
    this.events.dispatch("changed", { addr, val });
  }
  /**
   * Gets the value at a specific memory address.
   * @param addr - The memory address.
   * @returns The value at the specified address.
   */
  get(addr) {
    return this.memArray[addr];
  }
  /**
   * Gets a 16-bit word from memory.
   * @param addr - The starting memory address.
   * @returns The 16-bit word value.
   */
  getWord(addr) {
    return this.get(addr) + (this.get(addr + 1) << 8);
  }
  /**
   * Stores a byte in memory and updates the display if necessary.
   * @param addr - The memory address.
   * @param value - The value to store.
   */
  storeByte(addr, value) {
    this.set(addr, value & 255);
  }
  /**
   * Stores a keypress in memory.
   * Note: Used in the snake game example to control the snake with w-a-s-d keys.
   * @param value - The value to store.
   */
  storeKeypress(value) {
    this.storeByte(255, value);
  }
  /**
   * Formats a section of memory for display
   * @param start - The starting memory address.
   * @param length - The number of bytes to format.
   * @returns A formatted string representation of the memory section.
   */
  format(options) {
    let text = "";
    let n;
    for (let x = 0; x < options.length; x++) {
      if ((x & 15) === 0) {
        if (options.includeNewline && x > 0) {
          text += "\n";
        }
        if (options.includeAddress) {
          n = options.start + x;
          text += num2hex(n >> 8 & 255);
          text += num2hex(n & 255);
          text += ": ";
        }
      }
      text += num2hex(this.get(options.start + x));
      if (options.includeSpaces) {
        text += " ";
      }
    }
    return text;
  }
}
class Simulator {
  memory;
  labels;
  regA = 0;
  regX = 0;
  regY = 0;
  regP = 0;
  regPC = 1536;
  regSP = 255;
  _codeRunning = false;
  /** If true, the simulator will execute one instruction step by step triggered by the debugger. */
  stepper = false;
  executeId;
  events = new EventDispatcher();
  constructor(memory, labels) {
    this.memory = memory;
    this.labels = labels;
  }
  on(event, listener) {
    this.events.on(event, listener);
  }
  off(event, listener) {
    this.events.off(event, listener);
  }
  once(event, listener) {
    this.events.once(event, listener);
  }
  get codeRunning() {
    return this._codeRunning;
  }
  get info() {
    return {
      regA: this.regA,
      regX: this.regX,
      regY: this.regY,
      regP: this.regP,
      regPC: this.regPC,
      regSP: this.regSP
    };
  }
  get stepperEnabled() {
    return this.stepper;
  }
  /**
   * Stop the debugger.
   */
  stopStepper() {
    this.stepper = false;
  }
  /**
   * Enable the debugger.
   */
  enableStepper() {
    this.stepper = true;
    if (this.codeRunning) ;
  }
  /**
   * Execute one instruction and print values.
   */
  debugExecStep() {
    this.execute(true);
  }
  /**
   * Set PC to address (or address of label).
   * @param inp - The address or label to jump to.
   */
  gotoAddr(inp) {
    let addr = 0;
    if (!inp) {
      this.dispatchSimulatorFailureEvent("No address or label provided");
      return;
    }
    if (this.labels.find(inp)) {
      addr = this.labels.getPC(inp);
    } else {
      if (inp.match(/^0x[0-9a-f]{1,4}$/i)) {
        inp = inp.replace(/^0x/, "");
        addr = parseInt(inp, 16);
      } else if (inp.match(/^\$[0-9a-f]{1,4}$/i)) {
        inp = inp.replace(/^\$/, "");
        addr = parseInt(inp, 16);
      }
    }
    if (addr === 0) {
      this.dispatchSimulatorFailureEvent("Unable to find/parse given address/label");
    } else {
      this.regPC = addr;
    }
    this.dispatchGotoEvent();
  }
  /**
   * Reset CPU and memory.
   */
  reset() {
    for (let i = 0; i < 1536; i++) {
      this.memory.set(i, 0);
    }
    this.regA = this.regX = this.regY = 0;
    this.regPC = 1536;
    this.regSP = 255;
    this.regP = 48;
    this.dispatchResetEvent();
  }
  /**
   * Stop the CPU simulator.
   */
  stop(message = "") {
    message = "\nStopped\n" + message;
    this._codeRunning = false;
    clearInterval(this.executeId);
    this.dispatchStopEvent(message);
  }
  dispatchStepEvent(message) {
    this.events.dispatch("step", { simulator: this, message });
  }
  dispatchMultiStepEvent(message) {
    this.events.dispatch("multistep", { simulator: this, message });
  }
  dispatchResetEvent(message) {
    this.events.dispatch("reset", { simulator: this, message });
  }
  dispatchStartEvent(message) {
    this.events.dispatch("start", { simulator: this, message });
  }
  dispatchStopEvent(message) {
    this.events.dispatch("stop", { simulator: this, message });
  }
  dispatchGotoEvent(message) {
    this.events.dispatch("goto", { simulator: this, message });
  }
  dispatchSimulatorFailureEvent(message) {
    this.events.dispatch("simulator-failure", { simulator: this, message });
  }
  dispatchSimulatorInfoEvent(message) {
    this.events.dispatch("simulator-info", { simulator: this, message });
  }
  dispatchPseudoOpEvent(type, message) {
    this.events.dispatch("pseudo-op", { simulator: this, type, message });
  }
  /**
   * Set zero and negative processor flags based on result.
   */
  setNVflags(value) {
    if (value) {
      this.regP &= 253;
    } else {
      this.regP |= 2;
    }
    if (value & 128) {
      this.regP |= 128;
    } else {
      this.regP &= 127;
    }
  }
  /**
   * Sets the carry flag based on bit 0 of the given value.
   * This is used in operations like LSR (Logical Shift Right).
   * @param value - The value to extract the carry flag from.
   */
  setCarryFlagFromBit0(value) {
    this.regP = this.regP & 254 | value & 1;
  }
  /**
   * Sets the carry flag based on bit 7 of the given value.
   * This is used in operations like ASL (Arithmetic Shift Left).
   * @param value - The value to extract the carry flag from.
   */
  setCarryFlagFromBit7(value) {
    this.regP = this.regP & 254 | value >> 7 & 1;
  }
  /**
   * Sets the Negative (N) and Overflow (V) flags based on the current value in the A register.
   * This is called after operations that modify the A register.
   */
  setNVflagsForRegA() {
    this.setNVflags(this.regA);
  }
  /**
   * Sets the Negative (N) and Overflow (V) flags based on the current value in the X register.
   * This is called after operations that modify the X register.
   */
  setNVflagsForRegX() {
    this.setNVflags(this.regX);
  }
  /**
   * Sets the Negative (N) and Overflow (V) flags based on the current value in the Y register.
   * This is called after operations that modify the Y register.
   */
  setNVflagsForRegY() {
    this.setNVflags(this.regY);
  }
  /**
   * ORA - "OR" Memory with Accumulator
   * The ORA instruction performs a bitwise OR operation between the accumulator and a value from memory.
   * It affects the Negative (N) and Zero (Z) flags.
   */
  ORA = this.setNVflagsForRegA;
  /**
   * AND - "AND" Memory with Accumulator
   * The AND instruction performs a bitwise AND operation between the accumulator and a value from memory.
   * It affects the Negative (N) and Zero (Z) flags.
   */
  AND = this.setNVflagsForRegA;
  /**
   * EOR - "Exclusive OR" Memory with Accumulator
   * The EOR instruction performs a bitwise XOR operation between the accumulator and a value from memory.
   * It affects the Negative (N) and Zero (Z) flags.
   */
  EOR = this.setNVflagsForRegA;
  /**
   * ASL - Arithmetic Shift Left
   * The ASL instruction shifts all bits left one position. 0 is shifted into bit 0 and the original bit 7 is shifted into the Carry.
   * It affects the Negative (N), Zero (Z), and Carry (C) flags.
   */
  ASL = this.setNVflags;
  /**
   * LSR - Logical Shift Right
   * The LSR instruction shifts all bits right one position. 0 is shifted into bit 7 and the original bit 0 is shifted into the Carry.
   * It affects the Negative (N), Zero (Z), and Carry (C) flags.
   */
  LSR = this.setNVflags;
  /**
   * ROL - Rotate Left
   * The ROL instruction shifts all bits left one position. The Carry is shifted into bit 0 and the original bit 7 is shifted into the Carry.
   * It affects the Negative (N), Zero (Z), and Carry (C) flags.
   */
  ROL = this.setNVflags;
  /**
   * ROR - Rotate Right
   * The ROR instruction shifts all bits right one position. The Carry is shifted into bit 7 and the original bit 0 is shifted into the Carry.
   * It affects the Negative (N), Zero (Z), and Carry (C) flags.
   */
  ROR = this.setNVflags;
  /**
   * LDA - Load Accumulator
   * The LDA instruction loads a byte of memory into the accumulator setting the zero and negative flags as appropriate.
   * It affects the Negative (N) and Zero (Z) flags.
   */
  LDA = this.setNVflagsForRegA;
  /**
   * LDX - Load X Register
   * The LDX instruction loads a byte of memory into the X register setting the zero and negative flags as appropriate.
   * It affects the Negative (N) and Zero (Z) flags.
   */
  LDX = this.setNVflagsForRegX;
  /**
   * LDY - Load Y Register
   * The LDY instruction loads a byte of memory into the Y register setting the zero and negative flags as appropriate.
   * It affects the Negative (N) and Zero (Z) flags.
   */
  LDY = this.setNVflagsForRegY;
  /**
   * Implements the BIT (Bit Test) instruction.
   * This instruction performs a bitwise AND between the accumulator (A) and the specified value,
   * but does not store the result. It affects the following flags:
   * - Negative (N) flag: Set to bit 7 of the value.
   * - Overflow (V) flag: Set to bit 6 of the value.
   * - Zero (Z) flag: Set if the result of A AND value is zero.
   *
   * @param value - The value to test against the accumulator.
   */
  BIT(value) {
    if (value & 128) {
      this.regP |= 128;
    } else {
      this.regP &= 127;
    }
    if (value & 64) {
      this.regP |= 64;
    } else {
      this.regP &= ~64;
    }
    if (this.regA & value) {
      this.regP &= 253;
    } else {
      this.regP |= 2;
    }
  }
  /**
   * Clear Carry Flag
   * Sets the carry flag to 0
   */
  CLC() {
    this.regP &= 254;
  }
  /**
   * Set Carry Flag
   * Sets the carry flag to 1
   */
  SEC() {
    this.regP |= 1;
  }
  /**
   * Clear Overflow Flag
   * Sets the overflow flag to 0
   */
  CLV() {
    this.regP &= 191;
  }
  setOverflow() {
    this.regP |= 64;
  }
  DEC(addr) {
    let value = this.memory.get(addr);
    value--;
    value &= 255;
    this.memory.storeByte(addr, value);
    this.setNVflags(value);
  }
  INC(addr) {
    let value = this.memory.get(addr);
    value++;
    value &= 255;
    this.memory.storeByte(addr, value);
    this.setNVflags(value);
  }
  jumpBranch(offset) {
    if (offset > 127) {
      this.regPC = this.regPC - (256 - offset);
    } else {
      this.regPC = this.regPC + offset;
    }
  }
  overflowSet() {
    return this.regP & 64;
  }
  decimalMode() {
    return this.regP & 8;
  }
  carrySet() {
    return this.regP & 1;
  }
  negativeSet() {
    return this.regP & 128;
  }
  zeroSet() {
    return this.regP & 2;
  }
  doCompare(reg, val) {
    if (reg >= val) {
      this.SEC();
    } else {
      this.CLC();
    }
    val = reg - val;
    this.setNVflags(val);
  }
  testSBC(value) {
    let tmp, w;
    if ((this.regA ^ value) & 128) {
      this.setOverflow();
    } else {
      this.CLV();
    }
    if (this.decimalMode()) {
      tmp = 15 + (this.regA & 15) - (value & 15) + this.carrySet();
      if (tmp < 16) {
        w = 0;
        tmp -= 6;
      } else {
        w = 16;
        tmp -= 16;
      }
      w += 240 + (this.regA & 240) - (value & 240);
      if (w < 256) {
        this.CLC();
        if (this.overflowSet() && w < 128) {
          this.CLV();
        }
        w -= 96;
      } else {
        this.SEC();
        if (this.overflowSet() && w >= 384) {
          this.CLV();
        }
      }
      w += tmp;
    } else {
      w = 255 + this.regA - value + this.carrySet();
      if (w < 256) {
        this.CLC();
        if (this.overflowSet() && w < 128) {
          this.CLV();
        }
      } else {
        this.SEC();
        if (this.overflowSet() && w >= 384) {
          this.CLV();
        }
      }
    }
    this.regA = w & 255;
    this.setNVflagsForRegA();
  }
  testADC(value) {
    let tmp;
    if ((this.regA ^ value) & 128) {
      this.CLV();
    } else {
      this.setOverflow();
    }
    if (this.decimalMode()) {
      tmp = (this.regA & 15) + (value & 15) + this.carrySet();
      if (tmp >= 10) {
        tmp = 16 | tmp + 6 & 15;
      }
      tmp += (this.regA & 240) + (value & 240);
      if (tmp >= 160) {
        this.SEC();
        if (this.overflowSet() && tmp >= 384) {
          this.CLV();
        }
        tmp += 96;
      } else {
        this.CLC();
        if (this.overflowSet() && tmp < 128) {
          this.CLV();
        }
      }
    } else {
      tmp = this.regA + value + this.carrySet();
      if (tmp >= 256) {
        this.SEC();
        if (this.overflowSet() && tmp >= 384) {
          this.CLV();
        }
      } else {
        this.CLC();
        if (this.overflowSet() && tmp < 128) {
          this.CLV();
        }
      }
    }
    this.regA = tmp & 255;
    this.setNVflagsForRegA();
  }
  instructions = {
    i00: () => {
      this._codeRunning = false;
    },
    i01: () => {
      const zp = this.popByte() + this.regX & 255;
      const addr = this.memory.getWord(zp);
      const value = this.memory.get(addr);
      this.regA |= value;
      this.ORA();
    },
    i05: () => {
      const zp = this.popByte();
      this.regA |= this.memory.get(zp);
      this.ORA();
    },
    i06: () => {
      const zp = this.popByte();
      let value = this.memory.get(zp);
      this.setCarryFlagFromBit7(value);
      value = value << 1 & 255;
      this.memory.storeByte(zp, value);
      this.ASL(value);
    },
    i08: () => {
      this.stackPush(this.regP | 48);
    },
    i09: () => {
      this.regA |= this.popByte();
      this.ORA();
    },
    i0a: () => {
      this.setCarryFlagFromBit7(this.regA);
      this.regA = this.regA << 1 & 255;
      this.ASL(this.regA);
    },
    i0d: () => {
      this.regA |= this.memory.get(this.popWord());
      this.ORA();
    },
    i0e: () => {
      const addr = this.popWord();
      let value = this.memory.get(addr);
      this.setCarryFlagFromBit7(value);
      value = value << 1 & 255;
      this.memory.storeByte(addr, value);
      this.ASL(value);
    },
    i10: () => {
      const offset = this.popByte();
      if (!this.negativeSet()) {
        this.jumpBranch(offset);
      }
    },
    i11: () => {
      const zp = this.popByte();
      const value = this.memory.getWord(zp) + this.regY;
      this.regA |= this.memory.get(value);
      this.ORA();
    },
    i15: () => {
      const addr = this.popByte() + this.regX & 255;
      this.regA |= this.memory.get(addr);
      this.ORA();
    },
    i16: () => {
      const addr = this.popByte() + this.regX & 255;
      let value = this.memory.get(addr);
      this.setCarryFlagFromBit7(value);
      value = value << 1 & 255;
      this.memory.storeByte(addr, value);
      this.ASL(value);
    },
    i18: () => {
      this.CLC();
    },
    i19: () => {
      const addr = this.popWord() + this.regY;
      this.regA |= this.memory.get(addr);
      this.ORA();
    },
    i1d: () => {
      const addr = this.popWord() + this.regX;
      this.regA |= this.memory.get(addr);
      this.ORA();
    },
    i1e: () => {
      const addr = this.popWord() + this.regX;
      let value = this.memory.get(addr);
      this.setCarryFlagFromBit7(value);
      value = value << 1 & 255;
      this.memory.storeByte(addr, value);
      this.ASL(value);
    },
    i20: () => {
      const addr = this.popWord();
      const currAddr = this.regPC - 1;
      this.stackPush(currAddr >> 8 & 255);
      this.stackPush(currAddr & 255);
      this.regPC = addr;
    },
    i21: () => {
      const zp = this.popByte() + this.regX & 255;
      const addr = this.memory.getWord(zp);
      let value = this.memory.get(addr);
      this.regA &= value;
      this.AND();
    },
    i24: () => {
      const zp = this.popByte();
      const value = this.memory.get(zp);
      this.BIT(value);
    },
    i25: () => {
      const zp = this.popByte();
      this.regA &= this.memory.get(zp);
      this.AND();
    },
    i26: () => {
      const sf = this.carrySet();
      const addr = this.popByte();
      let value = this.memory.get(addr);
      this.setCarryFlagFromBit7(value);
      value = value << 1 & 255;
      value |= sf;
      this.memory.storeByte(addr, value);
      this.ROL(value);
    },
    i28: () => {
      this.regP = this.stackPop() | 48;
    },
    i29: () => {
      this.regA &= this.popByte();
      this.AND();
    },
    i2a: () => {
      const sf = this.carrySet();
      this.setCarryFlagFromBit7(this.regA);
      this.regA = this.regA << 1 & 255;
      this.regA |= sf;
      this.ROL(this.regA);
    },
    i2c: () => {
      const value = this.memory.get(this.popWord());
      this.BIT(value);
    },
    i2d: () => {
      const value = this.memory.get(this.popWord());
      this.regA &= value;
      this.AND();
    },
    i2e: () => {
      const sf = this.carrySet();
      const addr = this.popWord();
      let value = this.memory.get(addr);
      this.setCarryFlagFromBit7(value);
      value = value << 1 & 255;
      value |= sf;
      this.memory.storeByte(addr, value);
      this.ROL(value);
    },
    i30: () => {
      const offset = this.popByte();
      if (this.negativeSet()) {
        this.jumpBranch(offset);
      }
    },
    i31: () => {
      const zp = this.popByte();
      const value = this.memory.getWord(zp) + this.regY;
      this.regA &= this.memory.get(value);
      this.AND();
    },
    i35: () => {
      const addr = this.popByte() + this.regX & 255;
      this.regA &= this.memory.get(addr);
      this.AND();
    },
    i36: () => {
      const sf = this.carrySet();
      const addr = this.popByte() + this.regX & 255;
      let value = this.memory.get(addr);
      this.setCarryFlagFromBit7(value);
      value = value << 1 & 255;
      value |= sf;
      this.memory.storeByte(addr, value);
      this.ROL(value);
    },
    i38: () => {
      this.SEC();
    },
    i39: () => {
      const addr = this.popWord() + this.regY;
      const value = this.memory.get(addr);
      this.regA &= value;
      this.AND();
    },
    i3d: () => {
      const addr = this.popWord() + this.regX;
      const value = this.memory.get(addr);
      this.regA &= value;
      this.AND();
    },
    i3e: () => {
      const sf = this.carrySet();
      const addr = this.popWord() + this.regX;
      let value = this.memory.get(addr);
      this.setCarryFlagFromBit7(value);
      value = value << 1 & 255;
      value |= sf;
      this.memory.storeByte(addr, value);
      this.ROL(value);
    },
    i40: () => {
      this.regP = this.stackPop() | 48;
      this.regPC = this.stackPop() | this.stackPop() << 8;
    },
    i41: () => {
      const zp = this.popByte() + this.regX & 255;
      const value = this.memory.getWord(zp);
      this.regA ^= this.memory.get(value);
      this.EOR();
    },
    i45: () => {
      const addr = this.popByte() & 255;
      const value = this.memory.get(addr);
      this.regA ^= value;
      this.EOR();
    },
    i46: () => {
      const addr = this.popByte() & 255;
      let value = this.memory.get(addr);
      this.setCarryFlagFromBit0(value);
      value = value >> 1;
      this.memory.storeByte(addr, value);
      this.LSR(value);
    },
    i48: () => {
      this.stackPush(this.regA);
    },
    i49: () => {
      this.regA ^= this.popByte();
      this.EOR();
    },
    i4a: () => {
      this.setCarryFlagFromBit0(this.regA);
      this.regA = this.regA >> 1;
      this.LSR(this.regA);
    },
    i4c: () => {
      this.regPC = this.popWord();
    },
    i4d: () => {
      const addr = this.popWord();
      const value = this.memory.get(addr);
      this.regA ^= value;
      this.EOR();
    },
    i4e: () => {
      const addr = this.popWord();
      let value = this.memory.get(addr);
      this.setCarryFlagFromBit0(value);
      value = value >> 1;
      this.memory.storeByte(addr, value);
      this.LSR(value);
    },
    i50: () => {
      const offset = this.popByte();
      if (!this.overflowSet()) {
        this.jumpBranch(offset);
      }
    },
    i51: () => {
      const zp = this.popByte();
      const value = this.memory.getWord(zp) + this.regY;
      this.regA ^= this.memory.get(value);
      this.EOR();
    },
    i55: () => {
      const addr = this.popByte() + this.regX & 255;
      this.regA ^= this.memory.get(addr);
      this.EOR();
    },
    i56: () => {
      const addr = this.popByte() + this.regX & 255;
      let value = this.memory.get(addr);
      this.setCarryFlagFromBit0(value);
      value = value >> 1;
      this.memory.storeByte(addr, value);
      this.LSR(value);
    },
    i58: () => {
      this.regP &= ~4;
      throw new Error("Interrupts not implemented");
    },
    i59: () => {
      const addr = this.popWord() + this.regY;
      const value = this.memory.get(addr);
      this.regA ^= value;
      this.EOR();
    },
    i5d: () => {
      const addr = this.popWord() + this.regX;
      const value = this.memory.get(addr);
      this.regA ^= value;
      this.EOR();
    },
    i5e: () => {
      const addr = this.popWord() + this.regX;
      let value = this.memory.get(addr);
      this.setCarryFlagFromBit0(value);
      value = value >> 1;
      this.memory.storeByte(addr, value);
      this.LSR(value);
    },
    i60: () => {
      this.regPC = (this.stackPop() | this.stackPop() << 8) + 1;
    },
    i61: () => {
      const zp = this.popByte() + this.regX & 255;
      const addr = this.memory.getWord(zp);
      const value = this.memory.get(addr);
      this.testADC(value);
    },
    i65: () => {
      const addr = this.popByte();
      const value = this.memory.get(addr);
      this.testADC(value);
    },
    i66: () => {
      const sf = this.carrySet();
      const addr = this.popByte();
      let value = this.memory.get(addr);
      this.setCarryFlagFromBit0(value);
      value = value >> 1;
      if (sf) {
        value |= 128;
      }
      this.memory.storeByte(addr, value);
      this.ROR(value);
    },
    i68: () => {
      this.regA = this.stackPop();
      this.setNVflagsForRegA();
    },
    i69: () => {
      const value = this.popByte();
      this.testADC(value);
    },
    i6a: () => {
      const sf = this.carrySet();
      this.setCarryFlagFromBit0(this.regA);
      this.regA = this.regA >> 1;
      if (sf) {
        this.regA |= 128;
      }
      this.ROR(this.regA);
    },
    i6c: () => {
      this.regPC = this.memory.getWord(this.popWord());
    },
    i6d: () => {
      const addr = this.popWord();
      const value = this.memory.get(addr);
      this.testADC(value);
    },
    i6e: () => {
      const sf = this.carrySet();
      const addr = this.popWord();
      let value = this.memory.get(addr);
      this.setCarryFlagFromBit0(value);
      value = value >> 1;
      if (sf) {
        value |= 128;
      }
      this.memory.storeByte(addr, value);
      this.ROR(value);
    },
    i70: () => {
      const offset = this.popByte();
      if (this.overflowSet()) {
        this.jumpBranch(offset);
      }
    },
    i71: () => {
      const zp = this.popByte();
      const addr = this.memory.getWord(zp);
      const value = this.memory.get(addr + this.regY);
      this.testADC(value);
    },
    i75: () => {
      const addr = this.popByte() + this.regX & 255;
      const value = this.memory.get(addr);
      this.testADC(value);
    },
    i76: () => {
      const sf = this.carrySet();
      const addr = this.popByte() + this.regX & 255;
      let value = this.memory.get(addr);
      this.setCarryFlagFromBit0(value);
      value = value >> 1;
      if (sf) {
        value |= 128;
      }
      this.memory.storeByte(addr, value);
      this.ROR(value);
    },
    i78: () => {
      this.regP |= 4;
      throw new Error("Interrupts not implemented");
    },
    i79: () => {
      const addr = this.popWord();
      const value = this.memory.get(addr + this.regY);
      this.testADC(value);
    },
    i7d: () => {
      const addr = this.popWord();
      const value = this.memory.get(addr + this.regX);
      this.testADC(value);
    },
    i7e: () => {
      const sf = this.carrySet();
      const addr = this.popWord() + this.regX;
      let value = this.memory.get(addr);
      this.setCarryFlagFromBit0(value);
      value = value >> 1;
      if (sf) {
        value |= 128;
      }
      this.memory.storeByte(addr, value);
      this.ROR(value);
    },
    i81: () => {
      const zp = this.popByte() + this.regX & 255;
      const addr = this.memory.getWord(zp);
      this.memory.storeByte(addr, this.regA);
    },
    i84: () => {
      this.memory.storeByte(this.popByte(), this.regY);
    },
    i85: () => {
      this.memory.storeByte(this.popByte(), this.regA);
    },
    i86: () => {
      this.memory.storeByte(this.popByte(), this.regX);
    },
    i88: () => {
      this.regY = this.regY - 1 & 255;
      this.setNVflagsForRegY();
    },
    i8a: () => {
      this.regA = this.regX & 255;
      this.setNVflagsForRegA();
    },
    i8c: () => {
      this.memory.storeByte(this.popWord(), this.regY);
    },
    i8d: () => {
      this.memory.storeByte(this.popWord(), this.regA);
    },
    i8e: () => {
      this.memory.storeByte(this.popWord(), this.regX);
    },
    i90: () => {
      const offset = this.popByte();
      if (!this.carrySet()) {
        this.jumpBranch(offset);
      }
    },
    i91: () => {
      const zp = this.popByte();
      const addr = this.memory.getWord(zp) + this.regY;
      this.memory.storeByte(addr, this.regA);
    },
    i94: () => {
      this.memory.storeByte(this.popByte() + this.regX & 255, this.regY);
    },
    i95: () => {
      this.memory.storeByte(this.popByte() + this.regX & 255, this.regA);
    },
    i96: () => {
      this.memory.storeByte(this.popByte() + this.regY & 255, this.regX);
    },
    i98: () => {
      this.regA = this.regY & 255;
      this.setNVflagsForRegA();
    },
    i99: () => {
      this.memory.storeByte(this.popWord() + this.regY, this.regA);
    },
    i9a: () => {
      this.regSP = this.regX & 255;
    },
    i9d: () => {
      const addr = this.popWord();
      this.memory.storeByte(addr + this.regX, this.regA);
    },
    ia0: () => {
      this.regY = this.popByte();
      this.LDY();
    },
    ia1: () => {
      const zp = this.popByte() + this.regX & 255;
      const addr = this.memory.getWord(zp);
      this.regA = this.memory.get(addr);
      this.LDA();
    },
    ia2: () => {
      this.regX = this.popByte();
      this.LDX();
    },
    ia4: () => {
      this.regY = this.memory.get(this.popByte());
      this.LDY();
    },
    ia5: () => {
      this.regA = this.memory.get(this.popByte());
      this.LDA();
    },
    ia6: () => {
      this.regX = this.memory.get(this.popByte());
      this.LDX();
    },
    ia8: () => {
      this.regY = this.regA & 255;
      this.setNVflagsForRegY();
    },
    ia9: () => {
      this.regA = this.popByte();
      this.LDA();
    },
    iaa: () => {
      this.regX = this.regA & 255;
      this.setNVflagsForRegX();
    },
    iac: () => {
      this.regY = this.memory.get(this.popWord());
      this.LDY();
    },
    iad: () => {
      this.regA = this.memory.get(this.popWord());
      this.LDA();
    },
    iae: () => {
      this.regX = this.memory.get(this.popWord());
      this.LDX();
    },
    ib0: () => {
      const offset = this.popByte();
      if (this.carrySet()) {
        this.jumpBranch(offset);
      }
    },
    ib1: () => {
      const zp = this.popByte();
      const addr = this.memory.getWord(zp) + this.regY;
      this.regA = this.memory.get(addr);
      this.LDA();
    },
    ib4: () => {
      this.regY = this.memory.get(this.popByte() + this.regX & 255);
      this.LDY();
    },
    ib5: () => {
      this.regA = this.memory.get(this.popByte() + this.regX & 255);
      this.LDA();
    },
    ib6: () => {
      this.regX = this.memory.get(this.popByte() + this.regY & 255);
      this.LDX();
    },
    ib8: () => {
      this.CLV();
    },
    ib9: () => {
      const addr = this.popWord() + this.regY;
      this.regA = this.memory.get(addr);
      this.LDA();
    },
    iba: () => {
      this.regX = this.regSP & 255;
      this.LDX();
    },
    ibc: () => {
      const addr = this.popWord() + this.regX;
      this.regY = this.memory.get(addr);
      this.LDY();
    },
    ibd: () => {
      const addr = this.popWord() + this.regX;
      this.regA = this.memory.get(addr);
      this.LDA();
    },
    ibe: () => {
      const addr = this.popWord() + this.regY;
      this.regX = this.memory.get(addr);
      this.LDX();
    },
    ic0: () => {
      const value = this.popByte();
      this.doCompare(this.regY, value);
    },
    ic1: () => {
      const zp = this.popByte() + this.regX & 255;
      const addr = this.memory.getWord(zp);
      const value = this.memory.get(addr);
      this.doCompare(this.regA, value);
    },
    ic4: () => {
      const value = this.memory.get(this.popByte());
      this.doCompare(this.regY, value);
    },
    ic5: () => {
      const value = this.memory.get(this.popByte());
      this.doCompare(this.regA, value);
    },
    ic6: () => {
      const zp = this.popByte();
      this.DEC(zp);
    },
    ic8: () => {
      this.regY = this.regY + 1 & 255;
      this.setNVflagsForRegY();
    },
    ic9: () => {
      const value = this.popByte();
      this.doCompare(this.regA, value);
    },
    ica: () => {
      this.regX = this.regX - 1 & 255;
      this.setNVflagsForRegX();
    },
    icc: () => {
      const value = this.memory.get(this.popWord());
      this.doCompare(this.regY, value);
    },
    icd: () => {
      const value = this.memory.get(this.popWord());
      this.doCompare(this.regA, value);
    },
    ice: () => {
      const addr = this.popWord();
      this.DEC(addr);
    },
    id0: () => {
      const offset = this.popByte();
      if (!this.zeroSet()) {
        this.jumpBranch(offset);
      }
    },
    id1: () => {
      const zp = this.popByte();
      const addr = this.memory.getWord(zp) + this.regY;
      const value = this.memory.get(addr);
      this.doCompare(this.regA, value);
    },
    id5: () => {
      const value = this.memory.get(this.popByte() + this.regX & 255);
      this.doCompare(this.regA, value);
    },
    id6: () => {
      const addr = this.popByte() + this.regX & 255;
      this.DEC(addr);
    },
    id8: () => {
      this.regP &= 247;
    },
    id9: () => {
      const addr = this.popWord() + this.regY;
      const value = this.memory.get(addr);
      this.doCompare(this.regA, value);
    },
    idd: () => {
      const addr = this.popWord() + this.regX;
      const value = this.memory.get(addr);
      this.doCompare(this.regA, value);
    },
    ide: () => {
      const addr = this.popWord() + this.regX;
      this.DEC(addr);
    },
    ie0: () => {
      const value = this.popByte();
      this.doCompare(this.regX, value);
    },
    ie1: () => {
      const zp = this.popByte() + this.regX & 255;
      const addr = this.memory.getWord(zp);
      const value = this.memory.get(addr);
      this.doCompare(this.regA, value);
    },
    ie4: () => {
      const value = this.memory.get(this.popByte());
      this.doCompare(this.regX, value);
    },
    ie5: () => {
      const addr = this.popByte();
      const value = this.memory.get(addr);
      this.doCompare(this.regA, value);
    },
    ie6: () => {
      const zp = this.popByte();
      this.INC(zp);
    },
    ie8: () => {
      this.regX = this.regX + 1 & 255;
      this.setNVflagsForRegX();
    },
    ie9: () => {
      const value = this.popByte();
      this.testSBC(value);
    },
    iea: () => {
    },
    i42: () => {
      const value = this.popByte();
      if (value === 0) {
        const char = String.fromCharCode(this.regA);
        this.dispatchPseudoOpEvent("wdm-output", char);
      }
    },
    iec: () => {
      const value = this.memory.get(this.popWord());
      this.doCompare(this.regX, value);
    },
    ied: () => {
      const addr = this.popWord();
      const value = this.memory.get(addr);
      this.testSBC(value);
    },
    iee: () => {
      const addr = this.popWord();
      this.INC(addr);
    },
    if0: () => {
      const offset = this.popByte();
      if (this.zeroSet()) {
        this.jumpBranch(offset);
      }
    },
    if1: () => {
      const zp = this.popByte();
      const addr = this.memory.getWord(zp);
      const value = this.memory.get(addr + this.regY);
      this.testSBC(value);
    },
    if5: () => {
      const addr = this.popByte() + this.regX & 255;
      const value = this.memory.get(addr);
      this.testSBC(value);
    },
    if6: () => {
      const addr = this.popByte() + this.regX & 255;
      this.INC(addr);
    },
    if8: () => {
      this.regP |= 8;
    },
    if9: () => {
      const addr = this.popWord();
      const value = this.memory.get(addr + this.regY);
      this.testSBC(value);
    },
    ifd: () => {
      const addr = this.popWord();
      const value = this.memory.get(addr + this.regX);
      this.testSBC(value);
    },
    ife: () => {
      const addr = this.popWord() + this.regX;
      this.INC(addr);
    },
    ierr: () => {
      this.dispatchSimulatorFailureEvent("Address $" + addr2hex(this.regPC) + " - unknown opcode");
      this._codeRunning = false;
    }
  };
  stackPush(value) {
    this.memory.set((this.regSP & 255) + 256, value & 255);
    this.regSP--;
    if (this.regSP < 0) {
      this.regSP &= 255;
      this.dispatchSimulatorInfoEvent("6502 Stack filled! Wrapping...");
    }
  }
  stackPop() {
    let value;
    this.regSP++;
    if (this.regSP >= 256) {
      this.regSP &= 255;
      this.dispatchSimulatorInfoEvent("6502 Stack emptied! Wrapping...");
    }
    value = this.memory.get(this.regSP + 256);
    return value;
  }
  /**
   * Pops a byte.
   */
  popByte() {
    return this.memory.get(this.regPC++) & 255;
  }
  /**
   * Pops a little-endian word.
   */
  popWord() {
    return this.popByte() + (this.popByte() << 8);
  }
  /**
   * Executes the assembled code.
   */
  runBinary() {
    if (this._codeRunning) {
      this.stop();
    } else {
      this.dispatchStartEvent();
      this._codeRunning = true;
      this.executeId = setInterval(this.multiExecute.bind(this), 15);
    }
  }
  multiExecute() {
    if (this.stepper) {
      return;
    }
    for (let w = 0; w < 97; w++) {
      this.execute();
    }
    this.dispatchMultiStepEvent();
  }
  executeNextInstruction() {
    let instructionName = this.popByte().toString(16).toLowerCase();
    if (instructionName.length === 1) {
      instructionName = "0" + instructionName;
    }
    const instruction = this.instructions["i" + instructionName];
    if (instruction) {
      instruction();
    } else {
      this.instructions.ierr();
    }
  }
  /**
   * Executes one instruction. This is the main part of the CPU simulator.
   */
  execute(debugging = false) {
    if (!this._codeRunning && !debugging) {
      return;
    }
    this.setRandomByte();
    this.executeNextInstruction();
    this.dispatchStepEvent();
    if (this.regPC === 0 || !this._codeRunning && !debugging) {
      this.stop("Program end at PC=$" + addr2hex(this.regPC - 1));
    }
  }
  setRandomByte() {
    this.memory.set(254, Math.floor(Math.random() * 256));
  }
}
const Template$8 = '<?xml version="1.0" encoding="UTF-8"?>\n<!--\nDO NOT EDIT!\nThis file was @generated by blueprint-compiler. Instead, edit the\ncorresponding .blp file and regenerate this file with blueprint-compiler.\n-->\n<interface>\n  <requires lib="gtk" version="4.0"/>\n  <template class="Display" parent="AdwBin">\n    <property name="name">display</property>\n    <property name="halign">3</property>\n    <property name="valign">3</property>\n    <child>\n      <object class="GtkDrawingArea" id="drawingArea">\n        <property name="content-width">160</property>\n        <property name="content-height">160</property>\n      </object>\n    </child>\n  </template>\n</interface>';
class Display extends Adw.Bin {
  static {
    GObject.registerClass({
      GTypeName: "Display",
      Template: Template$8,
      InternalChildren: ["drawingArea"]
    }, this);
  }
  width = 160;
  height = 160;
  pixelSize = 0;
  numX = 32;
  numY = 32;
  memory;
  palette = [
    "#000000",
    "#ffffff",
    "#880000",
    "#aaffee",
    "#cc44cc",
    "#00cc55",
    "#0000aa",
    "#eeee77",
    "#dd8855",
    "#664400",
    "#ff7777",
    "#333333",
    "#777777",
    "#aaff66",
    "#0088ff",
    "#bbbbbb"
  ];
  constructor(params = {}) {
    super(params);
    if (!this._drawingArea) {
      throw new Error("DrawingArea is required");
    }
    this.reset();
  }
  /**
   * Initializes the display.
   */
  initialize(memory) {
    this.memory = memory;
    this.memory.on("changed", (event) => {
      if (event.addr >= 512 && event.addr <= 1535) {
        this.updatePixel(event.addr);
      }
    });
    this.width = this._drawingArea.get_width() || 160;
    this.height = this._drawingArea.get_height() || 160;
    this.pixelSize = this.width / this.numX;
    this.reset();
  }
  /**
   * Clears the display.
   */
  reset() {
    this._drawingArea.set_draw_func(this.drawClear.bind(this));
    this._drawingArea.queue_draw();
  }
  /**
   * Updates a single pixel on the display.
   * @param addr - The memory address of the pixel.
   * @param memory - The Memory object containing the pixel data.
   */
  updatePixel(_addr) {
    this._drawingArea.set_draw_func(this.drawPixels.bind(this));
    this._drawingArea.queue_draw();
  }
  drawClear(_drawingArea, cr, width, height) {
    const black = { red: 0, green: 0, blue: 0 };
    cr.setSourceRGB(black.red, black.green, black.blue);
    cr.paint();
  }
  drawPixels(_drawingArea, cr, width, height) {
    if (!this.memory) {
      return;
    }
    for (let addr = 512; addr <= 1535; addr++) {
      this.drawPixel(cr, addr);
    }
  }
  drawPixel(cr, addr) {
    const color = this._getColorForAddress(addr);
    const y = Math.floor((addr - 512) / this.numY);
    const x = (addr - 512) % this.numX;
    cr.setSourceRGB(color.red, color.green, color.blue);
    cr.rectangle(x * this.pixelSize, y * this.pixelSize, this.pixelSize, this.pixelSize);
    cr.fill();
  }
  _getColorForAddress(addr) {
    if (!this.memory) {
      return { red: 0, green: 0, blue: 0 };
    }
    const value = this.memory.get(addr) & 15;
    const hex = this.palette[value];
    const red = parseInt(hex.slice(1, 3), 16) / 255;
    const green = parseInt(hex.slice(3, 5), 16) / 255;
    const blue = parseInt(hex.slice(5, 7), 16) / 255;
    return { red, green, blue };
  }
}
const Template$7 = '<?xml version="1.0" encoding="UTF-8"?>\n<!--\nDO NOT EDIT!\nThis file was @generated by blueprint-compiler. Instead, edit the\ncorresponding .blp file and regenerate this file with blueprint-compiler.\n-->\n<interface>\n  <requires lib="gtk" version="4.0"/>\n  <template class="MessageConsole" parent="AdwBin">\n    <child>\n      <object class="GtkScrolledWindow" id="scrolledWindow">\n        <property name="height-request">200</property>\n        <property name="vexpand">true</property>\n        <property name="has-frame">false</property>\n        <child>\n          <object class="GtkTextView" id="textView">\n            <property name="editable">false</property>\n            <property name="hexpand">true</property>\n            <property name="hexpand-set">true</property>\n            <property name="wrap-mode">0</property>\n            <property name="bottom-margin">12</property>\n            <property name="left-margin">12</property>\n            <property name="right-margin">12</property>\n            <property name="top-margin">12</property>\n          </object>\n        </child>\n      </object>\n    </child>\n  </template>\n</interface>';
class MessageConsole extends Adw.Bin {
  static {
    GObject.registerClass({
      GTypeName: "MessageConsole",
      Template: Template$7,
      InternalChildren: ["textView"]
    }, this);
  }
  constructor(params) {
    super(params);
  }
  log(message) {
    message += "\n";
    this._textView.buffer.insert_at_cursor(message, message.length);
  }
  warn(message) {
    this._textView.buffer.insert_at_cursor(`

${message}`, message.length);
  }
  error(message) {
    this._textView.buffer.insert_at_cursor(`

${message}`, message.length);
  }
  clear() {
    this._textView.buffer.set_text("", 0);
  }
  prompt(message, defaultValue) {
    throw new Error("Not implemented");
  }
}
const Template$6 = '<?xml version="1.0" encoding="UTF-8"?>\n<!--\nDO NOT EDIT!\nThis file was @generated by blueprint-compiler. Instead, edit the\ncorresponding .blp file and regenerate this file with blueprint-compiler.\n-->\n<interface>\n  <requires lib="gtk" version="4.0"/>\n  <template class="GamePad" parent="AdwBin">\n    <property name="name">game-pad</property>\n    <child>\n      <object class="GtkBox">\n        <property name="orientation">0</property>\n        <child>\n          <object class="GtkBox">\n            <property name="name">d-pad</property>\n            <child>\n              <object class="GtkButton" id="buttonLeft">\n                <property name="name">buttonLeft</property>\n                <property name="icon-name">go-previous</property>\n                <property name="margin-end">0</property>\n                <property name="valign">3</property>\n                <style>\n                  <class name="osd"/>\n                  <class name="rounded-e-none"/>\n                </style>\n              </object>\n            </child>\n            <child>\n              <object class="GtkBox">\n                <property name="orientation">1</property>\n                <child>\n                  <object class="GtkButton" id="buttonUp">\n                    <property name="name">buttonUp</property>\n                    <property name="icon-name">go-up</property>\n                    <property name="valign">3</property>\n                    <property name="halign">3</property>\n                    <style>\n                      <class name="osd"/>\n                      <class name="rounded-b-none"/>\n                    </style>\n                  </object>\n                </child>\n                <child>\n                  <object class="GtkButton" id="buttonDown">\n                    <property name="name">buttonDown</property>\n                    <property name="icon-name">go-down</property>\n                    <property name="valign">3</property>\n                    <property name="halign">3</property>\n                    <style>\n                      <class name="osd"/>\n                      <class name="rounded-t-none"/>\n                    </style>\n                  </object>\n                </child>\n              </object>\n            </child>\n            <child>\n              <object class="GtkButton" id="buttonRight">\n                <property name="name">buttonRight</property>\n                <property name="icon-name">go-next</property>\n                <property name="valign">3</property>\n                <property name="halign">3</property>\n                <style>\n                  <class name="osd"/>\n                  <class name="rounded-s-none"/>\n                </style>\n              </object>\n            </child>\n          </object>\n        </child>\n        <child>\n          <object class="GtkBox">\n            <property name="orientation">0</property>\n            <property name="margin-start">30</property>\n            <child>\n              <object class="GtkButton" id="buttonB">\n                <property name="name">buttonB</property>\n                <property name="label">B</property>\n                <property name="margin-top">30</property>\n                <property name="margin-end">10</property>\n                <property name="valign">3</property>\n                <style>\n                  <class name="circular"/>\n                  <class name="opaque"/>\n                  <class name="destructive-action"/>\n                </style>\n              </object>\n            </child>\n            <child>\n              <object class="GtkButton" id="buttonA">\n                <property name="name">buttonA</property>\n                <property name="label">A</property>\n                <property name="margin-bottom">30</property>\n                <property name="margin-start">10</property>\n                <property name="valign">3</property>\n                <style>\n                  <class name="circular"/>\n                  <class name="opaque"/>\n                  <class name="suggested-action"/>\n                </style>\n              </object>\n            </child>\n          </object>\n        </child>\n      </object>\n    </child>\n  </template>\n</interface>';
GObject.type_ensure(MessageConsole.$gtype);
class GamePad extends Adw.Bin {
  static {
    GObject.registerClass({
      GTypeName: "GamePad",
      Template: Template$6,
      InternalChildren: ["buttonLeft", "buttonRight", "buttonUp", "buttonDown", "buttonA", "buttonB"],
      Signals: {
        "gamepad-pressed": {
          param_types: [GObject.TYPE_INT]
        }
      }
    }, this);
  }
  constructor(params = {}) {
    super(params);
    this._buttonUp.connect("clicked", () => {
      this.emit("gamepad-pressed", 119);
    });
    this._buttonDown.connect("clicked", () => {
      this.emit("gamepad-pressed", 115);
    });
    this._buttonLeft.connect("clicked", () => {
      this.emit("gamepad-pressed", 97);
    });
    this._buttonRight.connect("clicked", () => {
      this.emit("gamepad-pressed", 100);
    });
    this._buttonA.connect("clicked", () => {
      this.emit("gamepad-pressed", 13);
    });
    this._buttonB.connect("clicked", () => {
      this.emit("gamepad-pressed", 32);
    });
  }
  press(buttonName) {
    let button = null;
    switch (buttonName) {
      case "Left":
        button = this._buttonLeft;
        break;
      case "Right":
        button = this._buttonRight;
        break;
      case "Up":
        button = this._buttonUp;
        break;
      case "Down":
        button = this._buttonDown;
        break;
      case "A":
        button = this._buttonA;
        break;
      case "B":
        button = this._buttonB;
        break;
    }
    if (!button || !(button instanceof Gtk.Button)) {
      throw new Error("Invalid button name");
    }
    button.activate();
  }
}
const Template$5 = '<?xml version="1.0" encoding="UTF-8"?>\n<!--\nDO NOT EDIT!\nThis file was @generated by blueprint-compiler. Instead, edit the\ncorresponding .blp file and regenerate this file with blueprint-compiler.\n-->\n<interface>\n  <requires lib="gtk" version="4.0"/>\n  <template class="GameConsole" parent="AdwBin">\n    <property name="name">game-console</property>\n    <child>\n      <object class="GtkBox">\n        <property name="halign">3</property>\n        <property name="valign">3</property>\n        <property name="orientation">1</property>\n        <child>\n          <object class="Display" id="display"></object>\n        </child>\n        <child>\n          <object class="GamePad" id="gamePad">\n            <property name="margin-top">30</property>\n          </object>\n        </child>\n      </object>\n    </child>\n  </template>\n</interface>';
GObject.type_ensure(Display.$gtype);
GObject.type_ensure(GamePad.$gtype);
class GameConsole extends Adw.Bin {
  static {
    GObject.registerClass({
      GTypeName: "GameConsole",
      Template: Template$5,
      InternalChildren: ["display", "gamePad"],
      Signals: {
        "assemble-success": {
          // TODO: Fix this, see https://github.com/gjsify/ts-for-gir/pull/189
          param_types: [GObject.TYPE_JSOBJECT]
        },
        "assemble-failure": {
          param_types: [GObject.TYPE_JSOBJECT]
        },
        "hexdump": {
          param_types: [GObject.TYPE_JSOBJECT]
        },
        "disassembly": {
          param_types: [GObject.TYPE_JSOBJECT]
        },
        "assemble-info": {
          param_types: [GObject.TYPE_JSOBJECT]
        },
        "stop": {
          param_types: [GObject.TYPE_JSOBJECT]
        },
        "start": {
          param_types: [GObject.TYPE_JSOBJECT]
        },
        "reset": {
          param_types: [GObject.TYPE_JSOBJECT]
        },
        "step": {
          param_types: [GObject.TYPE_JSOBJECT]
        },
        "multistep": {
          param_types: [GObject.TYPE_JSOBJECT]
        },
        "goto": {
          param_types: [GObject.TYPE_JSOBJECT]
        },
        "pseudo-op": {
          param_types: [GObject.TYPE_JSOBJECT]
        },
        "simulator-info": {
          param_types: [GObject.TYPE_JSOBJECT]
        },
        "simulator-failure": {
          param_types: [GObject.TYPE_JSOBJECT]
        },
        "labels-info": {
          param_types: [GObject.TYPE_JSOBJECT]
        },
        "labels-failure": {
          param_types: [GObject.TYPE_JSOBJECT]
        },
        "gamepad-pressed": {
          param_types: [GObject.TYPE_INT]
        }
      }
    }, this);
  }
  /** A list of handler IDs for the signals we connect to. */
  gamepadHandlerIds = [];
  _memory;
  _labels;
  _simulator;
  _assembler;
  get memory() {
    return this._memory;
  }
  get labels() {
    return this._labels;
  }
  get simulator() {
    return this._simulator;
  }
  get assembler() {
    return this._assembler;
  }
  constructor(params) {
    super(params);
    this._memory = new Memory();
    this._labels = new Labels();
    this._simulator = new Simulator(this._memory, this._labels);
    this._assembler = new Assembler(this._memory, this._labels);
    this.initialize();
  }
  assemble(code) {
    this._simulator.reset();
    this._labels.reset();
    this._display?.reset();
    this._assembler.assembleCode(code);
  }
  run() {
    this._simulator.stopStepper();
    this._simulator.runBinary();
  }
  hexdump() {
    this._assembler.hexdump();
  }
  disassemble() {
    this._assembler.disassemble();
  }
  stop() {
    this._simulator.stop();
  }
  reset() {
    this._simulator.reset();
  }
  step() {
    this._simulator.debugExecStep();
  }
  goto(address) {
    this._simulator.gotoAddr(address);
  }
  gamepadPress(buttonName) {
    this._gamePad.press(buttonName);
  }
  /** Call this when the ApplicationWindow is closed. */
  close() {
    this.stop();
    this.removeSignalHandlers();
  }
  /**
   * Initializes the simulator widget and sets up event listeners.
   */
  initialize() {
    this._display?.initialize(this._memory);
    this._simulator.reset();
    this.setupEventListeners();
  }
  /**
   * Sets up event listeners for various UI elements.
   */
  setupEventListeners() {
    this._assembler.on("assemble-success", (event) => {
      this._memory.set(this._assembler.getCurrentPC(), 0);
      this.emit("assemble-success", event);
    });
    this._assembler.on("assemble-failure", (event) => {
      this.emit("assemble-failure", event);
    });
    this._assembler.on("hexdump", (event) => {
      this.emit("hexdump", event);
    });
    this._assembler.on("disassembly", (event) => {
      this.emit("disassembly", event);
    });
    this._assembler.on("assemble-info", (event) => {
      this.emit("assemble-info", event);
    });
    this._simulator.on("stop", (event) => {
      this.emit("stop", event);
    });
    this._simulator.on("start", (event) => {
      this.emit("start", event);
    });
    this._simulator.on("reset", (event) => {
      this._display?.reset();
      this.emit("reset", event);
    });
    this._simulator.on("step", (event) => {
      this.emit("step", event);
    });
    this._simulator.on("multistep", (event) => {
      this.emit("multistep", event);
    });
    this._simulator.on("goto", (event) => {
      this.emit("goto", event);
    });
    this._simulator.on("pseudo-op", (event) => {
      this.emit("pseudo-op", event);
    });
    this._simulator.on("simulator-info", (event) => {
      this.emit("simulator-info", event);
    });
    this._simulator.on("simulator-failure", (event) => {
      this.emit("simulator-failure", event);
    });
    this._labels.on("labels-info", (event) => {
      this.emit("labels-info", event);
    });
    this._labels.on("labels-failure", (event) => {
      this.emit("labels-failure", event);
    });
    this.gamepadHandlerIds.push(this._gamePad.connect("gamepad-pressed", (_source, key) => {
      this.emit("gamepad-pressed", key);
      this._memory.storeKeypress(key);
    }));
  }
  removeSignalHandlers() {
    this.gamepadHandlerIds.forEach((id) => this._gamePad.disconnect(id));
    this.gamepadHandlerIds = [];
  }
}
const Template$4 = '<?xml version="1.0" encoding="UTF-8"?>\n<!--\nDO NOT EDIT!\nThis file was @generated by blueprint-compiler. Instead, edit the\ncorresponding .blp file and regenerate this file with blueprint-compiler.\n-->\n<interface>\n  <requires lib="gtk" version="4.0"/>\n  <template class="HexMonitor" parent="AdwBin">\n    <child>\n      <object class="SourceView" id="sourceView">\n        <property name="editable">false</property>\n        <property name="language">hex</property>\n        <property name="height-request">200</property>\n        <property name="vexpand">true</property>\n      </object>\n    </child>\n  </template>\n</interface>';
GObject.type_ensure(SourceView.$gtype);
class HexMonitor extends Adw.Bin {
  static {
    GObject.registerClass({
      GTypeName: "HexMonitor",
      Template: Template$4,
      InternalChildren: ["sourceView"]
    }, this);
  }
  options = {
    start: 0,
    length: 65535
  };
  constructor(params) {
    super(params);
  }
  update(memory) {
    let content = "";
    const end = this.options.start + this.options.length - 1;
    if (!isNaN(this.options.start) && !isNaN(this.options.length) && this.options.start >= 0 && this.options.length > 0 && end <= 65535) {
      content = memory.format({ start: this.options.start, length: this.options.length, includeAddress: false, includeSpaces: true, includeNewline: true });
    } else {
      content = "Cannot monitor this range. Valid ranges are between $0000 and $ffff, inclusive.";
    }
    this._sourceView.code = content;
  }
  setOptions(options) {
    this.options = { ...this.options, ...options };
  }
}
const Template$3 = '<?xml version="1.0" encoding="UTF-8"?>\n<!--\nDO NOT EDIT!\nThis file was @generated by blueprint-compiler. Instead, edit the\ncorresponding .blp file and regenerate this file with blueprint-compiler.\n-->\n<interface>\n  <requires lib="gtk" version="4.0"/>\n  <template class="DebugInfo" parent="AdwBin">\n    <child>\n      <object class="GtkScrolledWindow" id="scrolledWindow">\n        <property name="height-request">100</property>\n        <property name="vexpand">true</property>\n        <property name="has-frame">false</property>\n        <child>\n          <object class="GtkTextView" id="textView">\n            <property name="editable">false</property>\n            <property name="hexpand">true</property>\n            <property name="hexpand-set">true</property>\n            <property name="wrap-mode">0</property>\n            <property name="bottom-margin">12</property>\n            <property name="left-margin">12</property>\n            <property name="right-margin">12</property>\n            <property name="top-margin">12</property>\n            <property name="monospace">true</property>\n          </object>\n        </child>\n      </object>\n    </child>\n  </template>\n</interface>';
class DebugInfo extends Adw.Bin {
  static {
    GObject.registerClass({
      GTypeName: "DebugInfo",
      Template: Template$3,
      InternalChildren: ["textView"]
    }, this);
  }
  constructor(params) {
    super(params);
  }
  update(simulator) {
    const { regA, regX, regY, regP, regPC, regSP } = simulator.info;
    let markup = "A=$" + num2hex(regA) + " X=$" + num2hex(regX) + " Y=$" + num2hex(regY) + "\n";
    markup += "SP=$" + num2hex(regSP) + " PC=$" + addr2hex(regPC);
    markup += "\n";
    markup += "NV-BDIZC\n";
    for (let i = 7; i >= 0; i--) {
      markup += regP >> i & 1;
    }
    this._textView.buffer.text = markup;
  }
}
const Template$2 = '<?xml version="1.0" encoding="UTF-8"?>\n<!--\nDO NOT EDIT!\nThis file was @generated by blueprint-compiler. Instead, edit the\ncorresponding .blp file and regenerate this file with blueprint-compiler.\n-->\n<interface>\n  <requires lib="gtk" version="4.0"/>\n  <template class="Debugger" parent="AdwBin">\n    <child>\n      <object class="GtkScrolledWindow">\n        <property name="hexpand">true</property>\n        <property name="vexpand">true</property>\n        <child>\n          <object class="GtkStack" id="stack">\n            <child>\n              <object class="GtkStackPage">\n                <property name="name">initial</property>\n                <property name="child">\n                  <object class="AdwStatusPage" id="statusPage">\n                    <property name="title" translatable="true">Debugger</property>\n                    <property name="description" translatable="true">Debug your 6502 assembly code, step through your program, and view memory and registers. To get started, assemble and run your program.</property>\n                    <property name="icon-name">bug-symbolic</property>\n                    <property name="valign">1</property>\n                  </object>\n                </property>\n              </object>\n            </child>\n            <child>\n              <object class="GtkStackPage">\n                <property name="name">debugger</property>\n                <property name="child">\n                  <object class="AdwClamp">\n                    <property name="maximum-size">600</property>\n                    <property name="margin-top">12</property>\n                    <property name="margin-bottom">12</property>\n                    <property name="margin-start">12</property>\n                    <property name="margin-end">12</property>\n                    <property name="child">\n                      <object class="GtkBox">\n                        <property name="orientation">1</property>\n                        <child>\n                          <object class="GtkLabel">\n                            <property name="label">Hex Monitor</property>\n                            <property name="halign">1</property>\n                            <property name="margin-bottom">12</property>\n                            <property name="margin-top">12</property>\n                            <style>\n                              <class name="heading"/>\n                            </style>\n                          </object>\n                        </child>\n                        <child>\n                          <object class="GtkFrame">\n                            <property name="margin-bottom">12</property>\n                            <child>\n                              <object class="HexMonitor" id="hexMonitor"></object>\n                            </child>\n                          </object>\n                        </child>\n                        <child>\n                          <object class="GtkLabel">\n                            <property name="label">Information</property>\n                            <property name="halign">1</property>\n                            <property name="margin-bottom">12</property>\n                            <property name="margin-top">12</property>\n                            <style>\n                              <class name="heading"/>\n                            </style>\n                          </object>\n                        </child>\n                        <child>\n                          <object class="GtkFrame">\n                            <property name="margin-bottom">12</property>\n                            <child>\n                              <object class="DebugInfo" id="debugInfo"></object>\n                            </child>\n                          </object>\n                        </child>\n                        <child>\n                          <object class="GtkLabel">\n                            <property name="label">Messages</property>\n                            <property name="halign">1</property>\n                            <property name="margin-bottom">12</property>\n                            <property name="margin-top">12</property>\n                            <style>\n                              <class name="heading"/>\n                            </style>\n                          </object>\n                        </child>\n                        <child>\n                          <object class="GtkFrame">\n                            <property name="margin-bottom">12</property>\n                            <child>\n                              <object class="MessageConsole" id="messageConsole"></object>\n                            </child>\n                          </object>\n                        </child>\n                      </object>\n                    </property>\n                  </object>\n                </property>\n              </object>\n            </child>\n          </object>\n        </child>\n      </object>\n    </child>\n  </template>\n</interface>';
GObject.type_ensure(MessageConsole.$gtype);
GObject.type_ensure(HexMonitor.$gtype);
GObject.type_ensure(DebugInfo.$gtype);
class Debugger extends Adw.Bin {
  static {
    GObject.registerClass({
      GTypeName: "Debugger",
      Template: Template$2,
      InternalChildren: ["stack", "messageConsole", "hexMonitor", "debugInfo", "statusPage"],
      Properties: {
        // TypeScript enums are numbers by default
        "state": GObject.ParamSpec.uint("state", "State", "Debugger state", GObject.ParamFlags.READWRITE, DebuggerState.INITIAL, DebuggerState.RESET, DebuggerState.INITIAL)
      }
    }, this);
  }
  get state() {
    return this._state;
  }
  set state(value) {
    if (this._state !== value) {
      this._state = value;
      this.notify("state");
    }
  }
  // TODO: Currently unused
  options = {
    monitor: {
      start: 0,
      length: 65535
    }
  };
  /** A list of handler IDs for the signals we connect to. */
  handlerIds = [];
  constructor(binParams = {}) {
    super(binParams);
    this.setupSignalHandlers();
    this.state = DebuggerState.INITIAL;
  }
  /** Call this when the ApplicationWindow is closed. */
  close() {
    this.removeSignalHandlers();
  }
  log(message) {
    this._messageConsole.log(message);
  }
  #update(memory, simulator) {
    this.updateMonitor(memory);
    this.updateDebugInfo(simulator);
  }
  /**
   * Update the debugger.
   * @note This is throttled to 349ms to prevent excessive CPU usage.
   * @param memory - The memory to update the hex monitor.
   * @param simulator - The simulator to update the debug info.
   */
  update = throttle(this.#update.bind(this), 349);
  // Prime number
  updateMonitor(memory) {
    this._hexMonitor.update(memory);
  }
  updateDebugInfo(simulator) {
    this._debugInfo.update(simulator);
  }
  reset() {
    this._messageConsole.clear();
    this.state = DebuggerState.RESET;
  }
  onStateChanged() {
    if (this.state === DebuggerState.INITIAL) {
      this._stack.set_visible_child_name("initial");
    } else {
      this._stack.set_visible_child_name("debugger");
    }
  }
  onParamChanged(_self, pspec) {
    switch (pspec.name) {
      case "state":
        this.onStateChanged();
        break;
    }
  }
  setupSignalHandlers() {
    this.handlerIds.push(this.connect("notify", this.onParamChanged.bind(this)));
  }
  removeSignalHandlers() {
    this.handlerIds.forEach((id) => this.disconnect(id));
    this.handlerIds = [];
  }
}
const Template$1 = '<?xml version="1.0" encoding="UTF-8"?>\n<!--\nDO NOT EDIT!\nThis file was @generated by blueprint-compiler. Instead, edit the\ncorresponding .blp file and regenerate this file with blueprint-compiler.\n-->\n<interface>\n  <requires lib="gtk" version="4.0"/>\n  <template class="ApplicationWindow" parent="AdwApplicationWindow">\n    <property name="name">application-window</property>\n    <property name="default-width">800</property>\n    <property name="default-height">600</property>\n    <property name="width-request">360</property>\n    <property name="height-request">480</property>\n    <property name="content">\n      <object class="AdwToolbarView">\n        <child type="top">\n          <object class="AdwHeaderBar" id="headerBar">\n            <property name="title-widget">\n              <object class="GtkLabel">\n                <property name="label" translatable="true">Easy6502</property>\n              </object>\n            </property>\n            <child type="end">\n              <object class="GtkMenuButton" id="menuButton">\n                <property name="primary">true</property>\n                <property name="icon-name">open-menu-symbolic</property>\n                <property name="tooltip-text" translatable="true">Menu</property>\n                <property name="menu-model">buttonWindowMenu</property>\n              </object>\n            </child>\n            <child type="end">\n              <object class="AdwSplitButton" id="runButton">\n                <property name="halign">3</property>\n                <property name="icon-name">media-playback-start-symbolic</property>\n                <style>\n                  <class name="suggested-action"/>\n                </style>\n                <property name="menu-model">buttonRunMenu</property>\n              </object>\n            </child>\n          </object>\n        </child>\n        <property name="content">\n          <object class="AdwToastOverlay" id="toastOverlay">\n            <child>\n              <object class="AdwViewStack" id="stack">\n                <property name="vexpand">true</property>\n                <child>\n                  <object class="AdwViewStackPage">\n                    <property name="name">learn</property>\n                    <property name="title" translatable="true">Learn</property>\n                    <property name="icon-name">school-symbolic</property>\n                    <property name="use-underline">true</property>\n                    <property name="child">\n                      <object class="Learn" id="learn"></object>\n                    </property>\n                  </object>\n                </child>\n                <child>\n                  <object class="AdwViewStackPage">\n                    <property name="name">editor</property>\n                    <property name="title" translatable="true">Editor</property>\n                    <property name="icon-name">code-symbolic</property>\n                    <property name="use-underline">true</property>\n                    <property name="child">\n                      <object class="Editor" id="editor"></object>\n                    </property>\n                  </object>\n                </child>\n                <child>\n                  <object class="AdwViewStackPage">\n                    <property name="name">gameConsole</property>\n                    <property name="title" translatable="true">Game Console</property>\n                    <property name="icon-name">nintendo-controller-symbolic</property>\n                    <property name="use-underline">true</property>\n                    <property name="child">\n                      <object class="GameConsole" id="gameConsole"></object>\n                    </property>\n                  </object>\n                </child>\n                <child>\n                  <object class="AdwViewStackPage">\n                    <property name="name">debugger</property>\n                    <property name="title" translatable="true">Debugger</property>\n                    <property name="icon-name">bug-symbolic</property>\n                    <property name="use-underline">true</property>\n                    <property name="child">\n                      <object class="Debugger" id="debugger"></object>\n                    </property>\n                  </object>\n                </child>\n              </object>\n            </child>\n          </object>\n        </property>\n        <child type="bottom">\n          <object class="AdwViewSwitcherBar" id="switcherBar">\n            <property name="stack">stack</property>\n            <property name="reveal">true</property>\n          </object>\n        </child>\n      </object>\n    </property>\n  </template>\n  <menu id="buttonWindowMenu">\n    <section>\n      <item>\n        <attribute name="label" translatable="true">_Preferences</attribute>\n        <attribute name="action">app.preferences</attribute>\n      </item>\n      <item>\n        <attribute name="label" translatable="true">_Keyboard Shortcuts</attribute>\n        <attribute name="action">win.show-help-overlay</attribute>\n      </item>\n      <item>\n        <attribute name="label" translatable="true">_About Test</attribute>\n        <attribute name="action">app.about</attribute>\n      </item>\n      <item>\n        <attribute name="label" translatable="true">_Quit</attribute>\n        <attribute name="action">app.quit</attribute>\n      </item>\n    </section>\n  </menu>\n  <menu id="buttonRunMenu">\n    <section>\n      <item>\n        <attribute name="label">Assemble and Run</attribute>\n        <attribute name="action">win.assemble-and-run</attribute>\n      </item>\n      <item>\n        <attribute name="label">Assemble</attribute>\n        <attribute name="action">win.assemble</attribute>\n      </item>\n      <item>\n        <attribute name="label">Run</attribute>\n        <attribute name="action">win.run</attribute>\n      </item>\n    </section>\n  </menu>\n</interface>';
GObject.type_ensure(Learn.$gtype);
GObject.type_ensure(Editor.$gtype);
GObject.type_ensure(GameConsole.$gtype);
GObject.type_ensure(Debugger.$gtype);
class ApplicationWindow extends Adw.ApplicationWindow {
  static {
    GObject.registerClass({
      GTypeName: "ApplicationWindow",
      Template: Template$1,
      InternalChildren: ["editor", "gameConsole", "learn", "menuButton", "runButton", "stack", "switcherBar", "debugger", "toastOverlay"]
    }, this);
  }
  constructor(application) {
    super({ application });
    this.setupGeneralSignalListeners();
    this.setupRunMenu();
    this.setupGameConsoleSignalListeners();
    this.setupKeyboardListener();
    this.setupLearnTutorialSignalListeners();
  }
  setupLearnTutorialSignalListeners() {
    this._learn.connect("copy-assemble-and-run", (_learn, code) => {
      this.copyGameConsole(code);
      this.assembleGameConsole();
      this.runGameConsole();
    });
    this._learn.connect("copy-assemble", (_learn, code) => {
      this.copyGameConsole(code);
      this.assembleGameConsole();
    });
    this._learn.connect("copy", (_learn, code) => {
      this.copyGameConsole(code);
    });
  }
  setupGeneralSignalListeners() {
    this.connect("close-request", this.onCloseRequest.bind(this));
  }
  onCloseRequest() {
    this._gameConsole.close();
    this._debugger.close();
  }
  setupRunMenu() {
    this._runButton.connect("clicked", this.runAndAssembleGameConsole.bind(this));
    const assembleAndRunAction = new Gio.SimpleAction({ name: "assemble-and-run" });
    assembleAndRunAction.connect("activate", this.runAndAssembleGameConsole.bind(this));
    this.add_action(assembleAndRunAction);
    const assembleAction = new Gio.SimpleAction({ name: "assemble" });
    assembleAction.connect("activate", this.assembleGameConsole.bind(this));
    this.add_action(assembleAction);
    const runAction = new Gio.SimpleAction({ name: "run" });
    runAction.connect("activate", this.runGameConsole.bind(this));
    this.add_action(runAction);
  }
  runGameConsole() {
    this._gameConsole.run();
  }
  assembleGameConsole() {
    this._debugger.reset();
    this._gameConsole.assemble(this._editor.code);
  }
  runAndAssembleGameConsole() {
    this.assembleGameConsole();
    this.runGameConsole();
  }
  copyGameConsole(code) {
    this._editor.code = code;
  }
  showToast(params) {
    const toast = new Adw.Toast(params);
    this._toastOverlay.add_toast(toast);
  }
  setupGameConsoleSignalListeners() {
    this._gameConsole.connect("assemble-success", (_gameConsole, signal) => {
      if (signal.message) {
        this._debugger.log(signal.message);
      }
      this.showToast({
        title: "Assembled successfully"
      });
    });
    this._gameConsole.connect("assemble-failure", (_gameConsole, signal) => {
      if (signal.message) {
        this._debugger.log(signal.message);
      }
      this.showToast({
        title: "Assemble failed"
      });
    });
    this._gameConsole.connect("hexdump", (_gameConsole, signal) => {
      if (signal.message) {
        this._debugger.log(signal.message);
      }
    });
    this._gameConsole.connect("disassembly", (_gameConsole, signal) => {
      if (signal.message) {
        this._debugger.log(signal.message);
      }
    });
    this._gameConsole.connect("assemble-info", (_gameConsole, signal) => {
      if (signal.message) {
        this._debugger.log(signal.message);
      }
    });
    this._gameConsole.connect("stop", (_gameConsole, signal) => {
      if (signal.message) {
        this._debugger.log(signal.message);
      }
    });
    this._gameConsole.connect("start", (_gameConsole, signal) => {
      if (signal.message) {
        this._debugger.log(signal.message);
      }
    });
    this._gameConsole.connect("reset", (_gameConsole, signal) => {
      if (signal.message) {
        this._debugger.log(signal.message);
      }
      this._debugger.update(this._gameConsole.memory, this._gameConsole.simulator);
    });
    this._gameConsole.connect("step", (_gameConsole, signal) => {
      if (signal.message) {
        this._debugger.log(signal.message);
      }
      if (this._gameConsole.simulator.stepperEnabled) {
        this._debugger.update(this._gameConsole.memory, this._gameConsole.simulator);
      }
    });
    this._gameConsole.connect("multistep", (_gameConsole, signal) => {
      if (signal.message) {
        this._debugger.log(signal.message);
      }
      this._debugger.update(this._gameConsole.memory, this._gameConsole.simulator);
    });
    this._gameConsole.connect("goto", (_gameConsole, signal) => {
      if (signal.message) {
        this._debugger.log(signal.message);
      }
      this._debugger.update(this._gameConsole.memory, this._gameConsole.simulator);
    });
    this._gameConsole.connect("simulator-info", (_gameConsole, signal) => {
      if (signal.message) {
        this._debugger.log(signal.message);
      }
    });
    this._gameConsole.connect("simulator-failure", (_gameConsole, signal) => {
      if (signal.message) {
        this._debugger.log(signal.message);
      }
      this.showToast({
        title: "Simulator failure"
      });
    });
    this._gameConsole.connect("labels-info", (_gameConsole, signal) => {
      if (signal.message) {
        this._debugger.log(signal.message);
      }
    });
    this._gameConsole.connect("labels-failure", (_gameConsole, signal) => {
      if (signal.message) {
        this._debugger.log(signal.message);
      }
      this.showToast({
        title: "Labels failure"
      });
    });
    this._gameConsole.connect("gamepad-pressed", (_gameConsole, key) => {
      this._debugger.log(`Gamepad key pressed: ${key}`);
    });
  }
  setupKeyboardListener() {
    const keyController = new Gtk.EventControllerKey();
    this.add_controller(keyController);
    keyController.connect("key-pressed", (_controller, keyval, keycode, state) => {
      this.handleKeyPress(keyval);
      return false;
    });
  }
  handleKeyPress(keyval) {
    switch (keyval) {
      case Gdk.KEY_w:
      case Gdk.KEY_Up:
        this._gameConsole.gamepadPress("Up");
        break;
      case Gdk.KEY_s:
      case Gdk.KEY_Down:
        this._gameConsole.gamepadPress("Down");
        break;
      case Gdk.KEY_a:
      case Gdk.KEY_Left:
        this._gameConsole.gamepadPress("Left");
        break;
      case Gdk.KEY_d:
      case Gdk.KEY_Right:
        this._gameConsole.gamepadPress("Right");
        break;
      case Gdk.KEY_Return:
        this._gameConsole.gamepadPress("A");
        break;
      case Gdk.KEY_space:
        this._gameConsole.gamepadPress("B");
        break;
    }
  }
}
const Template = '<?xml version="1.0" encoding="UTF-8"?>\n<!--\nDO NOT EDIT!\nThis file was @generated by blueprint-compiler. Instead, edit the\ncorresponding .blp file and regenerate this file with blueprint-compiler.\n-->\n<interface>\n  <requires lib="gtk" version="4.0"/>\n  <template class="PreferencesDialog" parent="AdwPreferencesDialog">\n    <property name="content-width">800</property>\n    <property name="content-height">600</property>\n    <property name="title" translatable="true">Preferences</property>\n    <child>\n      <object class="AdwPreferencesPage" id="appearance_page">\n        <property name="title" translatable="true">Appearance</property>\n        <property name="icon-name">brush-monitor-symbolic</property>\n        <child>\n          <object class="AdwPreferencesGroup">\n            <property name="title" translatable="true">Color Settings</property>\n            <property name="description" translatable="true">Change the color-scheme of the application</property>\n            <child>\n              <object class="AdwSwitchRow" id="dm_switch">\n                <property name="title" translatable="true">Use Dark Mode</property>\n              </object>\n            </child>\n          </object>\n        </child>\n        <child>\n          <object class="AdwPreferencesGroup">\n            <property name="title" translatable="true">Text Settings</property>\n            <property name="description" translatable="true">Customize the appearance of text in the application</property>\n            <child>\n              <object class="AdwSpinRow">\n                <property name="title" translatable="true">Font Size</property>\n                <property name="adjustment">\n                  <object class="GtkAdjustment">\n                    <property name="lower">5</property>\n                    <property name="upper">20</property>\n                    <property name="step-increment">1</property>\n                    <property name="value">11</property>\n                  </object>\n                </property>\n              </object>\n            </child>\n            <child>\n              <object class="AdwActionRow">\n                <property name="title" translatable="true">Font Color</property>\n                <child type="suffix">\n                  <object class="GtkColorDialogButton">\n                    <property name="halign">3</property>\n                    <property name="valign">3</property>\n                    <property name="dialog">\n                      <object class="GtkColorDialog"></object>\n                    </property>\n                  </object>\n                </child>\n              </object>\n            </child>\n          </object>\n        </child>\n      </object>\n    </child>\n    <child>\n      <object class="AdwPreferencesPage">\n        <property name="title" translatable="true">Behavior</property>\n        <property name="icon-name">settings-symbolic</property>\n        <child>\n          <object class="AdwPreferencesGroup">\n            <property name="title" translatable="true">Interaction Settings</property>\n            <property name="description" translatable="true">Change how the app behaves during user interaction</property>\n            <child type="header-suffix">\n              <object class="GtkButton">\n                <property name="halign">3</property>\n                <property name="valign">3</property>\n                <property name="icon-name">settings-symbolic</property>\n              </object>\n            </child>\n            <child>\n              <object class="AdwSwitchRow">\n                <property name="title" translatable="true">Run on Startup</property>\n              </object>\n            </child>\n            <child>\n              <object class="AdwActionRow">\n                <property name="title" translatable="true">Show Toast</property>\n                <property name="activatable-widget">toast_button</property>\n                <child type="suffix">\n                  <object class="GtkButton" id="toast_button">\n                    <property name="halign">3</property>\n                    <property name="valign">3</property>\n                    <property name="label" translatable="true">show toast</property>\n                    <property name="icon-name">bread-symbolic</property>\n                  </object>\n                </child>\n              </object>\n            </child>\n          </object>\n        </child>\n        <child>\n          <object class="AdwPreferencesGroup">\n            <property name="title" translatable="true">Data Settings</property>\n            <property name="description" translatable="true">Manage user data related settings</property>\n            <child>\n              <object class="AdwSwitchRow">\n                <property name="title" translatable="true">Enable Debug</property>\n              </object>\n            </child>\n            <child>\n              <object class="AdwSwitchRow">\n                <property name="title" translatable="true">Check for updates</property>\n              </object>\n            </child>\n            <child>\n              <object class="AdwActionRow" id="subpage_row">\n                <property name="title" translatable="true">Additional Preferences</property>\n                <property name="activatable">true</property>\n                <child type="suffix">\n                  <object class="GtkImage">\n                    <property name="icon-name">go-next-symbolic</property>\n                    <style>\n                      <class name="dim-label"/>\n                    </style>\n                  </object>\n                </child>\n              </object>\n            </child>\n          </object>\n        </child>\n      </object>\n    </child>\n  </template>\n</interface>';
class PreferencesDialog extends Adw.PreferencesDialog {
  static {
    GObject.registerClass({
      GTypeName: "PreferencesDialog",
      Template
    }, this);
  }
  constructor(params = {}) {
    super(params);
  }
}
const initResources = () => {
  const resourceDataPath = rootDir.resolve_relative_path(`./data/${APPLICATION_ID}.data.gresource`).get_path();
  if (!resourceDataPath) {
    throw new Error("Resource data path not found");
  }
  const resourceData = Gio.Resource.load(resourceDataPath);
  Gio.resources_register(resourceData);
  const resourceSrcPath = rootDir.resolve_relative_path(`./src/${APPLICATION_ID}.src.gresource`).get_path();
  if (!resourceSrcPath) {
    throw new Error("Resource src path not found");
  }
  const resourceSrc = Gio.Resource.load(resourceSrcPath);
  Gio.resources_register(resourceSrc);
  const display = Gdk.Display.get_default();
  if (!display) {
    throw new Error("Display not found");
  }
  const theme = Gtk.IconTheme.get_for_display(display);
  theme.add_resource_path(`${RESOURCES_PATH}/icons`);
  const languageManager = GtkSource.LanguageManager.get_default();
  const searchPath = languageManager.get_search_path();
  if (!searchPath) {
    throw new Error("Search path not found");
  }
  languageManager.set_search_path([`resource://${RESOURCES_PATH}/lang-specs`, ...searchPath]);
};
const mainStyle = "#application-window {\n\n}\n#game-pad {\n    \n}\n.rounded-none {\n  border-radius: 0;\n}\n.rounded-t-none {\n  border-top-left-radius: 0px;\n  border-top-right-radius: 0px;\n}\n.rounded-s-none {\n  border-bottom-left-radius: 0px;\n  border-top-left-radius: 0px;\n}\n.rounded-e-none {\n  border-top-right-radius: 0px;\n  border-bottom-right-radius: 0px;\n}\n.rounded-b-none {\n  border-bottom-left-radius: 0px;\n  border-bottom-right-radius: 0px;\n}";
class Application extends Adw.Application {
  static {
    GObject.registerClass({
      GTypeName: "Application"
    }, this);
  }
  constructor() {
    super({
      applicationId: APPLICATION_ID,
      flags: Gio.ApplicationFlags.DEFAULT_FLAGS
    });
    this.onStartup = this.onStartup.bind(this);
    this.connect("startup", this.onStartup);
    this.initActions();
  }
  onStartup() {
    this.initStyles();
    initResources();
  }
  /** Load the stylesheet in a CssProvider and add it to the Gtk.StyleContext */
  initStyles() {
    const provider = new Gtk.CssProvider();
    provider.load_from_string(mainStyle);
    const display = Gdk.Display.get_default();
    if (!display) {
      console.error("No display found");
      return;
    }
    Gtk.StyleContext.add_provider_for_display(
      display,
      provider,
      Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
    );
  }
  initActions() {
    const quitAction = new Gio.SimpleAction({ name: "quit" });
    quitAction.connect("activate", (_action) => {
      log("quitAction activated");
      this.quit();
    });
    this.add_action(quitAction);
    this.set_accels_for_action("app.quit", ["<primary>q"]);
    const showAboutAction = new Gio.SimpleAction({ name: "about" });
    showAboutAction.connect("activate", this.onShowAboutDialog.bind(this));
    this.add_action(showAboutAction);
    const showPreferencesAction = new Gio.SimpleAction({ name: "preferences" });
    showPreferencesAction.connect("activate", (_action) => {
      const preferencesDialog = new PreferencesDialog();
      preferencesDialog.present(this.active_window);
    });
    this.add_action(showPreferencesAction);
  }
  onShowAboutDialog() {
    const aboutDialog = Adw.AboutDialog.new_from_appdata(`${RESOURCES_PATH}/${pkg.name}.metainfo.xml`, pkg.version);
    aboutDialog.present(this.get_active_window());
  }
  vfunc_activate() {
    let { active_window } = this;
    if (!active_window) active_window = new ApplicationWindow(this);
    active_window.present();
  }
}
imports.package.init({
  name: APPLICATION_ID,
  version: VERSION,
  prefix: PREFIX,
  libdir: LIBDIR,
  datadir: DATADIR
});
pkg.initGettext();
const loop = GLib.MainLoop.new(null, false);
async function main(argv) {
  const application = new Application();
  const exitCode = await application.runAsync(argv);
  loop.quit();
  return exitCode;
}
try {
  const exitCode = await main(
    [programInvocationName].concat(ARGV)
  );
  log("exitCode: " + exitCode);
  exit(exitCode);
} catch (error) {
  console.error("An error occurred:", error);
  exit(1);
} finally {
  if (loop.is_running()) {
    loop.quit();
  }
}
